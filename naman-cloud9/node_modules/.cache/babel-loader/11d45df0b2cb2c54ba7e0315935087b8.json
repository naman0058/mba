{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Constants } from \"../util/constants\";\nimport { DEFAULT_CLIENT_MAX_RETRY_COUNT } from \"../util/throttlingRetryStrategy\";\nimport { delay } from \"@azure/core-util\";\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n * @returns\n */\n\nexport function throttlingRetryPolicy() {\n  return {\n    create: (nextPolicy, options) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    }\n  };\n}\nconst StandardAbortMessage = \"The operation was aborted.\";\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\n\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, _handleResponse) {\n    super(nextPolicy, options);\n    this.numberOfRetries = 0;\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  async sendRequest(httpRequest) {\n    const response = await this._nextPolicy.sendRequest(httpRequest.clone());\n\n    if (response.status !== StatusCodes.TooManyRequests && response.status !== StatusCodes.ServiceUnavailable) {\n      return response;\n    } else {\n      return this._handleResponse(httpRequest, response);\n    }\n  }\n\n  async _defaultResponseHandler(httpRequest, httpResponse) {\n    var _a;\n\n    const retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);\n\n    if (retryAfterHeader) {\n      const delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n\n      if (delayInMs) {\n        this.numberOfRetries += 1;\n        await delay(delayInMs, {\n          abortSignal: httpRequest.abortSignal,\n          abortErrorMsg: StandardAbortMessage\n        });\n\n        if ((_a = httpRequest.abortSignal) === null || _a === void 0 ? void 0 : _a.aborted) {\n          throw new AbortError(StandardAbortMessage);\n        }\n\n        if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {\n          return this.sendRequest(httpRequest);\n        } else {\n          return this._nextPolicy.sendRequest(httpRequest);\n        }\n      }\n    }\n\n    return httpResponse;\n  }\n\n  static parseRetryAfterHeader(headerValue) {\n    const retryAfterInSeconds = Number(headerValue);\n\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  static parseDateRetryAfterHeader(headerValue) {\n    try {\n      const now = Date.now();\n      const date = Date.parse(headerValue);\n      const diff = date - now;\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error) {\n      return undefined;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/policies/throttlingRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { Constants } from \"../util/constants\";\nimport { DEFAULT_CLIENT_MAX_RETRY_COUNT } from \"../util/throttlingRetryStrategy\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { delay } from \"@azure/core-util\";\n\ntype ResponseHandler = (\n  httpRequest: WebResourceLike,\n  response: HttpOperationResponse\n) => Promise<HttpOperationResponse>;\nconst StatusCodes = Constants.HttpConstants.StatusCodes;\n\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n * @returns\n */\nexport function throttlingRetryPolicy(): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ThrottlingRetryPolicy(nextPolicy, options);\n    },\n  };\n}\n\nconst StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * Creates a policy that re-sends the request if the response indicates the request failed because of throttling reasons.\n * For example, if the response contains a `Retry-After` header, it will retry sending the request based on the value of that header.\n *\n * To learn more, please refer to\n * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,\n * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and\n * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors\n */\nexport class ThrottlingRetryPolicy extends BaseRequestPolicy {\n  private _handleResponse: ResponseHandler;\n  private numberOfRetries = 0;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    _handleResponse?: ResponseHandler\n  ) {\n    super(nextPolicy, options);\n    this._handleResponse = _handleResponse || this._defaultResponseHandler;\n  }\n\n  public async sendRequest(httpRequest: WebResourceLike): Promise<HttpOperationResponse> {\n    const response = await this._nextPolicy.sendRequest(httpRequest.clone());\n    if (\n      response.status !== StatusCodes.TooManyRequests &&\n      response.status !== StatusCodes.ServiceUnavailable\n    ) {\n      return response;\n    } else {\n      return this._handleResponse(httpRequest, response);\n    }\n  }\n\n  private async _defaultResponseHandler(\n    httpRequest: WebResourceLike,\n    httpResponse: HttpOperationResponse\n  ): Promise<HttpOperationResponse> {\n    const retryAfterHeader: string | undefined = httpResponse.headers.get(\n      Constants.HeaderConstants.RETRY_AFTER\n    );\n\n    if (retryAfterHeader) {\n      const delayInMs: number | undefined =\n        ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);\n      if (delayInMs) {\n        this.numberOfRetries += 1;\n\n        await delay(delayInMs, {\n          abortSignal: httpRequest.abortSignal,\n          abortErrorMsg: StandardAbortMessage,\n        });\n\n        if (httpRequest.abortSignal?.aborted) {\n          throw new AbortError(StandardAbortMessage);\n        }\n\n        if (this.numberOfRetries < DEFAULT_CLIENT_MAX_RETRY_COUNT) {\n          return this.sendRequest(httpRequest);\n        } else {\n          return this._nextPolicy.sendRequest(httpRequest);\n        }\n      }\n    }\n\n    return httpResponse;\n  }\n\n  public static parseRetryAfterHeader(headerValue: string): number | undefined {\n    const retryAfterInSeconds = Number(headerValue);\n    if (Number.isNaN(retryAfterInSeconds)) {\n      return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);\n    } else {\n      return retryAfterInSeconds * 1000;\n    }\n  }\n\n  public static parseDateRetryAfterHeader(headerValue: string): number | undefined {\n    try {\n      const now: number = Date.now();\n      const date: number = Date.parse(headerValue);\n      const diff = date - now;\n\n      return Number.isNaN(diff) ? undefined : diff;\n    } catch (error: any) {\n      return undefined;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}