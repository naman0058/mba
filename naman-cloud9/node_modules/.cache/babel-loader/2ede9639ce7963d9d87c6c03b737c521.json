{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { base64ToBytes, bufferToBase64 } from \"./base64.browser\";\nimport { bufferToHex } from \"./hex\";\nimport { utf8ToBytes } from \"./utf8.browser\";\nlet subtleCrypto;\n/**\n * Returns a cached reference to the Web API crypto.subtle object.\n * @internal\n */\n\nfunction getCrypto() {\n  if (subtleCrypto) {\n    return subtleCrypto;\n  }\n\n  if (!self.crypto || !self.crypto.subtle) {\n    throw new Error(\"Your browser environment does not support cryptography functions.\");\n  }\n\n  subtleCrypto = self.crypto.subtle;\n  return subtleCrypto;\n}\n/**\n * Generates a SHA-256 HMAC signature.\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n * @param stringToSign - The data to be signed.\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\n\n\nexport async function computeSha256Hmac(key, stringToSign, encoding) {\n  const crypto = getCrypto();\n  const keyBytes = base64ToBytes(key);\n  const stringToSignBytes = utf8ToBytes(stringToSign);\n  const cryptoKey = await crypto.importKey(\"raw\", keyBytes, {\n    name: \"HMAC\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, false, [\"sign\"]);\n  const signature = await crypto.sign({\n    name: \"HMAC\",\n    hash: {\n      name: \"SHA-256\"\n    }\n  }, cryptoKey, stringToSignBytes);\n\n  switch (encoding) {\n    case \"base64\":\n      return bufferToBase64(signature);\n\n    case \"hex\":\n      return bufferToHex(signature);\n  }\n}\n/**\n * Generates a SHA-256 hash.\n * @param content - The data to be included in the hash.\n * @param encoding - The textual encoding to use for the returned hash.\n */\n\nexport async function computeSha256Hash(content, encoding) {\n  const contentBytes = utf8ToBytes(content);\n  const digest = await getCrypto().digest({\n    name: \"SHA-256\"\n  }, contentBytes);\n\n  switch (encoding) {\n    case \"base64\":\n      return bufferToBase64(digest);\n\n    case \"hex\":\n      return bufferToHex(digest);\n  }\n}","map":{"version":3,"sources":["../../src/sha256.browser.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAAS,aAAT,EAAwB,cAAxB,QAA8C,kBAA9C;AACA,SAAS,WAAT,QAA4B,OAA5B;AACA,SAAS,WAAT,QAA4B,gBAA5B;AA6CA,IAAI,YAAJ;AAEA;;;AAGG;;AACH,SAAS,SAAT,GAAkB;AAChB,MAAI,YAAJ,EAAkB;AAChB,WAAO,YAAP;AACD;;AAED,MAAI,CAAC,IAAI,CAAC,MAAN,IAAgB,CAAC,IAAI,CAAC,MAAL,CAAY,MAAjC,EAAyC;AACvC,UAAM,IAAI,KAAJ,CAAU,mEAAV,CAAN;AACD;;AAED,EAAA,YAAY,GAAG,IAAI,CAAC,MAAL,CAAY,MAA3B;AACA,SAAO,YAAP;AACD;AAED;;;;;AAKG;;;AACH,OAAO,eAAe,iBAAf,CACL,GADK,EAEL,YAFK,EAGL,QAHK,EAGqB;AAE1B,QAAM,MAAM,GAAG,SAAS,EAAxB;AACA,QAAM,QAAQ,GAAG,aAAa,CAAC,GAAD,CAA9B;AACA,QAAM,iBAAiB,GAAG,WAAW,CAAC,YAAD,CAArC;AAEA,QAAM,SAAS,GAAG,MAAM,MAAM,CAAC,SAAP,CACtB,KADsB,EAEtB,QAFsB,EAGtB;AACE,IAAA,IAAI,EAAE,MADR;AAEE,IAAA,IAAI,EAAE;AAAE,MAAA,IAAI,EAAE;AAAR;AAFR,GAHsB,EAOtB,KAPsB,EAQtB,CAAC,MAAD,CARsB,CAAxB;AAUA,QAAM,SAAS,GAAG,MAAM,MAAM,CAAC,IAAP,CACtB;AACE,IAAA,IAAI,EAAE,MADR;AAEE,IAAA,IAAI,EAAE;AAAE,MAAA,IAAI,EAAE;AAAR;AAFR,GADsB,EAKtB,SALsB,EAMtB,iBANsB,CAAxB;;AASA,UAAQ,QAAR;AACE,SAAK,QAAL;AACE,aAAO,cAAc,CAAC,SAAD,CAArB;;AACF,SAAK,KAAL;AACE,aAAO,WAAW,CAAC,SAAD,CAAlB;AAJJ;AAMD;AAED;;;;AAIG;;AACH,OAAO,eAAe,iBAAf,CACL,OADK,EAEL,QAFK,EAEqB;AAE1B,QAAM,YAAY,GAAG,WAAW,CAAC,OAAD,CAAhC;AACA,QAAM,MAAM,GAAG,MAAM,SAAS,GAAG,MAAZ,CAAmB;AAAE,IAAA,IAAI,EAAE;AAAR,GAAnB,EAAwC,YAAxC,CAArB;;AAEA,UAAQ,QAAR;AACE,SAAK,QAAL;AACE,aAAO,cAAc,CAAC,MAAD,CAArB;;AACF,SAAK,KAAL;AACE,aAAO,WAAW,CAAC,MAAD,CAAlB;AAJJ;AAMD","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { base64ToBytes, bufferToBase64 } from \"./base64.browser\";\nimport { bufferToHex } from \"./hex\";\nimport { utf8ToBytes } from \"./utf8.browser\";\n\n// stubs for browser self.crypto\ninterface JsonWebKey {}\ninterface CryptoKey {}\ntype KeyUsage =\n  | \"decrypt\"\n  | \"deriveBits\"\n  | \"deriveKey\"\n  | \"encrypt\"\n  | \"sign\"\n  | \"unwrapKey\"\n  | \"verify\"\n  | \"wrapKey\";\ninterface Algorithm {\n  name: string;\n}\ninterface SubtleCrypto {\n  importKey(\n    format: string,\n    keyData: JsonWebKey,\n    algorithm: HmacImportParams,\n    extractable: boolean,\n    usage: KeyUsage[]\n  ): Promise<CryptoKey>;\n  sign(\n    algorithm: HmacImportParams,\n    key: CryptoKey,\n    data: ArrayBufferView | ArrayBuffer\n  ): Promise<ArrayBuffer>;\n  digest(algorithm: Algorithm, data: ArrayBufferView | ArrayBuffer): Promise<ArrayBuffer>;\n}\ninterface Crypto {\n  readonly subtle: SubtleCrypto;\n  getRandomValues<T extends ArrayBufferView | null>(array: T): T;\n}\ndeclare const self: {\n  crypto: Crypto;\n};\ninterface HmacImportParams {\n  name: string;\n  hash: Algorithm;\n  length?: number;\n}\n\nlet subtleCrypto: SubtleCrypto | undefined;\n\n/**\n * Returns a cached reference to the Web API crypto.subtle object.\n * @internal\n */\nfunction getCrypto(): SubtleCrypto {\n  if (subtleCrypto) {\n    return subtleCrypto;\n  }\n\n  if (!self.crypto || !self.crypto.subtle) {\n    throw new Error(\"Your browser environment does not support cryptography functions.\");\n  }\n\n  subtleCrypto = self.crypto.subtle;\n  return subtleCrypto;\n}\n\n/**\n * Generates a SHA-256 HMAC signature.\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n * @param stringToSign - The data to be signed.\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\nexport async function computeSha256Hmac(\n  key: string,\n  stringToSign: string,\n  encoding: \"base64\" | \"hex\"\n): Promise<string> {\n  const crypto = getCrypto();\n  const keyBytes = base64ToBytes(key);\n  const stringToSignBytes = utf8ToBytes(stringToSign);\n\n  const cryptoKey = await crypto.importKey(\n    \"raw\",\n    keyBytes,\n    {\n      name: \"HMAC\",\n      hash: { name: \"SHA-256\" },\n    },\n    false,\n    [\"sign\"]\n  );\n  const signature = await crypto.sign(\n    {\n      name: \"HMAC\",\n      hash: { name: \"SHA-256\" },\n    },\n    cryptoKey,\n    stringToSignBytes\n  );\n\n  switch (encoding) {\n    case \"base64\":\n      return bufferToBase64(signature);\n    case \"hex\":\n      return bufferToHex(signature);\n  }\n}\n\n/**\n * Generates a SHA-256 hash.\n * @param content - The data to be included in the hash.\n * @param encoding - The textual encoding to use for the returned hash.\n */\nexport async function computeSha256Hash(\n  content: string,\n  encoding: \"base64\" | \"hex\"\n): Promise<string> {\n  const contentBytes = utf8ToBytes(content);\n  const digest = await getCrypto().digest({ name: \"SHA-256\" }, contentBytes);\n\n  switch (encoding) {\n    case \"base64\":\n      return bufferToBase64(digest);\n    case \"hex\":\n      return bufferToHex(digest);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}