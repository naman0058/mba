{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, shouldRetry, updateRetryData } from \"../util/exponentialBackoffStrategy\";\nimport { Constants } from \"../util/constants\";\nimport { RestError } from \"../restError\";\nimport { delay } from \"@azure/core-util\";\nimport { logger } from \"../log\";\n/**\n * Policy that retries the request as many times as configured for as long as the max retry time interval specified, each retry waiting longer to begin than the last time.\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - Base time between retries.\n * @param maxRetryInterval - Maximum time to wait between retries.\n */\n\nexport function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\n\nexport var RetryMode;\n\n(function (RetryMode) {\n  /**\n   * Currently supported retry mode.\n   * Each time a retry happens, it will take exponentially more time than the last time.\n   */\n  RetryMode[RetryMode[\"Exponential\"] = 0] = \"Exponential\";\n})(RetryMode || (RetryMode = {}));\n\nexport const DefaultRetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL\n};\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\n\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).then(response => retry(this, request, response)).catch(error => retry(this, request, error.response, undefined, error));\n  }\n\n}\n\nasync function retry(policy, request, response, retryData, requestError) {\n  function shouldPolicyRetry(responseParam) {\n    const statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;\n\n    if (statusCode === 503 && (response === null || response === void 0 ? void 0 : response.headers.get(Constants.HeaderConstants.RETRY_AFTER))) {\n      return false;\n    }\n\n    if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) {\n      return false;\n    }\n\n    return true;\n  }\n\n  retryData = updateRetryData({\n    retryInterval: policy.retryInterval,\n    minRetryInterval: 0,\n    maxRetryInterval: policy.maxRetryInterval\n  }, retryData, requestError);\n  const isAborted = request.abortSignal && request.abortSignal.aborted;\n\n  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n\n    try {\n      await delay(retryData.retryInterval);\n      const res = await policy._nextPolicy.sendRequest(request.clone());\n      return retry(policy, request, res, retryData);\n    } catch (err) {\n      return retry(policy, request, response, retryData, err);\n    }\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err = retryData.error || new RestError(\"Failed to send the request.\", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);\n    throw err;\n  } else {\n    return response;\n  }\n}","map":{"version":3,"sources":["../../../src/policies/exponentialRetryPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n  DEFAULT_CLIENT_RETRY_COUNT,\n  DEFAULT_CLIENT_RETRY_INTERVAL,\n  RetryData,\n  RetryError,\n  isNumber,\n  shouldRetry,\n  updateRetryData,\n} from \"../util/exponentialBackoffStrategy\";\nimport { Constants } from \"../util/constants\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { RestError } from \"../restError\";\nimport { WebResourceLike } from \"../webResource\";\nimport { delay } from \"@azure/core-util\";\nimport { logger } from \"../log\";\n\n/**\n * Policy that retries the request as many times as configured for as long as the max retry time interval specified, each retry waiting longer to begin than the last time.\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - Base time between retries.\n * @param maxRetryInterval - Maximum time to wait between retries.\n */\nexport function exponentialRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new ExponentialRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        maxRetryInterval\n      );\n    },\n  };\n}\n\n/**\n * Describes the Retry Mode type. Currently supporting only Exponential.\n */\nexport enum RetryMode {\n  /**\n   * Currently supported retry mode.\n   * Each time a retry happens, it will take exponentially more time than the last time.\n   */\n  Exponential,\n}\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface RetryOptions {\n  /**\n   * The maximum number of retry attempts.  Defaults to 3.\n   */\n  maxRetries?: number;\n\n  /**\n   * The amount of delay in milliseconds between retry attempts. Defaults to 30000\n   * (30 seconds). The delay increases exponentially with each retry up to a maximum\n   * specified by maxRetryDelayInMs.\n   */\n  retryDelayInMs?: number;\n\n  /**\n   * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n   * to 90000 (90 seconds).\n   */\n  maxRetryDelayInMs?: number;\n\n  /**\n   * Currently supporting only Exponential mode.\n   */\n  mode?: RetryMode;\n}\n\nexport const DefaultRetryOptions: RetryOptions = {\n  maxRetries: DEFAULT_CLIENT_RETRY_COUNT,\n  retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,\n  maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n};\n\n/**\n * Instantiates a new \"ExponentialRetryPolicyFilter\" instance.\n */\nexport class ExponentialRetryPolicy extends BaseRequestPolicy {\n  /**\n   * The client retry count.\n   */\n  retryCount: number;\n  /**\n   * The client retry interval in milliseconds.\n   */\n  retryInterval: number;\n  /**\n   * The maximum retry interval in milliseconds.\n   */\n  maxRetryInterval: number;\n\n  /**\n   * @param nextPolicy - The next RequestPolicy in the pipeline chain.\n   * @param options - The options for this RequestPolicy.\n   * @param retryCount - The client retry count.\n   * @param retryInterval - The client retry interval, in milliseconds.\n   * @param minRetryInterval - The minimum retry interval, in milliseconds.\n   * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n   */\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .then((response) => retry(this, request, response))\n      .catch((error) => retry(this, request, error.response, undefined, error));\n  }\n}\n\nasync function retry(\n  policy: ExponentialRetryPolicy,\n  request: WebResourceLike,\n  response?: HttpOperationResponse,\n  retryData?: RetryData,\n  requestError?: RetryError\n): Promise<HttpOperationResponse> {\n  function shouldPolicyRetry(responseParam?: HttpOperationResponse): boolean {\n    const statusCode = responseParam?.status;\n    if (statusCode === 503 && response?.headers.get(Constants.HeaderConstants.RETRY_AFTER)) {\n      return false;\n    }\n\n    if (\n      statusCode === undefined ||\n      (statusCode < 500 && statusCode !== 408) ||\n      statusCode === 501 ||\n      statusCode === 505\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  retryData = updateRetryData(\n    {\n      retryInterval: policy.retryInterval,\n      minRetryInterval: 0,\n      maxRetryInterval: policy.maxRetryInterval,\n    },\n    retryData,\n    requestError\n  );\n\n  const isAborted: boolean | undefined = request.abortSignal && request.abortSignal.aborted;\n  if (!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response)) {\n    logger.info(`Retrying request in ${retryData.retryInterval}`);\n    try {\n      await delay(retryData.retryInterval);\n      const res = await policy._nextPolicy.sendRequest(request.clone());\n      return retry(policy, request, res, retryData);\n    } catch (err: any) {\n      return retry(policy, request, response, retryData, err);\n    }\n  } else if (isAborted || requestError || !response) {\n    // If the operation failed in the end, return all errors instead of just the last one\n    const err =\n      retryData.error ||\n      new RestError(\n        \"Failed to send the request.\",\n        RestError.REQUEST_SEND_ERROR,\n        response && response.status,\n        response && response.request,\n        response\n      );\n    throw err;\n  } else {\n    return response;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}