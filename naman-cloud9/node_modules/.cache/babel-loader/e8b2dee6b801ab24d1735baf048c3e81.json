{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nvar MutexLockStatus;\n\n(function (MutexLockStatus) {\n  MutexLockStatus[MutexLockStatus[\"LOCKED\"] = 0] = \"LOCKED\";\n  MutexLockStatus[MutexLockStatus[\"UNLOCKED\"] = 1] = \"UNLOCKED\";\n})(MutexLockStatus || (MutexLockStatus = {}));\n/**\n * An async mutex lock.\n */\n\n\nexport class Mutex {\n  /**\n   * Lock for a specific key. If the lock has been acquired by another customer, then\n   * will wait until getting the lock.\n   *\n   * @param key - lock key\n   */\n  static async lock(key) {\n    return new Promise(resolve => {\n      if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {\n        this.keys[key] = MutexLockStatus.LOCKED;\n        resolve();\n      } else {\n        this.onUnlockEvent(key, () => {\n          this.keys[key] = MutexLockStatus.LOCKED;\n          resolve();\n        });\n      }\n    });\n  }\n  /**\n   * Unlock a key.\n   *\n   * @param key -\n   */\n\n\n  static async unlock(key) {\n    return new Promise(resolve => {\n      if (this.keys[key] === MutexLockStatus.LOCKED) {\n        this.emitUnlockEvent(key);\n      }\n\n      delete this.keys[key];\n      resolve();\n    });\n  }\n\n  static onUnlockEvent(key, handler) {\n    if (this.listeners[key] === undefined) {\n      this.listeners[key] = [handler];\n    } else {\n      this.listeners[key].push(handler);\n    }\n  }\n\n  static emitUnlockEvent(key) {\n    if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {\n      const handler = this.listeners[key].shift();\n      setImmediate(() => {\n        handler.call(this);\n      });\n    }\n  }\n\n}\nMutex.keys = {};\nMutex.listeners = {};","map":{"version":3,"sources":["../../../../src/utils/Mutex.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,IAAK,eAAL;;AAAA,CAAA,UAAK,eAAL,EAAoB;AAClB,EAAA,eAAA,CAAA,eAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAA,eAAA,CAAA,eAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACD,CAHD,EAAK,eAAe,KAAf,eAAe,GAAA,EAAA,CAApB;AAOA;;AAEG;;;AACH,OAAM,MAAO,KAAP,CAAY;AAChB;;;;;AAKG;AACqB,eAAJ,IAAI,CAAC,GAAD,EAAY;AAClC,WAAO,IAAI,OAAJ,CAAmB,OAAD,IAAY;AACnC,UAAI,KAAK,IAAL,CAAU,GAAV,MAAmB,SAAnB,IAAgC,KAAK,IAAL,CAAU,GAAV,MAAmB,eAAe,CAAC,QAAvE,EAAiF;AAC/E,aAAK,IAAL,CAAU,GAAV,IAAiB,eAAe,CAAC,MAAjC;AACA,QAAA,OAAO;AACR,OAHD,MAGO;AACL,aAAK,aAAL,CAAmB,GAAnB,EAAwB,MAAK;AAC3B,eAAK,IAAL,CAAU,GAAV,IAAiB,eAAe,CAAC,MAAjC;AACA,UAAA,OAAO;AACR,SAHD;AAID;AACF,KAVM,CAAP;AAWD;AAED;;;;AAIG;;;AACuB,eAAN,MAAM,CAAC,GAAD,EAAY;AACpC,WAAO,IAAI,OAAJ,CAAmB,OAAD,IAAY;AACnC,UAAI,KAAK,IAAL,CAAU,GAAV,MAAmB,eAAe,CAAC,MAAvC,EAA+C;AAC7C,aAAK,eAAL,CAAqB,GAArB;AACD;;AACD,aAAO,KAAK,IAAL,CAAU,GAAV,CAAP;AACA,MAAA,OAAO;AACR,KANM,CAAP;AAOD;;AAK2B,SAAb,aAAa,CAAC,GAAD,EAAc,OAAd,EAA+B;AACzD,QAAI,KAAK,SAAL,CAAe,GAAf,MAAwB,SAA5B,EAAuC;AACrC,WAAK,SAAL,CAAe,GAAf,IAAsB,CAAC,OAAD,CAAtB;AACD,KAFD,MAEO;AACL,WAAK,SAAL,CAAe,GAAf,EAAoB,IAApB,CAAyB,OAAzB;AACD;AACF;;AAE6B,SAAf,eAAe,CAAC,GAAD,EAAY;AACxC,QAAI,KAAK,SAAL,CAAe,GAAf,MAAwB,SAAxB,IAAqC,KAAK,SAAL,CAAe,GAAf,EAAoB,MAApB,GAA6B,CAAtE,EAAyE;AACvE,YAAM,OAAO,GAAG,KAAK,SAAL,CAAe,GAAf,EAAoB,KAApB,EAAhB;AACA,MAAA,YAAY,CAAC,MAAK;AAChB,QAAA,OAAQ,CAAC,IAAT,CAAc,IAAd;AACD,OAFW,CAAZ;AAGD;AACF;;AAtDe;AAoCD,KAAA,CAAA,IAAA,GAA2C,EAA3C;AACA,KAAA,CAAA,SAAA,GAA2C,EAA3C","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nenum MutexLockStatus {\n  LOCKED,\n  UNLOCKED,\n}\n\ntype Callback = (...args: any[]) => any;\n\n/**\n * An async mutex lock.\n */\nexport class Mutex {\n  /**\n   * Lock for a specific key. If the lock has been acquired by another customer, then\n   * will wait until getting the lock.\n   *\n   * @param key - lock key\n   */\n  public static async lock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === undefined || this.keys[key] === MutexLockStatus.UNLOCKED) {\n        this.keys[key] = MutexLockStatus.LOCKED;\n        resolve();\n      } else {\n        this.onUnlockEvent(key, () => {\n          this.keys[key] = MutexLockStatus.LOCKED;\n          resolve();\n        });\n      }\n    });\n  }\n\n  /**\n   * Unlock a key.\n   *\n   * @param key -\n   */\n  public static async unlock(key: string): Promise<void> {\n    return new Promise<void>((resolve) => {\n      if (this.keys[key] === MutexLockStatus.LOCKED) {\n        this.emitUnlockEvent(key);\n      }\n      delete this.keys[key];\n      resolve();\n    });\n  }\n\n  private static keys: { [key: string]: MutexLockStatus } = {};\n  private static listeners: { [key: string]: Callback[] } = {};\n\n  private static onUnlockEvent(key: string, handler: Callback) {\n    if (this.listeners[key] === undefined) {\n      this.listeners[key] = [handler];\n    } else {\n      this.listeners[key].push(handler);\n    }\n  }\n\n  private static emitUnlockEvent(key: string) {\n    if (this.listeners[key] !== undefined && this.listeners[key].length > 0) {\n      const handler = this.listeners[key].shift();\n      setImmediate(() => {\n        handler!.call(this);\n      });\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}