{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { SpanKind, setSpan, context as otContext, getTracer } from \"./interfaces\";\nimport { trace, INVALID_SPAN_CONTEXT } from \"@opentelemetry/api\";\nexport function isTracingDisabled() {\n  var _a;\n\n  if (typeof process === \"undefined\") {\n    // not supported in browser for now without polyfills\n    return false;\n  }\n\n  const azureTracingDisabledValue = (_a = process.env.AZURE_TRACING_DISABLED) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n\n  if (azureTracingDisabledValue === \"false\" || azureTracingDisabledValue === \"0\") {\n    return false;\n  }\n\n  return Boolean(azureTracingDisabledValue);\n}\n/**\n * Creates a function that can be used to create spans using the global tracer.\n *\n * Usage:\n *\n * ```typescript\n * // once\n * const createSpan = createSpanFunction({ packagePrefix: \"Azure.Data.AppConfiguration\", namespace: \"Microsoft.AppConfiguration\" });\n *\n * // in each operation\n * const span = createSpan(\"deleteConfigurationSetting\", operationOptions);\n *    // code...\n * span.end();\n * ```\n *\n * @hidden\n * @param args - allows configuration of the prefix for each span as well as the az.namespace field.\n */\n\nexport function createSpanFunction(args) {\n  return function (operationName, operationOptions) {\n    const tracer = getTracer();\n    const tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};\n    const spanOptions = Object.assign({\n      kind: SpanKind.INTERNAL\n    }, tracingOptions.spanOptions);\n    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;\n    let span;\n\n    if (isTracingDisabled()) {\n      span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n    } else {\n      span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);\n    }\n\n    if (args.namespace) {\n      span.setAttribute(\"az.namespace\", args.namespace);\n    }\n\n    let newSpanOptions = tracingOptions.spanOptions || {};\n\n    if (span.isRecording() && args.namespace) {\n      newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), {\n        attributes: Object.assign(Object.assign({}, spanOptions.attributes), {\n          \"az.namespace\": args.namespace\n        })\n      });\n    }\n\n    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), {\n      spanOptions: newSpanOptions,\n      tracingContext: setSpan(tracingOptions.tracingContext || otContext.active(), span)\n    });\n    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), {\n      tracingOptions: newTracingOptions\n    });\n    return {\n      span,\n      updatedOptions: newOperationOptions\n    };\n  };\n}","map":{"version":3,"sources":["../../src/createSpan.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAIE,QAJF,EAKE,OALF,EAME,OAAO,IAAI,SANb,EAOE,SAPF,QAQO,cARP;AASA,SAAS,KAAT,EAAgB,oBAAhB,QAA4C,oBAA5C;AAuBA,OAAM,SAAU,iBAAV,GAA2B;;;AAC/B,MAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC;AAClC;AACA,WAAO,KAAP;AACD;;AAED,QAAM,yBAAyB,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,GAAR,CAAY,sBAAZ,MAAkC,IAAlC,IAAkC,EAAA,KAAA,KAAA,CAAlC,GAAkC,KAAA,CAAlC,GAAkC,EAAA,CAAE,WAAF,EAApE;;AAEA,MAAI,yBAAyB,KAAK,OAA9B,IAAyC,yBAAyB,KAAK,GAA3E,EAAgF;AAC9E,WAAO,KAAP;AACD;;AAED,SAAO,OAAO,CAAC,yBAAD,CAAd;AACD;AAED;;;;;;;;;;;;;;;;;AAiBG;;AACH,OAAM,SAAU,kBAAV,CAA6B,IAA7B,EAAyD;AAC7D,SAAO,UACL,aADK,EAEL,gBAFK,EAE0B;AAE/B,UAAM,MAAM,GAAG,SAAS,EAAxB;AACA,UAAM,cAAc,GAAG,CAAA,gBAAgB,KAAA,IAAhB,IAAA,gBAAgB,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAA,gBAAgB,CAAE,cAAlB,KAAoC,EAA3D;AACA,UAAM,WAAW,GAAA,MAAA,CAAA,MAAA,CAAA;AACf,MAAA,IAAI,EAAE,QAAQ,CAAC;AADA,KAAA,EAEZ,cAAc,CAAC,WAFH,CAAjB;AAKA,UAAM,QAAQ,GAAG,IAAI,CAAC,aAAL,GAAqB,GAAG,IAAI,CAAC,aAAa,IAAI,aAAa,EAA3D,GAAgE,aAAjF;AAEA,QAAI,IAAJ;;AACA,QAAI,iBAAiB,EAArB,EAAyB;AACvB,MAAA,IAAI,GAAG,KAAK,CAAC,eAAN,CAAsB,oBAAtB,CAAP;AACD,KAFD,MAEO;AACL,MAAA,IAAI,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAjB,EAA2B,WAA3B,EAAwC,cAAc,CAAC,cAAvD,CAAP;AACD;;AAED,QAAI,IAAI,CAAC,SAAT,EAAoB;AAClB,MAAA,IAAI,CAAC,YAAL,CAAkB,cAAlB,EAAkC,IAAI,CAAC,SAAvC;AACD;;AAED,QAAI,cAAc,GAAG,cAAc,CAAC,WAAf,IAA8B,EAAnD;;AAEA,QAAI,IAAI,CAAC,WAAL,MAAsB,IAAI,CAAC,SAA/B,EAA0C;AACxC,MAAA,cAAc,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACT,cAAc,CAAC,WADN,CAAA,EACiB;AAC7B,QAAA,UAAU,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACL,WAAW,CAAC,UADP,CAAA,EACiB;AACzB,0BAAgB,IAAI,CAAC;AADI,SADjB;AADmB,OADjB,CAAd;AAOD;;AAED,UAAM,iBAAiB,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAClB,cADkB,CAAA,EACJ;AACjB,MAAA,WAAW,EAAE,cADI;AAEjB,MAAA,cAAc,EAAE,OAAO,CAAC,cAAc,CAAC,cAAf,IAAiC,SAAS,CAAC,MAAV,EAAlC,EAAsD,IAAtD;AAFN,KADI,CAAvB;AAMA,UAAM,mBAAmB,GAAG,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACvB,gBADuB,CAAA,EACP;AACnB,MAAA,cAAc,EAAE;AADG,KADO,CAA5B;AAKA,WAAO;AACL,MAAA,IADK;AAEL,MAAA,cAAc,EAAE;AAFX,KAAP;AAID,GAnDD;AAoDD","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  OperationTracingOptions,\n  Span,\n  SpanOptions,\n  SpanKind,\n  setSpan,\n  context as otContext,\n  getTracer\n} from \"./interfaces\";\nimport { trace, INVALID_SPAN_CONTEXT } from \"@opentelemetry/api\";\n\n/**\n * Arguments for `createSpanFunction` that allow you to specify the\n * prefix for each created span as well as the `az.namespace` attribute.\n *\n * @hidden\n */\nexport interface CreateSpanFunctionArgs {\n  /**\n   * Package name prefix.\n   *\n   * NOTE: if this is empty no prefix will be applied to created Span names.\n   */\n  packagePrefix: string;\n  /**\n   * Service namespace\n   *\n   * NOTE: if this is empty no `az.namespace` attribute will be added to created Spans.\n   */\n  namespace: string;\n}\n\nexport function isTracingDisabled(): boolean {\n  if (typeof process === \"undefined\") {\n    // not supported in browser for now without polyfills\n    return false;\n  }\n\n  const azureTracingDisabledValue = process.env.AZURE_TRACING_DISABLED?.toLowerCase();\n\n  if (azureTracingDisabledValue === \"false\" || azureTracingDisabledValue === \"0\") {\n    return false;\n  }\n\n  return Boolean(azureTracingDisabledValue);\n}\n\n/**\n * Creates a function that can be used to create spans using the global tracer.\n *\n * Usage:\n *\n * ```typescript\n * // once\n * const createSpan = createSpanFunction({ packagePrefix: \"Azure.Data.AppConfiguration\", namespace: \"Microsoft.AppConfiguration\" });\n *\n * // in each operation\n * const span = createSpan(\"deleteConfigurationSetting\", operationOptions);\n *    // code...\n * span.end();\n * ```\n *\n * @hidden\n * @param args - allows configuration of the prefix for each span as well as the az.namespace field.\n */\nexport function createSpanFunction(args: CreateSpanFunctionArgs) {\n  return function<T extends { tracingOptions?: OperationTracingOptions }>(\n    operationName: string,\n    operationOptions: T | undefined\n  ): { span: Span; updatedOptions: T } {\n    const tracer = getTracer();\n    const tracingOptions = operationOptions?.tracingOptions || {};\n    const spanOptions: SpanOptions = {\n      kind: SpanKind.INTERNAL,\n      ...tracingOptions.spanOptions\n    };\n\n    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;\n\n    let span: Span;\n    if (isTracingDisabled()) {\n      span = trace.wrapSpanContext(INVALID_SPAN_CONTEXT);\n    } else {\n      span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);\n    }\n\n    if (args.namespace) {\n      span.setAttribute(\"az.namespace\", args.namespace);\n    }\n\n    let newSpanOptions = tracingOptions.spanOptions || {};\n\n    if (span.isRecording() && args.namespace) {\n      newSpanOptions = {\n        ...tracingOptions.spanOptions,\n        attributes: {\n          ...spanOptions.attributes,\n          \"az.namespace\": args.namespace\n        }\n      };\n    }\n\n    const newTracingOptions: Required<OperationTracingOptions> = {\n      ...tracingOptions,\n      spanOptions: newSpanOptions,\n      tracingContext: setSpan(tracingOptions.tracingContext || otContext.active(), span)\n    };\n\n    const newOperationOptions = {\n      ...operationOptions,\n      tracingOptions: newTracingOptions\n    } as T & { tracingOptions: Required<OperationTracingOptions> };\n\n    return {\n      span,\n      updatedOptions: newOperationOptions\n    };\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}