{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n/**\n * Deserializes the state\n */\n\nexport function deserializeState(serializedState) {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError(inputs) {\n  const {\n    state,\n    stateProxy,\n    isOperationError\n  } = inputs;\n  return error => {\n    if (isOperationError(error)) {\n      stateProxy.setError(state, error);\n      stateProxy.setFailed(state);\n    }\n\n    throw error;\n  };\n}\n\nfunction processOperationStatus(result) {\n  const {\n    state,\n    stateProxy,\n    status,\n    isDone,\n    processResult,\n    response,\n    setErrorAsResult\n  } = result;\n\n  switch (status) {\n    case \"succeeded\":\n      {\n        stateProxy.setSucceeded(state);\n        break;\n      }\n\n    case \"failed\":\n      {\n        stateProxy.setError(state, new Error(`The long-running operation has failed`));\n        stateProxy.setFailed(state);\n        break;\n      }\n\n    case \"canceled\":\n      {\n        stateProxy.setCanceled(state);\n        break;\n      }\n  }\n\n  if ((isDone === null || isDone === void 0 ? void 0 : isDone(response, state)) || isDone === undefined && [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status)) {\n    stateProxy.setResult(state, buildResult({\n      response,\n      state,\n      processResult\n    }));\n  }\n}\n\nfunction buildResult(inputs) {\n  const {\n    processResult,\n    response,\n    state\n  } = inputs;\n  return processResult ? processResult(response, state) : response;\n}\n/**\n * Initiates the long-running operation.\n */\n\n\nexport async function initOperation(inputs) {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation,\n    resourceLocation,\n    metadata,\n    response\n  } = await init();\n  if (operationLocation) withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({\n    response,\n    state,\n    operationLocation\n  });\n  processOperationStatus({\n    state,\n    status,\n    stateProxy,\n    response,\n    setErrorAsResult,\n    processResult\n  });\n  return state;\n}\n\nasync function pollOperationHelper(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    isOperationError,\n    options\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(setStateError({\n    state,\n    stateProxy,\n    isOperationError\n  }));\n  const status = getOperationStatus(response, state);\n  logger.verbose(`LRO: Status:\\n\\tPolling from: ${state.config.operationLocation}\\n\\tOperation status: ${status}\\n\\tPolling status: ${terminalStates.includes(status) ? \"Stopped\" : \"Running\"}`);\n\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(setStateError({\n          state,\n          stateProxy,\n          isOperationError\n        })),\n        status\n      };\n    }\n  }\n\n  return {\n    response,\n    status\n  };\n}\n/** Polls the long-running operation. */\n\n\nexport async function pollOperation(inputs) {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    isOperationError,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult\n  } = inputs;\n  const {\n    operationLocation\n  } = state.config;\n\n  if (operationLocation !== undefined) {\n    const {\n      response,\n      status\n    } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      isOperationError,\n      options\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      setErrorAsResult\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval === null || getPollingInterval === void 0 ? void 0 : getPollingInterval(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation === null || getOperationLocation === void 0 ? void 0 : getOperationLocation(response, state);\n\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(location, isUpdated);\n      } else withOperationLocation === null || withOperationLocation === void 0 ? void 0 : withOperationLocation(operationLocation, false);\n    }\n\n    updateState === null || updateState === void 0 ? void 0 : updateState(state, response);\n  }\n}","map":{"version":3,"sources":["../../../src/poller/operation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Operation, OperationStatus, RestorableOperationState, StateProxy } from \"./models\";\nimport { logger } from \"../logger\";\nimport { terminalStates } from \"./constants\";\n\n/**\n * Deserializes the state\n */\nexport function deserializeState<TState>(\n  serializedState: string\n): RestorableOperationState<TState> {\n  try {\n    return JSON.parse(serializedState).state;\n  } catch (e) {\n    throw new Error(`Unable to deserialize input state: ${serializedState}`);\n  }\n}\n\nfunction setStateError<TState, TResult>(inputs: {\n  state: TState;\n  stateProxy: StateProxy<TState, TResult>;\n  isOperationError: (error: Error) => boolean;\n}): (error: Error) => never {\n  const { state, stateProxy, isOperationError } = inputs;\n  return (error: Error) => {\n    if (isOperationError(error)) {\n      stateProxy.setError(state, error);\n      stateProxy.setFailed(state);\n    }\n    throw error;\n  };\n}\n\nfunction processOperationStatus<TState, TResult, TResponse>(result: {\n  status: OperationStatus;\n  response: TResponse;\n  state: RestorableOperationState<TState>;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n}): void {\n  const { state, stateProxy, status, isDone, processResult, response, setErrorAsResult } = result;\n  switch (status) {\n    case \"succeeded\": {\n      stateProxy.setSucceeded(state);\n      break;\n    }\n    case \"failed\": {\n      stateProxy.setError(state, new Error(`The long-running operation has failed`));\n      stateProxy.setFailed(state);\n      break;\n    }\n    case \"canceled\": {\n      stateProxy.setCanceled(state);\n      break;\n    }\n  }\n  if (\n    isDone?.(response, state) ||\n    (isDone === undefined &&\n      [\"succeeded\", \"canceled\"].concat(setErrorAsResult ? [] : [\"failed\"]).includes(status))\n  ) {\n    stateProxy.setResult(\n      state,\n      buildResult({\n        response,\n        state,\n        processResult,\n      })\n    );\n  }\n}\n\nfunction buildResult<TResponse, TResult, TState>(inputs: {\n  response: TResponse;\n  state: TState;\n  processResult?: (result: TResponse, state: TState) => TResult;\n}): TResult {\n  const { processResult, response, state } = inputs;\n  return processResult ? processResult(response, state) : (response as unknown as TResult);\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initOperation<TResponse, TResult, TState>(inputs: {\n  init: Operation<TResponse, unknown>[\"init\"];\n  stateProxy: StateProxy<TState, TResult>;\n  getOperationStatus: (inputs: {\n    response: TResponse;\n    state: RestorableOperationState<TState>;\n    operationLocation?: string;\n  }) => OperationStatus;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  setErrorAsResult: boolean;\n}): Promise<RestorableOperationState<TState>> {\n  const {\n    init,\n    stateProxy,\n    processResult,\n    getOperationStatus,\n    withOperationLocation,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation, resourceLocation, metadata, response } = await init();\n  if (operationLocation) withOperationLocation?.(operationLocation, false);\n  const config = {\n    metadata,\n    operationLocation,\n    resourceLocation,\n  };\n  logger.verbose(`LRO: Operation description:`, config);\n  const state = stateProxy.initState(config);\n  const status = getOperationStatus({ response, state, operationLocation });\n  processOperationStatus({ state, status, stateProxy, response, setErrorAsResult, processResult });\n  return state;\n}\n\nasync function pollOperationHelper<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  operationLocation: string;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  options?: TOptions;\n}): Promise<{\n  status: OperationStatus;\n  response: TResponse;\n}> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    operationLocation,\n    getOperationStatus,\n    getResourceLocation,\n    isOperationError,\n    options,\n  } = inputs;\n  const response = await poll(operationLocation, options).catch(\n    setStateError({\n      state,\n      stateProxy,\n      isOperationError,\n    })\n  );\n  const status = getOperationStatus(response, state);\n  logger.verbose(\n    `LRO: Status:\\n\\tPolling from: ${\n      state.config.operationLocation\n    }\\n\\tOperation status: ${status}\\n\\tPolling status: ${\n      terminalStates.includes(status) ? \"Stopped\" : \"Running\"\n    }`\n  );\n  if (status === \"succeeded\") {\n    const resourceLocation = getResourceLocation(response, state);\n    if (resourceLocation !== undefined) {\n      return {\n        response: await poll(resourceLocation).catch(\n          setStateError({ state, stateProxy, isOperationError })\n        ),\n        status,\n      };\n    }\n  }\n  return { response, status };\n}\n\n/** Polls the long-running operation. */\nexport async function pollOperation<TResponse, TState, TResult, TOptions>(inputs: {\n  poll: Operation<TResponse, TOptions>[\"poll\"];\n  stateProxy: StateProxy<TState, TResult>;\n  state: RestorableOperationState<TState>;\n  getOperationStatus: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => OperationStatus;\n  getResourceLocation: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  isOperationError: (error: Error) => boolean;\n  getPollingInterval?: (response: TResponse) => number | undefined;\n  setDelay: (intervalInMs: number) => void;\n  getOperationLocation?: (\n    response: TResponse,\n    state: RestorableOperationState<TState>\n  ) => string | undefined;\n  withOperationLocation?: (operationLocation: string, isUpdated: boolean) => void;\n  processResult?: (result: TResponse, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: TResponse) => void;\n  isDone?: (lastResponse: TResponse, state: TState) => boolean;\n  setErrorAsResult: boolean;\n  options?: TOptions;\n}): Promise<void> {\n  const {\n    poll,\n    state,\n    stateProxy,\n    options,\n    getOperationStatus,\n    getResourceLocation,\n    getOperationLocation,\n    isOperationError,\n    withOperationLocation,\n    getPollingInterval,\n    processResult,\n    updateState,\n    setDelay,\n    isDone,\n    setErrorAsResult,\n  } = inputs;\n  const { operationLocation } = state.config;\n  if (operationLocation !== undefined) {\n    const { response, status } = await pollOperationHelper({\n      poll,\n      getOperationStatus,\n      state,\n      stateProxy,\n      operationLocation,\n      getResourceLocation,\n      isOperationError,\n      options,\n    });\n    processOperationStatus({\n      status,\n      response,\n      state,\n      stateProxy,\n      isDone,\n      processResult,\n      setErrorAsResult,\n    });\n\n    if (!terminalStates.includes(status)) {\n      const intervalInMs = getPollingInterval?.(response);\n      if (intervalInMs) setDelay(intervalInMs);\n      const location = getOperationLocation?.(response, state);\n      if (location !== undefined) {\n        const isUpdated = operationLocation !== location;\n        state.config.operationLocation = location;\n        withOperationLocation?.(location, isUpdated);\n      } else withOperationLocation?.(operationLocation, false);\n    }\n    updateState?.(state, response);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}