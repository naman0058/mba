{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport { DiagLogLevel } from '../diag/types';\nimport { getGlobal, registerGlobal, unregisterGlobal } from '../internal/global-utils';\nvar API_NAME = 'diag';\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\n\nvar DiagAPI =\n/** @class */\nfunction () {\n  /**\n   * Private internal constructor\n   * @private\n   */\n  function DiagAPI() {\n    function _logProxy(funcName) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var logger = getGlobal('diag'); // shortcut if logger not set\n\n        if (!logger) return;\n        return logger[funcName].apply(logger, __spreadArray([], __read(args), false));\n      };\n    } // Using self local variable for minification purposes as 'this' cannot be minified\n\n\n    var self = this; // DiagAPI specific functions\n\n    var setLogger = function (logger, optionsOrLogLevel) {\n      var _a, _b, _c;\n\n      if (optionsOrLogLevel === void 0) {\n        optionsOrLogLevel = {\n          logLevel: DiagLogLevel.INFO\n        };\n      }\n\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');\n        self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel\n        };\n      }\n\n      var oldLogger = getGlobal('diag');\n      var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger); // There already is an logger registered. We'll let it know before overwriting it.\n\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : '<failed to generate stacktrace>';\n        oldLogger.warn(\"Current logger will be overwritten from \" + stack);\n        newLogger.warn(\"Current logger will overwrite one already registered from \" + stack);\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = function () {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = function (options) {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n  /** Get the singleton instance of the DiagAPI API */\n\n\n  DiagAPI.instance = function () {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  };\n\n  return DiagAPI;\n}();\n\nexport { DiagAPI };","map":{"version":3,"sources":["../../../src/api/diag.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEH,SAAS,mBAAT,QAAoC,yBAApC;AACA,SAAS,wBAAT,QAAyC,iCAAzC;AACA,SAKE,YALF,QAMO,eANP;AAOA,SACE,SADF,EAEE,cAFF,EAGE,gBAHF,QAIO,0BAJP;AAMA,IAAM,QAAQ,GAAG,MAAjB;AAEA;;;AAGG;;AACH,IAAA,OAAA;AAAA;AAAA,YAAA;AAYE;;;AAGG;AACH,WAAA,OAAA,GAAA;AACE,aAAS,SAAT,CAAmB,QAAnB,EAA6C;AAC3C,aAAO,YAAA;AAAU,YAAA,IAAA,GAAA,EAAA;;aAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAO;AAAP,UAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACf,YAAM,MAAM,GAAG,SAAS,CAAC,MAAD,CAAxB,CADK,CAEL;;AACA,YAAI,CAAC,MAAL,EAAa;AACb,eAAO,MAAM,CAAC,QAAD,CAAN,CAAgB,KAAhB,CAAA,MAAA,EAAM,aAAA,CAAA,EAAA,EAAA,MAAA,CAAc,IAAd,CAAA,EAAkB,KAAlB,CAAN,CAAP;AACD,OALD;AAMD,KARH,CAUE;;;AACA,QAAM,IAAI,GAAG,IAAb,CAXF,CAaE;;AAEA,QAAM,SAAS,GAA+B,UAC5C,MAD4C,EAE5C,iBAF4C,EAEO;;;AAAnD,UAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,iBAAA,GAAA;AAAsB,UAAA,QAAQ,EAAE,YAAY,CAAC;AAA7C,SAAA;AAAmD;;AAEnD,UAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA;AACA;AACA,YAAM,GAAG,GAAG,IAAI,KAAJ,CACV,oIADU,CAAZ;AAGA,QAAA,IAAI,CAAC,KAAL,CAAW,CAAA,EAAA,GAAA,GAAG,CAAC,KAAJ,MAAS,IAAT,IAAS,EAAA,KAAA,KAAA,CAAT,GAAS,EAAT,GAAa,GAAG,CAAC,OAA5B;AACA,eAAO,KAAP;AACD;;AAED,UAAI,OAAO,iBAAP,KAA6B,QAAjC,EAA2C;AACzC,QAAA,iBAAiB,GAAG;AAClB,UAAA,QAAQ,EAAE;AADQ,SAApB;AAGD;;AAED,UAAM,SAAS,GAAG,SAAS,CAAC,MAAD,CAA3B;AACA,UAAM,SAAS,GAAG,wBAAwB,CACxC,CAAA,EAAA,GAAA,iBAAiB,CAAC,QAAlB,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,YAAY,CAAC,IADH,EAExC,MAFwC,CAA1C,CApBmD,CAwBnD;;AACA,UAAI,SAAS,IAAI,CAAC,iBAAiB,CAAC,uBAApC,EAA6D;AAC3D,YAAM,KAAK,GAAG,CAAA,EAAA,GAAA,IAAI,KAAJ,GAAY,KAAZ,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,iCAAnC;AACA,QAAA,SAAS,CAAC,IAAV,CAAe,6CAA2C,KAA1D;AACA,QAAA,SAAS,CAAC,IAAV,CACE,+DAA6D,KAD/D;AAGD;;AAED,aAAO,cAAc,CAAC,MAAD,EAAS,SAAT,EAAoB,IAApB,EAA0B,IAA1B,CAArB;AACD,KApCD;;AAsCA,IAAA,IAAI,CAAC,SAAL,GAAiB,SAAjB;;AAEA,IAAA,IAAI,CAAC,OAAL,GAAe,YAAA;AACb,MAAA,gBAAgB,CAAC,QAAD,EAAW,IAAX,CAAhB;AACD,KAFD;;AAIA,IAAA,IAAI,CAAC,qBAAL,GAA6B,UAAC,OAAD,EAAgC;AAC3D,aAAO,IAAI,mBAAJ,CAAwB,OAAxB,CAAP;AACD,KAFD;;AAIA,IAAA,IAAI,CAAC,OAAL,GAAe,SAAS,CAAC,SAAD,CAAxB;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,OAAD,CAAtB;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,SAAS,CAAC,MAAD,CAArB;AACA,IAAA,IAAI,CAAC,IAAL,GAAY,SAAS,CAAC,MAAD,CAArB;AACA,IAAA,IAAI,CAAC,KAAL,GAAa,SAAS,CAAC,OAAD,CAAtB;AACD;AAjFD;;;AACc,EAAA,OAAA,CAAA,QAAA,GAAd,YAAA;AACE,QAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,WAAK,SAAL,GAAiB,IAAI,OAAJ,EAAjB;AACD;;AAED,WAAO,KAAK,SAAZ;AACD,GANa;;AAqGhB,SAAA,OAAA;AAAC,CAzGD,EAAA","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}