{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy, deserializationPolicy, disableResponseDecompressionPolicy, HttpHeaders, RequestPolicyOptions, WebResource, proxyPolicy, isNode, isTokenCredential, tracingPolicy, logPolicy, keepAlivePolicy, generateClientRequestIdPolicy } from \"@azure/core-http\";\nimport { logger } from \"./log\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory\";\nimport { StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport { StorageOAuthScopes, StorageBlobLoggingAllowedHeaderNames, StorageBlobLoggingAllowedQueryParameters } from \"./utils/constants\";\nimport { TelemetryPolicyFactory } from \"./TelemetryPolicyFactory\";\nimport { getCachedDefaultHttpClient } from \"./utils/cache\";\nimport { attachCredential } from \"./utils/utils.common\";\nimport { storageBearerTokenChallengeAuthenticationPolicy } from \"./policies/StorageBearerTokenChallengeAuthenticationPolicy\"; // Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\n\nexport { BaseRequestPolicy, StorageOAuthScopes, deserializationPolicy, HttpHeaders, WebResource, RequestPolicyOptions };\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\n\nexport function isPipelineLike(pipeline) {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n\n  const castPipeline = pipeline;\n  return Array.isArray(castPipeline.factories) && typeof castPipeline.options === \"object\" && typeof castPipeline.toServiceClientOptions === \"function\";\n}\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\n\nexport class Pipeline {\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.factories = factories; // when options.httpClient is not specified, passing in a DefaultHttpClient instance to\n    // avoid each client creating its own http client.\n\n    this.options = Object.assign(Object.assign({}, options), {\n      httpClient: options.httpClient || getCachedDefaultHttpClient()\n    });\n  }\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n\n\n  toServiceClientOptions() {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories\n    };\n  }\n\n}\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\n\nexport function newPipeline(credential) {\n  let pipelineOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  if (credential === undefined) {\n    credential = new AnonymousCredential();\n  } // Order is important. Closer to the API at the top & closer to the network at the bottom.\n  // The credential's policy factory must appear close to the wire so it can sign any\n  // changes made by other factories (like UniqueRequestIDPolicyFactory)\n\n\n  const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);\n  const factories = [tracingPolicy({\n    userAgent: telemetryPolicy.telemetryString\n  }), keepAlivePolicy(pipelineOptions.keepAliveOptions), telemetryPolicy, generateClientRequestIdPolicy(), new StorageBrowserPolicyFactory(), new StorageRetryPolicyFactory(pipelineOptions.retryOptions), // Default deserializationPolicy is provided by protocol layer\n  // Use customized XML char key of \"#\" so we could deserialize metadata\n  // with \"_\" key\n  deserializationPolicy(undefined, {\n    xmlCharKey: \"#\"\n  }), logPolicy({\n    logger: logger.info,\n    allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n    allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters\n  })];\n\n  if (isNode) {\n    // policies only available in Node.js runtime, not in browsers\n    factories.push(proxyPolicy(pipelineOptions.proxyOptions));\n    factories.push(disableResponseDecompressionPolicy());\n  }\n\n  factories.push(isTokenCredential(credential) ? attachCredential(storageBearerTokenChallengeAuthenticationPolicy(credential, (_a = pipelineOptions.audience) !== null && _a !== void 0 ? _a : StorageOAuthScopes), credential) : credential);\n  return new Pipeline(factories, pipelineOptions);\n}","map":{"version":3,"sources":["../../../src/Pipeline.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  deserializationPolicy,\n  disableResponseDecompressionPolicy,\n  HttpClient as IHttpClient,\n  HttpHeaders,\n  HttpOperationResponse,\n  HttpRequestBody,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n  ServiceClientOptions,\n  WebResource,\n  proxyPolicy,\n  isNode,\n  TokenCredential,\n  isTokenCredential,\n  tracingPolicy,\n  logPolicy,\n  ProxyOptions,\n  keepAlivePolicy,\n  KeepAliveOptions,\n  generateClientRequestIdPolicy,\n  UserAgentOptions,\n} from \"@azure/core-http\";\n\nimport { logger } from \"./log\";\nimport { StorageBrowserPolicyFactory } from \"./StorageBrowserPolicyFactory\";\nimport { StorageRetryOptions, StorageRetryPolicyFactory } from \"./StorageRetryPolicyFactory\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport {\n  StorageOAuthScopes,\n  StorageBlobLoggingAllowedHeaderNames,\n  StorageBlobLoggingAllowedQueryParameters,\n} from \"./utils/constants\";\nimport { TelemetryPolicyFactory } from \"./TelemetryPolicyFactory\";\nimport { getCachedDefaultHttpClient } from \"./utils/cache\";\nimport { attachCredential } from \"./utils/utils.common\";\nimport { storageBearerTokenChallengeAuthenticationPolicy } from \"./policies/StorageBearerTokenChallengeAuthenticationPolicy\";\n\n// Export following interfaces and types for customers who want to implement their\n// own RequestPolicy or HTTPClient\nexport {\n  BaseRequestPolicy,\n  StorageOAuthScopes,\n  deserializationPolicy,\n  IHttpClient,\n  HttpHeaders,\n  HttpRequestBody,\n  HttpOperationResponse,\n  WebResource,\n  RequestPolicyFactory,\n  RequestPolicy,\n  RequestPolicyOptions,\n};\n\n/**\n * Option interface for Pipeline constructor.\n */\nexport interface PipelineOptions {\n  /**\n   * Optional. Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n}\n\n/**\n * An interface for the {@link Pipeline} class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport interface PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  readonly options: PipelineOptions;\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  toServiceClientOptions(): ServiceClientOptions;\n}\n\n/**\n * A helper to decide if a given argument satisfies the Pipeline contract\n * @param pipeline - An argument that may be a Pipeline\n * @returns true when the argument satisfies the Pipeline contract\n */\nexport function isPipelineLike(pipeline: unknown): pipeline is PipelineLike {\n  if (!pipeline || typeof pipeline !== \"object\") {\n    return false;\n  }\n\n  const castPipeline = pipeline as PipelineLike;\n\n  return (\n    Array.isArray(castPipeline.factories) &&\n    typeof castPipeline.options === \"object\" &&\n    typeof castPipeline.toServiceClientOptions === \"function\"\n  );\n}\n\n/**\n * A Pipeline class containing HTTP request policies.\n * You can create a default Pipeline by calling {@link newPipeline}.\n * Or you can create a Pipeline with your own policies by the constructor of Pipeline.\n *\n * Refer to {@link newPipeline} and provided policies before implementing your\n * customized Pipeline.\n */\nexport class Pipeline implements PipelineLike {\n  /**\n   * A list of chained request policy factories.\n   */\n  public readonly factories: RequestPolicyFactory[];\n  /**\n   * Configures pipeline logger and HTTP client.\n   */\n  public readonly options: PipelineOptions;\n\n  /**\n   * Creates an instance of Pipeline. Customize HTTPClient by implementing IHttpClient interface.\n   *\n   * @param factories -\n   * @param options -\n   */\n  constructor(factories: RequestPolicyFactory[], options: PipelineOptions = {}) {\n    this.factories = factories;\n    // when options.httpClient is not specified, passing in a DefaultHttpClient instance to\n    // avoid each client creating its own http client.\n    this.options = {\n      ...options,\n      httpClient: options.httpClient || getCachedDefaultHttpClient(),\n    };\n  }\n\n  /**\n   * Transfer Pipeline object to ServiceClientOptions object which is required by\n   * ServiceClient constructor.\n   *\n   * @returns The ServiceClientOptions object from this Pipeline.\n   */\n  public toServiceClientOptions(): ServiceClientOptions {\n    return {\n      httpClient: this.options.httpClient,\n      requestPolicyFactories: this.factories,\n    };\n  }\n}\n\n/**\n * Options interface for the {@link newPipeline} function.\n */\nexport interface StoragePipelineOptions {\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxyOptions;\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentOptions;\n  /**\n   * Configures the built-in retry policy behavior.\n   */\n  retryOptions?: StorageRetryOptions;\n  /**\n   * Keep alive configurations. Default keep-alive is enabled.\n   */\n  keepAliveOptions?: KeepAliveOptions;\n  /**\n   * Configures the HTTP client to send requests and receive responses.\n   */\n  httpClient?: IHttpClient;\n  /**\n   * The audience used to retrieve an AAD token.\n   */\n  audience?: string | string[];\n}\n\n/**\n * Creates a new Pipeline object with Credential provided.\n *\n * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n * @param pipelineOptions - Optional. Options.\n * @returns A new Pipeline object.\n */\nexport function newPipeline(\n  credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n  pipelineOptions: StoragePipelineOptions = {}\n): Pipeline {\n  if (credential === undefined) {\n    credential = new AnonymousCredential();\n  }\n\n  // Order is important. Closer to the API at the top & closer to the network at the bottom.\n  // The credential's policy factory must appear close to the wire so it can sign any\n  // changes made by other factories (like UniqueRequestIDPolicyFactory)\n\n  const telemetryPolicy = new TelemetryPolicyFactory(pipelineOptions.userAgentOptions);\n  const factories: RequestPolicyFactory[] = [\n    tracingPolicy({ userAgent: telemetryPolicy.telemetryString }),\n    keepAlivePolicy(pipelineOptions.keepAliveOptions),\n    telemetryPolicy,\n    generateClientRequestIdPolicy(),\n    new StorageBrowserPolicyFactory(),\n    new StorageRetryPolicyFactory(pipelineOptions.retryOptions), // Retry policy should be above any policy that throws retryable errors\n    // Default deserializationPolicy is provided by protocol layer\n    // Use customized XML char key of \"#\" so we could deserialize metadata\n    // with \"_\" key\n    deserializationPolicy(undefined, { xmlCharKey: \"#\" }),\n    logPolicy({\n      logger: logger.info,\n      allowedHeaderNames: StorageBlobLoggingAllowedHeaderNames,\n      allowedQueryParameters: StorageBlobLoggingAllowedQueryParameters,\n    }),\n  ];\n\n  if (isNode) {\n    // policies only available in Node.js runtime, not in browsers\n    factories.push(proxyPolicy(pipelineOptions.proxyOptions));\n    factories.push(disableResponseDecompressionPolicy());\n  }\n  factories.push(\n    isTokenCredential(credential)\n      ? attachCredential(\n          storageBearerTokenChallengeAuthenticationPolicy(\n            credential,\n            pipelineOptions.audience ?? StorageOAuthScopes\n          ),\n          credential\n        )\n      : credential\n  );\n\n  return new Pipeline(factories, pipelineOptions);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}