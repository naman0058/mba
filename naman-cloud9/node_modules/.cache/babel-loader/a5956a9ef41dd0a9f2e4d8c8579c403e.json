{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"@azure/core-http\";\nimport { HTTP_VERSION_1_1, HTTP_LINE_ENDING, HeaderConstants, HTTPURLConnection } from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { logger } from \"./log\";\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n/**\n * Util class for parsing batch response.\n */\n\nexport class BatchResponseParser {\n  constructor(batchResponse, subRequests) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  } // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n\n\n  async parseBatchResponse() {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(`Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`);\n    }\n\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n    const subResponses = responseBodyAsText.split(this.batchResponseEnding)[0] // string after ending is useless\n    .split(this.perResponsePrefix).slice(1); // string before first response boundary is useless\n\n    const subResponseCount = subResponses.length; // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n\n    const deserializedSubResponses = new Array(subResponseCount);\n    let subResponsesSucceededCount = 0;\n    let subResponsesFailedCount = 0; // Parse sub subResponses.\n\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {};\n      deserializedSubResponse.headers = new HttpHeaders();\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          } // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n\n\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n\n          continue; // Skip empty line\n        } // Note: when code reach here, it indicates subRespHeaderStartFound == true\n\n\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(`Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`);\n          } // Parse headers of sub response.\n\n\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n\n\n      if (contentId !== NOT_FOUND && Number.isInteger(contentId) && contentId >= 0 && contentId < this.subRequests.size && deserializedSubResponses[contentId] === undefined) {\n        deserializedSubResponse._request = this.subRequests.get(contentId);\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(`subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`);\n      }\n\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/BatchResponseParser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders } from \"@azure/core-http\";\n\nimport { ServiceSubmitBatchResponseModel } from \"./generatedModels\";\nimport {\n  HTTP_VERSION_1_1,\n  HTTP_LINE_ENDING,\n  HeaderConstants,\n  HTTPURLConnection,\n} from \"./utils/constants\";\nimport { getBodyAsText } from \"./BatchUtils\";\nimport { BatchSubRequest } from \"./BlobBatch\";\nimport { BatchSubResponse, ParsedBatchResponse } from \"./BatchResponse\";\nimport { logger } from \"./log\";\n\nconst HTTP_HEADER_DELIMITER = \": \";\nconst SPACE_DELIMITER = \" \";\nconst NOT_FOUND = -1;\n\n/**\n * Util class for parsing batch response.\n */\nexport class BatchResponseParser {\n  private readonly batchResponse: ServiceSubmitBatchResponseModel;\n  private readonly responseBatchBoundary: string;\n  private readonly perResponsePrefix: string;\n  private readonly batchResponseEnding: string;\n  private readonly subRequests: Map<number, BatchSubRequest>;\n\n  constructor(\n    batchResponse: ServiceSubmitBatchResponseModel,\n    subRequests: Map<number, BatchSubRequest>\n  ) {\n    if (!batchResponse || !batchResponse.contentType) {\n      // In special case(reported), server may return invalid content-type which could not be parsed.\n      throw new RangeError(\"batchResponse is malformed or doesn't contain valid content-type.\");\n    }\n\n    if (!subRequests || subRequests.size === 0) {\n      // This should be prevent during coding.\n      throw new RangeError(\"Invalid state: subRequests is not provided or size is 0.\");\n    }\n\n    this.batchResponse = batchResponse;\n    this.subRequests = subRequests;\n    this.responseBatchBoundary = this.batchResponse.contentType!.split(\"=\")[1];\n    this.perResponsePrefix = `--${this.responseBatchBoundary}${HTTP_LINE_ENDING}`;\n    this.batchResponseEnding = `--${this.responseBatchBoundary}--`;\n  }\n\n  // For example of response, please refer to https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch#response\n  public async parseBatchResponse(): Promise<ParsedBatchResponse> {\n    // When logic reach here, suppose batch request has already succeeded with 202, so we can further parse\n    // sub request's response.\n    if (this.batchResponse._response.status !== HTTPURLConnection.HTTP_ACCEPTED) {\n      throw new Error(\n        `Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`\n      );\n    }\n\n    const responseBodyAsText = await getBodyAsText(this.batchResponse);\n\n    const subResponses = responseBodyAsText\n      .split(this.batchResponseEnding)[0] // string after ending is useless\n      .split(this.perResponsePrefix)\n      .slice(1); // string before first response boundary is useless\n    const subResponseCount = subResponses.length;\n\n    // Defensive coding in case of potential error parsing.\n    // Note: subResponseCount == 1 is special case where sub request is invalid.\n    // We try to prevent such cases through early validation, e.g. validate sub request count >= 1.\n    // While in unexpected sub request invalid case, we allow sub response to be parsed and return to user.\n    if (subResponseCount !== this.subRequests.size && subResponseCount !== 1) {\n      throw new Error(\"Invalid state: sub responses' count is not equal to sub requests' count.\");\n    }\n\n    const deserializedSubResponses: Array<BatchSubResponse> = new Array(subResponseCount);\n    let subResponsesSucceededCount: number = 0;\n    let subResponsesFailedCount: number = 0;\n\n    // Parse sub subResponses.\n    for (let index = 0; index < subResponseCount; index++) {\n      const subResponse = subResponses[index];\n      const deserializedSubResponse = {} as BatchSubResponse;\n      deserializedSubResponse.headers = new HttpHeaders();\n\n      const responseLines = subResponse.split(`${HTTP_LINE_ENDING}`);\n      let subRespHeaderStartFound = false;\n      let subRespHeaderEndFound = false;\n      let subRespFailed = false;\n      let contentId = NOT_FOUND;\n\n      for (const responseLine of responseLines) {\n        if (!subRespHeaderStartFound) {\n          // Convention line to indicate content ID\n          if (responseLine.startsWith(HeaderConstants.CONTENT_ID)) {\n            contentId = parseInt(responseLine.split(HTTP_HEADER_DELIMITER)[1]);\n          }\n\n          // Http version line with status code indicates the start of sub request's response.\n          // Example: HTTP/1.1 202 Accepted\n          if (responseLine.startsWith(HTTP_VERSION_1_1)) {\n            subRespHeaderStartFound = true;\n\n            const tokens = responseLine.split(SPACE_DELIMITER);\n            deserializedSubResponse.status = parseInt(tokens[1]);\n            deserializedSubResponse.statusMessage = tokens.slice(2).join(SPACE_DELIMITER);\n          }\n\n          continue; // Skip convention headers not specifically for sub request i.e. Content-Type: application/http and Content-ID: *\n        }\n\n        if (responseLine.trim() === \"\") {\n          // Sub response's header start line already found, and the first empty line indicates header end line found.\n          if (!subRespHeaderEndFound) {\n            subRespHeaderEndFound = true;\n          }\n\n          continue; // Skip empty line\n        }\n\n        // Note: when code reach here, it indicates subRespHeaderStartFound == true\n        if (!subRespHeaderEndFound) {\n          if (responseLine.indexOf(HTTP_HEADER_DELIMITER) === -1) {\n            // Defensive coding to prevent from missing valuable lines.\n            throw new Error(\n              `Invalid state: find non-empty line '${responseLine}' without HTTP header delimiter '${HTTP_HEADER_DELIMITER}'.`\n            );\n          }\n\n          // Parse headers of sub response.\n          const tokens = responseLine.split(HTTP_HEADER_DELIMITER);\n          deserializedSubResponse.headers.set(tokens[0], tokens[1]);\n          if (tokens[0] === HeaderConstants.X_MS_ERROR_CODE) {\n            deserializedSubResponse.errorCode = tokens[1];\n            subRespFailed = true;\n          }\n        } else {\n          // Assemble body of sub response.\n          if (!deserializedSubResponse.bodyAsText) {\n            deserializedSubResponse.bodyAsText = \"\";\n          }\n\n          deserializedSubResponse.bodyAsText += responseLine;\n        }\n      } // Inner for end\n\n      // The response will contain the Content-ID header for each corresponding subrequest response to use for tracking.\n      // The Content-IDs are set to a valid index in the subrequests we sent. In the status code 202 path, we could expect it\n      // to be 1-1 mapping from the [0, subRequests.size) to the Content-IDs returned. If not, we simply don't return that\n      // unexpected subResponse in the parsed reponse and we can always look it up in the raw response for debugging purpose.\n      if (\n        contentId !== NOT_FOUND &&\n        Number.isInteger(contentId) &&\n        contentId >= 0 &&\n        contentId < this.subRequests.size &&\n        deserializedSubResponses[contentId] === undefined\n      ) {\n        deserializedSubResponse._request = this.subRequests.get(contentId)!;\n        deserializedSubResponses[contentId] = deserializedSubResponse;\n      } else {\n        logger.error(\n          `subResponses[${index}] is dropped as the Content-ID is not found or invalid, Content-ID: ${contentId}`\n        );\n      }\n\n      if (subRespFailed) {\n        subResponsesFailedCount++;\n      } else {\n        subResponsesSucceededCount++;\n      }\n    }\n\n    return {\n      subResponses: deserializedSubResponses,\n      subResponsesSucceededCount: subResponsesSucceededCount,\n      subResponsesFailedCount: subResponsesFailedCount,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}