{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders } from \"./httpHeaders\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\n\nexport class XhrHttpClient {\n  sendRequest(request) {\n    var _a;\n\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = () => {\n        xhr.abort();\n      };\n\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n\n      const appendFormValue = (key, value) => {\n        if (value && Object.prototype.hasOwnProperty.call(value, \"value\") && Object.prototype.hasOwnProperty.call(value, \"options\")) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? \"blob\" : \"text\"; // tslint:disable-next-line:no-null-keyword\n\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () => resolve({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          bodyAsText: xhr.responseText\n        }));\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n\n}\n\nfunction handleBlobResponse(xhr, request, res, rej) {\n  xhr.addEventListener(\"readystatechange\", () => {\n    var _a; // Resolve as soon as headers are loaded\n\n\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {\n        const blobBody = new Promise((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n\n            reader.onload = function (e) {\n              var _a;\n\n              const text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text\n              });\n            };\n\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr)\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(xhr, listener) {\n  if (listener) {\n    xhr.addEventListener(\"progress\", rawEvent => listener({\n      loadedBytes: rawEvent.loaded\n    }));\n  }\n} // exported locally for testing\n\n\nexport function parseHeaders(xhr) {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/);\n\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(request, xhr, reject) {\n  xhr.addEventListener(\"error\", () => reject(new RestError(`Failed to send request to ${request.url}`, RestError.REQUEST_SEND_ERROR, undefined, request)));\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}","map":{"version":3,"sources":["../../src/xhrHttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { HttpHeaders, HttpHeadersLike } from \"./httpHeaders\";\nimport { TransferProgressEvent, WebResourceLike } from \"./webResource\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { HttpClient } from \"./httpClient\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { RestError } from \"./restError\";\n\n/**\n * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.\n */\nexport class XhrHttpClient implements HttpClient {\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    const xhr = new XMLHttpRequest();\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    const abortSignal = request.abortSignal;\n    if (abortSignal) {\n      if (abortSignal.aborted) {\n        return Promise.reject(new AbortError(\"The operation was aborted.\"));\n      }\n\n      const listener = (): void => {\n        xhr.abort();\n      };\n      abortSignal.addEventListener(\"abort\", listener);\n      xhr.addEventListener(\"readystatechange\", () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          abortSignal.removeEventListener(\"abort\", listener);\n        }\n      });\n    }\n\n    addProgressListener(xhr.upload, request.onUploadProgress);\n    addProgressListener(xhr, request.onDownloadProgress);\n\n    if (request.formData) {\n      const formData = request.formData;\n      const requestForm = new FormData();\n      const appendFormValue = (key: string, value: any): void => {\n        if (\n          value &&\n          Object.prototype.hasOwnProperty.call(value, \"value\") &&\n          Object.prototype.hasOwnProperty.call(value, \"options\")\n        ) {\n          requestForm.append(key, value.value, value.options);\n        } else {\n          requestForm.append(key, value);\n        }\n      };\n      for (const formKey of Object.keys(formData)) {\n        const formValue = formData[formKey];\n        if (Array.isArray(formValue)) {\n          for (let j = 0; j < formValue.length; j++) {\n            appendFormValue(formKey, formValue[j]);\n          }\n        } else {\n          appendFormValue(formKey, formValue);\n        }\n      }\n\n      request.body = requestForm;\n      request.formData = undefined;\n      const contentType = request.headers.get(\"Content-Type\");\n      if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n        // browser will automatically apply a suitable content-type header\n        request.headers.remove(\"Content-Type\");\n      }\n    }\n\n    xhr.open(request.method, request.url);\n    xhr.timeout = request.timeout;\n    xhr.withCredentials = request.withCredentials;\n    for (const header of request.headers.headersArray()) {\n      xhr.setRequestHeader(header.name, header.value);\n    }\n\n    xhr.responseType =\n      request.streamResponseStatusCodes?.size || request.streamResponseBody ? \"blob\" : \"text\";\n\n    // tslint:disable-next-line:no-null-keyword\n    xhr.send(request.body === undefined ? null : request.body);\n\n    if (xhr.responseType === \"blob\") {\n      return new Promise((resolve, reject) => {\n        handleBlobResponse(xhr, request, resolve, reject);\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    } else {\n      return new Promise(function (resolve, reject) {\n        xhr.addEventListener(\"load\", () =>\n          resolve({\n            request,\n            status: xhr.status,\n            headers: parseHeaders(xhr),\n            bodyAsText: xhr.responseText,\n          })\n        );\n        rejectOnTerminalEvent(request, xhr, reject);\n      });\n    }\n  }\n}\n\nfunction handleBlobResponse(\n  xhr: XMLHttpRequest,\n  request: WebResourceLike,\n  res: (value: HttpOperationResponse | PromiseLike<HttpOperationResponse>) => void,\n  rej: (reason?: any) => void\n): void {\n  xhr.addEventListener(\"readystatechange\", () => {\n    // Resolve as soon as headers are loaded\n    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {\n      if (request.streamResponseBody || request.streamResponseStatusCodes?.has(xhr.status)) {\n        const blobBody = new Promise<Blob>((resolve, reject) => {\n          xhr.addEventListener(\"load\", () => {\n            resolve(xhr.response);\n          });\n          rejectOnTerminalEvent(request, xhr, reject);\n        });\n        res({\n          request,\n          status: xhr.status,\n          headers: parseHeaders(xhr),\n          blobBody,\n        });\n      } else {\n        xhr.addEventListener(\"load\", () => {\n          // xhr.response is of Blob type if the request is sent with xhr.responseType === \"blob\"\n          // but the status code is not one of the stream response status codes,\n          // so treat it as text and convert from Blob to text\n          if (xhr.response) {\n            // Blob.text() is not supported in IE so using FileReader instead\n            const reader = new FileReader();\n            reader.onload = function (e) {\n              const text = e.target?.result as string;\n              res({\n                request,\n                status: xhr.status,\n                headers: parseHeaders(xhr),\n                bodyAsText: text,\n              });\n            };\n            reader.onerror = function (_e) {\n              rej(reader.error);\n            };\n            reader.readAsText(xhr.response, \"UTF-8\");\n          } else {\n            res({\n              request,\n              status: xhr.status,\n              headers: parseHeaders(xhr),\n            });\n          }\n        });\n      }\n    }\n  });\n}\n\nfunction addProgressListener(\n  xhr: XMLHttpRequestEventTarget,\n  listener?: (progress: TransferProgressEvent) => void\n): void {\n  if (listener) {\n    xhr.addEventListener(\"progress\", (rawEvent) =>\n      listener({\n        loadedBytes: rawEvent.loaded,\n      })\n    );\n  }\n}\n\n// exported locally for testing\nexport function parseHeaders(xhr: XMLHttpRequest): HttpHeadersLike {\n  const responseHeaders = new HttpHeaders();\n  const headerLines = xhr\n    .getAllResponseHeaders()\n    .trim()\n    .split(/[\\r\\n]+/);\n  for (const line of headerLines) {\n    const index = line.indexOf(\":\");\n    const headerName = line.slice(0, index);\n    const headerValue = line.slice(index + 2);\n    responseHeaders.set(headerName, headerValue);\n  }\n  return responseHeaders;\n}\n\nfunction rejectOnTerminalEvent(\n  request: WebResourceLike,\n  xhr: XMLHttpRequest,\n  reject: (err: any) => void\n): void {\n  xhr.addEventListener(\"error\", () =>\n    reject(\n      new RestError(\n        `Failed to send request to ${request.url}`,\n        RestError.REQUEST_SEND_ERROR,\n        undefined,\n        request\n      )\n    )\n  );\n  const abortError = new AbortError(\"The operation was aborted.\");\n  xhr.addEventListener(\"abort\", () => reject(abortError));\n  xhr.addEventListener(\"timeout\", () => reject(abortError));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}