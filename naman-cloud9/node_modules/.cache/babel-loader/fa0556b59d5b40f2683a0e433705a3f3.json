{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { DEFAULT_CLIENT_MAX_RETRY_INTERVAL, DEFAULT_CLIENT_MIN_RETRY_INTERVAL, DEFAULT_CLIENT_RETRY_COUNT, DEFAULT_CLIENT_RETRY_INTERVAL, isNumber, shouldRetry, updateRetryData } from \"../util/exponentialBackoffStrategy\";\nimport { delay } from \"@azure/core-util\";\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n * @returns An instance of the {@link SystemErrorRetryPolicy}\n */\n\nexport function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n  return {\n    create: (nextPolicy, options) => {\n      return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);\n    }\n  };\n}\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\n\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  sendRequest(request) {\n    return this._nextPolicy.sendRequest(request.clone()).catch(error => retry(this, request, error.response, error));\n  }\n\n}\n\nasync function retry(policy, request, operationResponse, err, retryData) {\n  retryData = updateRetryData(policy, retryData, err);\n\n  function shouldPolicyRetry(_response, error) {\n    if (error && error.code && (error.code === \"ETIMEDOUT\" || error.code === \"ESOCKETTIMEDOUT\" || error.code === \"ECONNREFUSED\" || error.code === \"ECONNRESET\" || error.code === \"ENOENT\")) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    try {\n      await delay(retryData.retryInterval);\n      return policy._nextPolicy.sendRequest(request.clone());\n    } catch (nestedErr) {\n      return retry(policy, request, operationResponse, nestedErr, retryData);\n    }\n  } else {\n    if (err) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      return Promise.reject(retryData.error);\n    }\n\n    return operationResponse;\n  }\n}","map":{"version":3,"sources":["../../../src/policies/systemErrorRetryPolicy.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SACE,iBADF,QAKO,iBALP;AAMA,SACE,iCADF,EAEE,iCAFF,EAGE,0BAHF,EAIE,6BAJF,EAOE,QAPF,EAQE,WARF,EASE,eATF,QAUO,oCAVP;AAaA,SAAS,KAAT,QAAsB,kBAAtB;AAEA;;;;;;;AAOG;;AACH,OAAM,SAAU,sBAAV,CACJ,UADI,EAEJ,aAFI,EAGJ,gBAHI,EAIJ,gBAJI,EAIqB;AAEzB,SAAO;AACL,IAAA,MAAM,EAAE,CAAC,UAAD,EAA4B,OAA5B,KAA6D;AACnE,aAAO,IAAI,sBAAJ,CACL,UADK,EAEL,OAFK,EAGL,UAHK,EAIL,aAJK,EAKL,gBALK,EAML,gBANK,CAAP;AAQD;AAVI,GAAP;AAYD;AAED;;;;;;AAMG;;AACH,OAAM,MAAO,sBAAP,SAAsC,iBAAtC,CAAuD;AAM3D,EAAA,WAAA,CACE,UADF,EAEE,OAFF,EAGE,UAHF,EAIE,aAJF,EAKE,gBALF,EAME,gBANF,EAM2B;AAEzB,UAAM,UAAN,EAAkB,OAAlB;AACA,SAAK,UAAL,GAAkB,QAAQ,CAAC,UAAD,CAAR,GAAuB,UAAvB,GAAoC,0BAAtD;AACA,SAAK,aAAL,GAAqB,QAAQ,CAAC,aAAD,CAAR,GAA0B,aAA1B,GAA0C,6BAA/D;AACA,SAAK,gBAAL,GAAwB,QAAQ,CAAC,gBAAD,CAAR,GACpB,gBADoB,GAEpB,iCAFJ;AAGA,SAAK,gBAAL,GAAwB,QAAQ,CAAC,gBAAD,CAAR,GACpB,gBADoB,GAEpB,iCAFJ;AAGD;;AAEM,EAAA,WAAW,CAAC,OAAD,EAAyB;AACzC,WAAO,KAAK,WAAL,CACJ,WADI,CACQ,OAAO,CAAC,KAAR,EADR,EAEJ,KAFI,CAEG,KAAD,IAAW,KAAK,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAAC,QAAtB,EAAgC,KAAhC,CAFlB,CAAP;AAGD;;AA7B0D;;AAgC7D,eAAe,KAAf,CACE,MADF,EAEE,OAFF,EAGE,iBAHF,EAIE,GAJF,EAKE,SALF,EAKuB;AAErB,EAAA,SAAS,GAAG,eAAe,CAAC,MAAD,EAAS,SAAT,EAAoB,GAApB,CAA3B;;AAEA,WAAS,iBAAT,CAA2B,SAA3B,EAA8D,KAA9D,EAAgF;AAC9E,QACE,KAAK,IACL,KAAK,CAAC,IADN,KAEC,KAAK,CAAC,IAAN,KAAe,WAAf,IACC,KAAK,CAAC,IAAN,KAAe,iBADhB,IAEC,KAAK,CAAC,IAAN,KAAe,cAFhB,IAGC,KAAK,CAAC,IAAN,KAAe,YAHhB,IAIC,KAAK,CAAC,IAAN,KAAe,QANjB,CADF,EAQE;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACD;;AAED,MAAI,WAAW,CAAC,MAAM,CAAC,UAAR,EAAoB,iBAApB,EAAuC,SAAvC,EAAkD,iBAAlD,EAAqE,GAArE,CAAf,EAA0F;AACxF;AACA,QAAI;AACF,YAAM,KAAK,CAAC,SAAS,CAAC,aAAX,CAAX;AACA,aAAO,MAAM,CAAC,WAAP,CAAmB,WAAnB,CAA+B,OAAO,CAAC,KAAR,EAA/B,CAAP;AACD,KAHD,CAGE,OAAO,SAAP,EAAuB;AACvB,aAAO,KAAK,CAAC,MAAD,EAAS,OAAT,EAAkB,iBAAlB,EAAqC,SAArC,EAAgD,SAAhD,CAAZ;AACD;AACF,GARD,MAQO;AACL,QAAI,GAAJ,EAAS;AACP;AACA,aAAO,OAAO,CAAC,MAAR,CAAe,SAAS,CAAC,KAAzB,CAAP;AACD;;AACD,WAAO,iBAAP;AACD;AACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  DEFAULT_CLIENT_MAX_RETRY_INTERVAL,\n  DEFAULT_CLIENT_MIN_RETRY_INTERVAL,\n  DEFAULT_CLIENT_RETRY_COUNT,\n  DEFAULT_CLIENT_RETRY_INTERVAL,\n  RetryData,\n  RetryError,\n  isNumber,\n  shouldRetry,\n  updateRetryData,\n} from \"../util/exponentialBackoffStrategy\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { delay } from \"@azure/core-util\";\n\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - Maximum number of retries.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n * @returns An instance of the {@link SystemErrorRetryPolicy}\n */\nexport function systemErrorRetryPolicy(\n  retryCount?: number,\n  retryInterval?: number,\n  minRetryInterval?: number,\n  maxRetryInterval?: number\n): RequestPolicyFactory {\n  return {\n    create: (nextPolicy: RequestPolicy, options: RequestPolicyOptions) => {\n      return new SystemErrorRetryPolicy(\n        nextPolicy,\n        options,\n        retryCount,\n        retryInterval,\n        minRetryInterval,\n        maxRetryInterval\n      );\n    },\n  };\n}\n\n/**\n * A policy that retries when there's a system error, identified by the codes \"ETIMEDOUT\", \"ESOCKETTIMEDOUT\", \"ECONNREFUSED\", \"ECONNRESET\" or \"ENOENT\".\n * @param retryCount - The client retry count.\n * @param retryInterval - The client retry interval, in milliseconds.\n * @param minRetryInterval - The minimum retry interval, in milliseconds.\n * @param maxRetryInterval - The maximum retry interval, in milliseconds.\n */\nexport class SystemErrorRetryPolicy extends BaseRequestPolicy {\n  retryCount: number;\n  retryInterval: number;\n  minRetryInterval: number;\n  maxRetryInterval: number;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    retryCount?: number,\n    retryInterval?: number,\n    minRetryInterval?: number,\n    maxRetryInterval?: number\n  ) {\n    super(nextPolicy, options);\n    this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;\n    this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;\n    this.minRetryInterval = isNumber(minRetryInterval)\n      ? minRetryInterval\n      : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n    this.maxRetryInterval = isNumber(maxRetryInterval)\n      ? maxRetryInterval\n      : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n  }\n\n  public sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    return this._nextPolicy\n      .sendRequest(request.clone())\n      .catch((error) => retry(this, request, error.response, error));\n  }\n}\n\nasync function retry(\n  policy: SystemErrorRetryPolicy,\n  request: WebResourceLike,\n  operationResponse: HttpOperationResponse,\n  err?: RetryError,\n  retryData?: RetryData\n): Promise<HttpOperationResponse> {\n  retryData = updateRetryData(policy, retryData, err);\n\n  function shouldPolicyRetry(_response?: HttpOperationResponse, error?: RetryError): boolean {\n    if (\n      error &&\n      error.code &&\n      (error.code === \"ETIMEDOUT\" ||\n        error.code === \"ESOCKETTIMEDOUT\" ||\n        error.code === \"ECONNREFUSED\" ||\n        error.code === \"ECONNRESET\" ||\n        error.code === \"ENOENT\")\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  if (shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) {\n    // If previous operation ended with an error and the policy allows a retry, do that\n    try {\n      await delay(retryData.retryInterval);\n      return policy._nextPolicy.sendRequest(request.clone());\n    } catch (nestedErr: any) {\n      return retry(policy, request, operationResponse, nestedErr, retryData);\n    }\n  } else {\n    if (err) {\n      // If the operation failed in the end, return all errors instead of just the last one\n      return Promise.reject(retryData.error);\n    }\n    return operationResponse;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}