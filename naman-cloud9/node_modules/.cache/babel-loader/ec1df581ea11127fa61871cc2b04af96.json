{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { initOperation, pollOperation } from \"../poller/operation\";\nimport { logger } from \"../logger\";\n\nfunction getOperationLocationPollingUrl(inputs) {\n  const {\n    azureAsyncOperation,\n    operationLocation\n  } = inputs;\n  return operationLocation !== null && operationLocation !== void 0 ? operationLocation : azureAsyncOperation;\n}\n\nfunction getLocationHeader(rawResponse) {\n  return rawResponse.headers[\"location\"];\n}\n\nfunction getOperationLocationHeader(rawResponse) {\n  return rawResponse.headers[\"operation-location\"];\n}\n\nfunction getAzureAsyncOperationHeader(rawResponse) {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\n\nfunction findResourceLocation(inputs) {\n  const {\n    location,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n\n  switch (requestMethod) {\n    case \"PUT\":\n      {\n        return requestPath;\n      }\n\n    case \"DELETE\":\n      {\n        return undefined;\n      }\n\n    default:\n      {\n        switch (resourceLocationConfig) {\n          case \"azure-async-operation\":\n            {\n              return undefined;\n            }\n\n          case \"original-uri\":\n            {\n              return requestPath;\n            }\n\n          case \"location\":\n          default:\n            {\n              return location;\n            }\n        }\n      }\n  }\n}\n\nexport function inferLroMode(inputs) {\n  const {\n    rawResponse,\n    requestMethod,\n    requestPath,\n    resourceLocationConfig\n  } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({\n    operationLocation,\n    azureAsyncOperation\n  });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod === null || requestMethod === void 0 ? void 0 : requestMethod.toLocaleUpperCase();\n\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig\n      })\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction transformStatus(inputs) {\n  const {\n    status,\n    statusCode\n  } = inputs;\n\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(`Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`);\n  }\n\n  switch (status === null || status === void 0 ? void 0 : status.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n\n    case \"succeeded\":\n      return \"succeeded\";\n\n    case \"failed\":\n      return \"failed\";\n\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n\n    default:\n      {\n        logger.warning(`LRO: unrecognized operation status: ${status}`);\n        return status;\n      }\n  }\n}\n\nfunction getStatus(rawResponse) {\n  var _a;\n\n  const {\n    status\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\n\nfunction getProvisioningState(rawResponse) {\n  var _a, _b;\n\n  const {\n    properties,\n    provisioningState\n  } = (_a = rawResponse.body) !== null && _a !== void 0 ? _a : {};\n  const status = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;\n  return transformStatus({\n    status,\n    statusCode: rawResponse.statusCode\n  });\n}\n\nfunction toOperationStatus(statusCode) {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\n\nexport function parseRetryAfter(_ref) {\n  let {\n    rawResponse\n  } = _ref;\n  const retryAfter = rawResponse.headers[\"retry-after\"];\n\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds) ? calculatePollingIntervalFromDate(new Date(retryAfter)) : retryAfterInSeconds * 1000;\n  }\n\n  return undefined;\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate) {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n\n  return undefined;\n}\n\nexport function getStatusFromInitialResponse(inputs) {\n  const {\n    response,\n    state,\n    operationLocation\n  } = inputs;\n\n  function helper() {\n    var _a;\n\n    const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n\n      case \"Body\":\n        return getOperationStatus(response, state);\n\n      default:\n        return \"running\";\n    }\n  }\n\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n/**\n * Initiates the long-running operation.\n */\n\nexport async function initHttpOperation(inputs) {\n  const {\n    stateProxy,\n    resourceLocationConfig,\n    processResult,\n    lro,\n    setErrorAsResult\n  } = inputs;\n  return initOperation({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig\n      });\n      return Object.assign({\n        response,\n        operationLocation: config === null || config === void 0 ? void 0 : config.operationLocation,\n        resourceLocation: config === null || config === void 0 ? void 0 : config.resourceLocation\n      }, (config === null || config === void 0 ? void 0 : config.mode) ? {\n        metadata: {\n          mode: config.mode\n        }\n      } : {});\n    },\n    stateProxy,\n    processResult: processResult ? (_ref2, state) => {\n      let {\n        flatResponse\n      } = _ref2;\n      return processResult(flatResponse, state);\n    } : _ref3 => {\n      let {\n        flatResponse\n      } = _ref3;\n      return flatResponse;\n    },\n    getOperationStatus: getStatusFromInitialResponse,\n    setErrorAsResult\n  });\n}\nexport function getOperationLocation(_ref4, state) {\n  let {\n    rawResponse\n  } = _ref4;\n\n  var _a;\n\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getOperationLocationPollingUrl({\n          operationLocation: getOperationLocationHeader(rawResponse),\n          azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse)\n        });\n      }\n\n    case \"ResourceLocation\":\n      {\n        return getLocationHeader(rawResponse);\n      }\n\n    case \"Body\":\n    default:\n      {\n        return undefined;\n      }\n  }\n}\nexport function getOperationStatus(_ref5, state) {\n  let {\n    rawResponse\n  } = _ref5;\n\n  var _a;\n\n  const mode = (_a = state.config.metadata) === null || _a === void 0 ? void 0 : _a[\"mode\"];\n\n  switch (mode) {\n    case \"OperationLocation\":\n      {\n        return getStatus(rawResponse);\n      }\n\n    case \"ResourceLocation\":\n      {\n        return toOperationStatus(rawResponse.statusCode);\n      }\n\n    case \"Body\":\n      {\n        return getProvisioningState(rawResponse);\n      }\n\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\nexport function getResourceLocation(_ref6, state) {\n  let {\n    flatResponse\n  } = _ref6;\n\n  if (typeof flatResponse === \"object\") {\n    const resourceLocation = flatResponse.resourceLocation;\n\n    if (resourceLocation !== undefined) {\n      state.config.resourceLocation = resourceLocation;\n    }\n  }\n\n  return state.config.resourceLocation;\n}\nexport function isOperationError(e) {\n  return e.name === \"RestError\";\n}\n/** Polls the long-running operation. */\n\nexport async function pollHttpOperation(inputs) {\n  const {\n    lro,\n    stateProxy,\n    options,\n    processResult,\n    updateState,\n    setDelay,\n    state,\n    setErrorAsResult\n  } = inputs;\n  return pollOperation({\n    state,\n    stateProxy,\n    setDelay,\n    processResult: processResult ? (_ref7, inputState) => {\n      let {\n        flatResponse\n      } = _ref7;\n      return processResult(flatResponse, inputState);\n    } : _ref8 => {\n      let {\n        flatResponse\n      } = _ref8;\n      return flatResponse;\n    },\n    updateState,\n    getPollingInterval: parseRetryAfter,\n    getOperationLocation,\n    getOperationStatus,\n    isOperationError,\n    getResourceLocation,\n    options,\n\n    /**\n     * The expansion here is intentional because `lro` could be an object that\n     * references an inner this, so we need to preserve a reference to it.\n     */\n    poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),\n    setErrorAsResult\n  });\n}","map":{"version":3,"sources":["../../../src/http/operation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  HttpOperationMode,\n  LongRunningOperation,\n  LroResourceLocationConfig,\n  LroResponse,\n  RawResponse,\n  ResponseBody,\n} from \"./models\";\nimport {\n  OperationConfig,\n  OperationStatus,\n  RestorableOperationState,\n  StateProxy,\n} from \"../poller/models\";\nimport { initOperation, pollOperation } from \"../poller/operation\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { logger } from \"../logger\";\n\nfunction getOperationLocationPollingUrl(inputs: {\n  operationLocation?: string;\n  azureAsyncOperation?: string;\n}): string | undefined {\n  const { azureAsyncOperation, operationLocation } = inputs;\n  return operationLocation ?? azureAsyncOperation;\n}\n\nfunction getLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"location\"];\n}\n\nfunction getOperationLocationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"operation-location\"];\n}\n\nfunction getAzureAsyncOperationHeader(rawResponse: RawResponse): string | undefined {\n  return rawResponse.headers[\"azure-asyncoperation\"];\n}\n\nfunction findResourceLocation(inputs: {\n  requestMethod?: string;\n  location?: string;\n  requestPath?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): string | undefined {\n  const { location, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  switch (requestMethod) {\n    case \"PUT\": {\n      return requestPath;\n    }\n    case \"DELETE\": {\n      return undefined;\n    }\n    default: {\n      switch (resourceLocationConfig) {\n        case \"azure-async-operation\": {\n          return undefined;\n        }\n        case \"original-uri\": {\n          return requestPath;\n        }\n        case \"location\":\n        default: {\n          return location;\n        }\n      }\n    }\n  }\n}\n\nexport function inferLroMode(inputs: {\n  rawResponse: RawResponse;\n  requestPath?: string;\n  requestMethod?: string;\n  resourceLocationConfig?: LroResourceLocationConfig;\n}): (OperationConfig & { mode: HttpOperationMode }) | undefined {\n  const { rawResponse, requestMethod, requestPath, resourceLocationConfig } = inputs;\n  const operationLocation = getOperationLocationHeader(rawResponse);\n  const azureAsyncOperation = getAzureAsyncOperationHeader(rawResponse);\n  const pollingUrl = getOperationLocationPollingUrl({ operationLocation, azureAsyncOperation });\n  const location = getLocationHeader(rawResponse);\n  const normalizedRequestMethod = requestMethod?.toLocaleUpperCase();\n  if (pollingUrl !== undefined) {\n    return {\n      mode: \"OperationLocation\",\n      operationLocation: pollingUrl,\n      resourceLocation: findResourceLocation({\n        requestMethod: normalizedRequestMethod,\n        location,\n        requestPath,\n        resourceLocationConfig,\n      }),\n    };\n  } else if (location !== undefined) {\n    return {\n      mode: \"ResourceLocation\",\n      operationLocation: location,\n    };\n  } else if (normalizedRequestMethod === \"PUT\" && requestPath) {\n    return {\n      mode: \"Body\",\n      operationLocation: requestPath,\n    };\n  } else {\n    return undefined;\n  }\n}\n\nfunction transformStatus(inputs: { status: unknown; statusCode: number }): OperationStatus {\n  const { status, statusCode } = inputs;\n  if (typeof status !== \"string\" && status !== undefined) {\n    throw new Error(\n      `Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${status}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`\n    );\n  }\n  switch (status?.toLocaleLowerCase()) {\n    case undefined:\n      return toOperationStatus(statusCode);\n    case \"succeeded\":\n      return \"succeeded\";\n    case \"failed\":\n      return \"failed\";\n    case \"running\":\n    case \"accepted\":\n    case \"started\":\n    case \"canceling\":\n    case \"cancelling\":\n      return \"running\";\n    case \"canceled\":\n    case \"cancelled\":\n      return \"canceled\";\n    default: {\n      logger.warning(`LRO: unrecognized operation status: ${status}`);\n      return status as OperationStatus;\n    }\n  }\n}\n\nfunction getStatus(rawResponse: RawResponse): OperationStatus {\n  const { status } = (rawResponse.body as ResponseBody) ?? {};\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction getProvisioningState(rawResponse: RawResponse): OperationStatus {\n  const { properties, provisioningState } = (rawResponse.body as ResponseBody) ?? {};\n  const status = properties?.provisioningState ?? provisioningState;\n  return transformStatus({ status, statusCode: rawResponse.statusCode });\n}\n\nfunction toOperationStatus(statusCode: number): OperationStatus {\n  if (statusCode === 202) {\n    return \"running\";\n  } else if (statusCode < 300) {\n    return \"succeeded\";\n  } else {\n    return \"failed\";\n  }\n}\n\nexport function parseRetryAfter<T>({ rawResponse }: LroResponse<T>): number | undefined {\n  const retryAfter: string | undefined = rawResponse.headers[\"retry-after\"];\n  if (retryAfter !== undefined) {\n    // Retry-After header value is either in HTTP date format, or in seconds\n    const retryAfterInSeconds = parseInt(retryAfter);\n    return isNaN(retryAfterInSeconds)\n      ? calculatePollingIntervalFromDate(new Date(retryAfter))\n      : retryAfterInSeconds * 1000;\n  }\n  return undefined;\n}\n\nfunction calculatePollingIntervalFromDate(retryAfterDate: Date): number | undefined {\n  const timeNow = Math.floor(new Date().getTime());\n  const retryAfterTime = retryAfterDate.getTime();\n  if (timeNow < retryAfterTime) {\n    return retryAfterTime - timeNow;\n  }\n  return undefined;\n}\n\nexport function getStatusFromInitialResponse<TState>(inputs: {\n  response: LroResponse<unknown>;\n  state: RestorableOperationState<TState>;\n  operationLocation?: string;\n}): OperationStatus {\n  const { response, state, operationLocation } = inputs;\n  function helper(): OperationStatus {\n    const mode = state.config.metadata?.[\"mode\"];\n    switch (mode) {\n      case undefined:\n        return toOperationStatus(response.rawResponse.statusCode);\n      case \"Body\":\n        return getOperationStatus(response, state);\n      default:\n        return \"running\";\n    }\n  }\n  const status = helper();\n  return status === \"running\" && operationLocation === undefined ? \"succeeded\" : status;\n}\n\n/**\n * Initiates the long-running operation.\n */\nexport async function initHttpOperation<TResult, TState>(inputs: {\n  stateProxy: StateProxy<TState, TResult>;\n  resourceLocationConfig?: LroResourceLocationConfig;\n  processResult?: (result: unknown, state: TState) => TResult;\n  setErrorAsResult: boolean;\n  lro: LongRunningOperation;\n}): Promise<RestorableOperationState<TState>> {\n  const { stateProxy, resourceLocationConfig, processResult, lro, setErrorAsResult } = inputs;\n  return initOperation({\n    init: async () => {\n      const response = await lro.sendInitialRequest();\n      const config = inferLroMode({\n        rawResponse: response.rawResponse,\n        requestPath: lro.requestPath,\n        requestMethod: lro.requestMethod,\n        resourceLocationConfig,\n      });\n      return {\n        response,\n        operationLocation: config?.operationLocation,\n        resourceLocation: config?.resourceLocation,\n        ...(config?.mode ? { metadata: { mode: config.mode } } : {}),\n      };\n    },\n    stateProxy,\n    processResult: processResult\n      ? ({ flatResponse }, state) => processResult(flatResponse, state)\n      : ({ flatResponse }) => flatResponse as TResult,\n    getOperationStatus: getStatusFromInitialResponse,\n    setErrorAsResult,\n  });\n}\n\nexport function getOperationLocation<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): string | undefined {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getOperationLocationPollingUrl({\n        operationLocation: getOperationLocationHeader(rawResponse),\n        azureAsyncOperation: getAzureAsyncOperationHeader(rawResponse),\n      });\n    }\n    case \"ResourceLocation\": {\n      return getLocationHeader(rawResponse);\n    }\n    case \"Body\":\n    default: {\n      return undefined;\n    }\n  }\n}\n\nexport function getOperationStatus<TState>(\n  { rawResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): OperationStatus {\n  const mode = state.config.metadata?.[\"mode\"];\n  switch (mode) {\n    case \"OperationLocation\": {\n      return getStatus(rawResponse);\n    }\n    case \"ResourceLocation\": {\n      return toOperationStatus(rawResponse.statusCode);\n    }\n    case \"Body\": {\n      return getProvisioningState(rawResponse);\n    }\n    default:\n      throw new Error(`Internal error: Unexpected operation mode: ${mode}`);\n  }\n}\n\nexport function getResourceLocation<TState>(\n  { flatResponse }: LroResponse,\n  state: RestorableOperationState<TState>\n): string | undefined {\n  if (typeof flatResponse === \"object\") {\n    const resourceLocation = (flatResponse as { resourceLocation?: string }).resourceLocation;\n    if (resourceLocation !== undefined) {\n      state.config.resourceLocation = resourceLocation;\n    }\n  }\n  return state.config.resourceLocation;\n}\n\nexport function isOperationError(e: Error): boolean {\n  return e.name === \"RestError\";\n}\n\n/** Polls the long-running operation. */\nexport async function pollHttpOperation<TState, TResult>(inputs: {\n  lro: LongRunningOperation;\n  stateProxy: StateProxy<TState, TResult>;\n  processResult?: (result: unknown, state: TState) => TResult;\n  updateState?: (state: TState, lastResponse: LroResponse) => void;\n  isDone?: (lastResponse: LroResponse, state: TState) => boolean;\n  setDelay: (intervalInMs: number) => void;\n  options?: { abortSignal?: AbortSignalLike };\n  state: RestorableOperationState<TState>;\n  setErrorAsResult: boolean;\n}): Promise<void> {\n  const {\n    lro,\n    stateProxy,\n    options,\n    processResult,\n    updateState,\n    setDelay,\n    state,\n    setErrorAsResult,\n  } = inputs;\n  return pollOperation({\n    state,\n    stateProxy,\n    setDelay,\n    processResult: processResult\n      ? ({ flatResponse }, inputState) => processResult(flatResponse, inputState)\n      : ({ flatResponse }) => flatResponse as TResult,\n    updateState,\n    getPollingInterval: parseRetryAfter,\n    getOperationLocation,\n    getOperationStatus,\n    isOperationError,\n    getResourceLocation,\n    options,\n    /**\n     * The expansion here is intentional because `lro` could be an object that\n     * references an inner this, so we need to preserve a reference to it.\n     */\n    poll: async (location, inputOptions) => lro.sendPollRequest(location, inputOptions),\n    setErrorAsResult,\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}