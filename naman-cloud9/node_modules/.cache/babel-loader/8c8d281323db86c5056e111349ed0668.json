{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BlobSASPermissions } from \"./BlobSASPermissions\";\nimport { ContainerSASPermissions } from \"./ContainerSASPermissions\";\nimport { StorageSharedKeyCredential } from \"../credentials/StorageSharedKeyCredential\";\nimport { UserDelegationKeyCredential } from \"../credentials/UserDelegationKeyCredential\";\nimport { ipRangeToString } from \"./SasIPRange\";\nimport { SASQueryParameters } from \"./SASQueryParameters\";\nimport { SERVICE_VERSION } from \"../utils/constants\";\nimport { truncatedISO8061Date } from \"../utils/utils.common\";\nexport function generateBlobSASQueryParameters(blobSASSignatureValues, sharedKeyCredentialOrUserDelegationKey, accountName) {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n  const sharedKeyCredential = sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential ? sharedKeyCredentialOrUserDelegationKey : undefined;\n  let userDelegationKeyCredential;\n\n  if (sharedKeyCredential === undefined && accountName !== undefined) {\n    userDelegationKeyCredential = new UserDelegationKeyCredential(accountName, sharedKeyCredentialOrUserDelegationKey);\n  }\n\n  if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {\n    throw TypeError(\"Invalid sharedKeyCredential, userDelegationKey or accountName.\");\n  } // Version 2020-12-06 adds support for encryptionscope in SAS.\n\n\n  if (version >= \"2020-12-06\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      return generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential);\n    }\n  } // Version 2019-12-12 adds support for the blob tags permission.\n  // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.\n  // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string\n\n\n  if (version >= \"2018-11-09\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      // Version 2020-02-10 delegation SAS signature construction includes preauthorizedAgentObjectId, agentObjectId, correlationId.\n      if (version >= \"2020-02-10\") {\n        return generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential);\n      } else {\n        return generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential);\n      }\n    }\n  }\n\n  if (version >= \"2015-04-05\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      throw new RangeError(\"'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.\");\n    }\n  }\n\n  throw new RangeError(\"'version' must be >= '2015-04-05'.\");\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\n\nfunction generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n\n  let resource = \"c\";\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\n\n\nfunction generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType);\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\n\n\nfunction generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (!blobSASSignatureValues.identifier && !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\");\n  }\n\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(sharedKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), blobSASSignatureValues.identifier, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.encryptionScope, blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\", blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\", blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\", blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\", blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\"].join(\"\\n\");\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, undefined, undefined, undefined, blobSASSignatureValues.encryptionScope);\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\n\n\nfunction generateBlobSASQueryParametersUDK20181109(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues); // Stored access policies are not supported for a user delegation SAS.\n\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey);\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-02-10.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\n\n\nfunction generateBlobSASQueryParametersUDK20200210(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues); // Stored access policies are not supported for a user delegation SAS.\n\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.preauthorizedAgentObjectId, undefined, blobSASSignatureValues.correlationId, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId);\n}\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\n\n\nfunction generateBlobSASQueryParametersUDK20201206(blobSASSignatureValues, userDelegationKeyCredential) {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues); // Stored access policies are not supported for a user delegation SAS.\n\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\");\n  }\n\n  let resource = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  } // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n\n\n  let verifiedPermissions;\n\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(blobSASSignatureValues.permissions.toString()).toString();\n    }\n  } // Signature is generated on the un-url-encoded values.\n\n\n  const stringToSign = [verifiedPermissions ? verifiedPermissions : \"\", blobSASSignatureValues.startsOn ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false) : \"\", blobSASSignatureValues.expiresOn ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false) : \"\", getCanonicalName(userDelegationKeyCredential.accountName, blobSASSignatureValues.containerName, blobSASSignatureValues.blobName), userDelegationKeyCredential.userDelegationKey.signedObjectId, userDelegationKeyCredential.userDelegationKey.signedTenantId, userDelegationKeyCredential.userDelegationKey.signedStartsOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedExpiresOn ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false) : \"\", userDelegationKeyCredential.userDelegationKey.signedService, userDelegationKeyCredential.userDelegationKey.signedVersion, blobSASSignatureValues.preauthorizedAgentObjectId, undefined, blobSASSignatureValues.correlationId, blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\", blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\", blobSASSignatureValues.version, resource, timestamp, blobSASSignatureValues.encryptionScope, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType].join(\"\\n\");\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(blobSASSignatureValues.version, signature, verifiedPermissions, undefined, undefined, blobSASSignatureValues.protocol, blobSASSignatureValues.startsOn, blobSASSignatureValues.expiresOn, blobSASSignatureValues.ipRange, blobSASSignatureValues.identifier, resource, blobSASSignatureValues.cacheControl, blobSASSignatureValues.contentDisposition, blobSASSignatureValues.contentEncoding, blobSASSignatureValues.contentLanguage, blobSASSignatureValues.contentType, userDelegationKeyCredential.userDelegationKey, blobSASSignatureValues.preauthorizedAgentObjectId, blobSASSignatureValues.correlationId, blobSASSignatureValues.encryptionScope);\n}\n\nfunction getCanonicalName(accountName, containerName, blobName) {\n  // Container: \"/blob/account/containerName\"\n  // Blob:      \"/blob/account/containerName/blobName\"\n  const elements = [`/blob/${accountName}/${containerName}`];\n\n  if (blobName) {\n    elements.push(`/${blobName}`);\n  }\n\n  return elements.join(\"\");\n}\n\nfunction SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues) {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n\n  if (blobSASSignatureValues.snapshotTime && version < \"2018-11-09\") {\n    throw RangeError(\"'version' must be >= '2018-11-09' when providing 'snapshotTime'.\");\n  }\n\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {\n    throw RangeError(\"Must provide 'blobName' when providing 'snapshotTime'.\");\n  }\n\n  if (blobSASSignatureValues.versionId && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'versionId'.\");\n  }\n\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {\n    throw RangeError(\"Must provide 'blobName' when providing 'versionId'.\");\n  }\n\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.setImmutabilityPolicy && version < \"2020-08-04\") {\n    throw RangeError(\"'version' must be >= '2020-08-04' when provided 'i' permission.\");\n  }\n\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.deleteVersion && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'x' permission.\");\n  }\n\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.permanentDelete && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'y' permission.\");\n  }\n\n  if (blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.tag && version < \"2019-12-12\") {\n    throw RangeError(\"'version' must be >= '2019-12-12' when providing 't' permission.\");\n  }\n\n  if (version < \"2020-02-10\" && blobSASSignatureValues.permissions && (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.\");\n  }\n\n  if (version < \"2021-04-10\" && blobSASSignatureValues.permissions && blobSASSignatureValues.permissions.filterByTags) {\n    throw RangeError(\"'version' must be >= '2021-04-10' when providing the 'f' permission.\");\n  }\n\n  if (version < \"2020-02-10\" && (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.\");\n  }\n\n  if (blobSASSignatureValues.encryptionScope && version < \"2020-12-06\") {\n    throw RangeError(\"'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.\");\n  }\n\n  blobSASSignatureValues.version = version;\n  return blobSASSignatureValues;\n}","map":{"version":3,"sources":["../../../../src/sas/BlobSASSignatureValues.ts"],"names":[],"mappings":"AAAA;AACA;AACA,SAAS,kBAAT,QAAmC,sBAAnC;AAEA,SAAS,uBAAT,QAAwC,2BAAxC;AACA,SAAS,0BAAT,QAA2C,2CAA3C;AACA,SAAS,2BAAT,QAA4C,4CAA5C;AACA,SAAS,eAAT,QAA4C,cAA5C;AACA,SAAsB,kBAAtB,QAAgD,sBAAhD;AACA,SAAS,eAAT,QAAgC,oBAAhC;AACA,SAAS,oBAAT,QAAqC,uBAArC;AA4OA,OAAM,SAAU,8BAAV,CACJ,sBADI,EAEJ,sCAFI,EAGJ,WAHI,EAGgB;AAEpB,QAAM,OAAO,GAAG,sBAAsB,CAAC,OAAvB,GAAiC,sBAAsB,CAAC,OAAxD,GAAkE,eAAlF;AAEA,QAAM,mBAAmB,GACvB,sCAAsC,YAAY,0BAAlD,GACI,sCADJ,GAEI,SAHN;AAIA,MAAI,2BAAJ;;AAEA,MAAI,mBAAmB,KAAK,SAAxB,IAAqC,WAAW,KAAK,SAAzD,EAAoE;AAClE,IAAA,2BAA2B,GAAG,IAAI,2BAAJ,CAC5B,WAD4B,EAE5B,sCAF4B,CAA9B;AAID;;AAED,MAAI,mBAAmB,KAAK,SAAxB,IAAqC,2BAA2B,KAAK,SAAzE,EAAoF;AAClF,UAAM,SAAS,CAAC,gEAAD,CAAf;AACD,GAnBmB,CAqBpB;;;AACA,MAAI,OAAO,IAAI,YAAf,EAA6B;AAC3B,QAAI,mBAAmB,KAAK,SAA5B,EAAuC;AACrC,aAAO,sCAAsC,CAAC,sBAAD,EAAyB,mBAAzB,CAA7C;AACD,KAFD,MAEO;AACL,aAAO,yCAAyC,CAC9C,sBAD8C,EAE9C,2BAF8C,CAAhD;AAID;AACF,GA/BmB,CAiCpB;AACA;AACA;;;AACA,MAAI,OAAO,IAAI,YAAf,EAA6B;AAC3B,QAAI,mBAAmB,KAAK,SAA5B,EAAuC;AACrC,aAAO,sCAAsC,CAAC,sBAAD,EAAyB,mBAAzB,CAA7C;AACD,KAFD,MAEO;AACL;AACA,UAAI,OAAO,IAAI,YAAf,EAA6B;AAC3B,eAAO,yCAAyC,CAC9C,sBAD8C,EAE9C,2BAF8C,CAAhD;AAID,OALD,MAKO;AACL,eAAO,yCAAyC,CAC9C,sBAD8C,EAE9C,2BAF8C,CAAhD;AAID;AACF;AACF;;AAED,MAAI,OAAO,IAAI,YAAf,EAA6B;AAC3B,QAAI,mBAAmB,KAAK,SAA5B,EAAuC;AACrC,aAAO,sCAAsC,CAAC,sBAAD,EAAyB,mBAAzB,CAA7C;AACD,KAFD,MAEO;AACL,YAAM,IAAI,UAAJ,CACJ,kGADI,CAAN;AAGD;AACF;;AAED,QAAM,IAAI,UAAJ,CAAe,oCAAf,CAAN;AACD;AAED;;;;;;;;;;;;;;;AAeG;;AACH,SAAS,sCAAT,CACE,sBADF,EAEE,mBAFF,EAEiD;AAE/C,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE;;AAEA,MACE,CAAC,sBAAsB,CAAC,UAAxB,IACA,EAAE,sBAAsB,CAAC,WAAvB,IAAsC,sBAAsB,CAAC,SAA/D,CAFF,EAGE;AACA,UAAM,IAAI,UAAJ,CACJ,uGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;AACD,GAhB8C,CAkB/C;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GA9B8C,CAgC/C;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,mBAAmB,CAAC,WADN,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,sBAAsB,CAAC,UAbJ,EAcnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EAdhE,EAenB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EAfjD,EAgBnB,sBAAsB,CAAC,OAhBJ,EAiBnB,sBAAsB,CAAC,YAAvB,GAAsC,sBAAsB,CAAC,YAA7D,GAA4E,EAjBzD,EAkBnB,sBAAsB,CAAC,kBAAvB,GAA4C,sBAAsB,CAAC,kBAAnE,GAAwF,EAlBrE,EAmBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EAnB/D,EAoBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EApB/D,EAqBnB,sBAAsB,CAAC,WAAvB,GAAqC,sBAAsB,CAAC,WAA5D,GAA0E,EArBvD,EAsBnB,IAtBmB,CAsBd,IAtBc,CAArB;AAwBA,QAAM,SAAS,GAAG,mBAAmB,CAAC,iBAApB,CAAsC,YAAtC,CAAlB;AAEA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,CAAP;AAkBD;AAED;;;;;;;;;;;;;;;AAeG;;;AACH,SAAS,sCAAT,CACE,sBADF,EAEE,mBAFF,EAEiD;AAE/C,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE;;AAEA,MACE,CAAC,sBAAsB,CAAC,UAAxB,IACA,EAAE,sBAAsB,CAAC,WAAvB,IAAsC,sBAAsB,CAAC,SAA/D,CAFF,EAGE;AACA,UAAM,IAAI,UAAJ,CACJ,uGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;AACA,MAAI,SAAS,GAAG,sBAAsB,CAAC,YAAvC;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;;AACA,QAAI,sBAAsB,CAAC,YAA3B,EAAyC;AACvC,MAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO,IAAI,sBAAsB,CAAC,SAA3B,EAAsC;AAC3C,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,sBAAsB,CAAC,SAAnC;AACD;AACF,GAvB8C,CAyB/C;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GArC8C,CAuC/C;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,mBAAmB,CAAC,WADN,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,sBAAsB,CAAC,UAbJ,EAcnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EAdhE,EAenB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EAfjD,EAgBnB,sBAAsB,CAAC,OAhBJ,EAiBnB,QAjBmB,EAkBnB,SAlBmB,EAmBnB,sBAAsB,CAAC,YAAvB,GAAsC,sBAAsB,CAAC,YAA7D,GAA4E,EAnBzD,EAoBnB,sBAAsB,CAAC,kBAAvB,GAA4C,sBAAsB,CAAC,kBAAnE,GAAwF,EApBrE,EAqBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EArB/D,EAsBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EAtB/D,EAuBnB,sBAAsB,CAAC,WAAvB,GAAqC,sBAAsB,CAAC,WAA5D,GAA0E,EAvBvD,EAwBnB,IAxBmB,CAwBd,IAxBc,CAArB;AA0BA,QAAM,SAAS,GAAG,mBAAmB,CAAC,iBAApB,CAAsC,YAAtC,CAAlB;AAEA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,CAAP;AAkBD;AAED;;;;;;;;;;;;;;;AAeG;;;AACH,SAAS,sCAAT,CACE,sBADF,EAEE,mBAFF,EAEiD;AAE/C,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE;;AAEA,MACE,CAAC,sBAAsB,CAAC,UAAxB,IACA,EAAE,sBAAsB,CAAC,WAAvB,IAAsC,sBAAsB,CAAC,SAA/D,CAFF,EAGE;AACA,UAAM,IAAI,UAAJ,CACJ,uGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;AACA,MAAI,SAAS,GAAG,sBAAsB,CAAC,YAAvC;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;;AACA,QAAI,sBAAsB,CAAC,YAA3B,EAAyC;AACvC,MAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO,IAAI,sBAAsB,CAAC,SAA3B,EAAsC;AAC3C,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,sBAAsB,CAAC,SAAnC;AACD;AACF,GAvB8C,CAyB/C;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GArC8C,CAuC/C;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,mBAAmB,CAAC,WADN,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,sBAAsB,CAAC,UAbJ,EAcnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EAdhE,EAenB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EAfjD,EAgBnB,sBAAsB,CAAC,OAhBJ,EAiBnB,QAjBmB,EAkBnB,SAlBmB,EAmBnB,sBAAsB,CAAC,eAnBJ,EAoBnB,sBAAsB,CAAC,YAAvB,GAAsC,sBAAsB,CAAC,YAA7D,GAA4E,EApBzD,EAqBnB,sBAAsB,CAAC,kBAAvB,GAA4C,sBAAsB,CAAC,kBAAnE,GAAwF,EArBrE,EAsBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EAtB/D,EAuBnB,sBAAsB,CAAC,eAAvB,GAAyC,sBAAsB,CAAC,eAAhE,GAAkF,EAvB/D,EAwBnB,sBAAsB,CAAC,WAAvB,GAAqC,sBAAsB,CAAC,WAA5D,GAA0E,EAxBvD,EAyBnB,IAzBmB,CAyBd,IAzBc,CAArB;AA2BA,QAAM,SAAS,GAAG,mBAAmB,CAAC,iBAApB,CAAsC,YAAtC,CAAlB;AAEA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,EAiBL,SAjBK,EAkBL,SAlBK,EAmBL,SAnBK,EAoBL,sBAAsB,CAAC,eApBlB,CAAP;AAsBD;AAED;;;;;;;;;;;;;AAaG;;;AACH,SAAS,yCAAT,CACE,sBADF,EAEE,2BAFF,EAE0D;AAExD,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE,CAFwD,CAIxD;;AACA,MAAI,CAAC,sBAAsB,CAAC,WAAxB,IAAuC,CAAC,sBAAsB,CAAC,SAAnE,EAA8E;AAC5E,UAAM,IAAI,UAAJ,CACJ,yGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;AACA,MAAI,SAAS,GAAG,sBAAsB,CAAC,YAAvC;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;;AACA,QAAI,sBAAsB,CAAC,YAA3B,EAAyC;AACvC,MAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO,IAAI,sBAAsB,CAAC,SAA3B,EAAsC;AAC3C,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,sBAAsB,CAAC,SAAnC;AACD;AACF,GArBuD,CAuBxD;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GAnCuD,CAqCxD;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,2BAA2B,CAAC,WADd,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,2BAA2B,CAAC,iBAA5B,CAA8C,cAb3B,EAcnB,2BAA2B,CAAC,iBAA5B,CAA8C,cAd3B,EAenB,2BAA2B,CAAC,iBAA5B,CAA8C,cAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,cAA/C,EAA+D,KAA/D,CADxB,GAEI,EAjBe,EAkBnB,2BAA2B,CAAC,iBAA5B,CAA8C,eAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,eAA/C,EAAgE,KAAhE,CADxB,GAEI,EApBe,EAqBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aArB3B,EAsBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aAtB3B,EAuBnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EAvBhE,EAwBnB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EAxBjD,EAyBnB,sBAAsB,CAAC,OAzBJ,EA0BnB,QA1BmB,EA2BnB,SA3BmB,EA4BnB,sBAAsB,CAAC,YA5BJ,EA6BnB,sBAAsB,CAAC,kBA7BJ,EA8BnB,sBAAsB,CAAC,eA9BJ,EA+BnB,sBAAsB,CAAC,eA/BJ,EAgCnB,sBAAsB,CAAC,WAhCJ,EAiCnB,IAjCmB,CAiCd,IAjCc,CAArB;AAmCA,QAAM,SAAS,GAAG,2BAA2B,CAAC,iBAA5B,CAA8C,YAA9C,CAAlB;AACA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,EAiBL,2BAA2B,CAAC,iBAjBvB,CAAP;AAmBD;AAED;;;;;;;;;;;;;AAaG;;;AACH,SAAS,yCAAT,CACE,sBADF,EAEE,2BAFF,EAE0D;AAExD,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE,CAFwD,CAIxD;;AACA,MAAI,CAAC,sBAAsB,CAAC,WAAxB,IAAuC,CAAC,sBAAsB,CAAC,SAAnE,EAA8E;AAC5E,UAAM,IAAI,UAAJ,CACJ,yGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;AACA,MAAI,SAAS,GAAG,sBAAsB,CAAC,YAAvC;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;;AACA,QAAI,sBAAsB,CAAC,YAA3B,EAAyC;AACvC,MAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO,IAAI,sBAAsB,CAAC,SAA3B,EAAsC;AAC3C,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,sBAAsB,CAAC,SAAnC;AACD;AACF,GArBuD,CAuBxD;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GAnCuD,CAqCxD;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,2BAA2B,CAAC,WADd,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,2BAA2B,CAAC,iBAA5B,CAA8C,cAb3B,EAcnB,2BAA2B,CAAC,iBAA5B,CAA8C,cAd3B,EAenB,2BAA2B,CAAC,iBAA5B,CAA8C,cAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,cAA/C,EAA+D,KAA/D,CADxB,GAEI,EAjBe,EAkBnB,2BAA2B,CAAC,iBAA5B,CAA8C,eAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,eAA/C,EAAgE,KAAhE,CADxB,GAEI,EApBe,EAqBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aArB3B,EAsBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aAtB3B,EAuBnB,sBAAsB,CAAC,0BAvBJ,EAwBnB,SAxBmB,EAyBnB,sBAAsB,CAAC,aAzBJ,EA0BnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EA1BhE,EA2BnB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EA3BjD,EA4BnB,sBAAsB,CAAC,OA5BJ,EA6BnB,QA7BmB,EA8BnB,SA9BmB,EA+BnB,sBAAsB,CAAC,YA/BJ,EAgCnB,sBAAsB,CAAC,kBAhCJ,EAiCnB,sBAAsB,CAAC,eAjCJ,EAkCnB,sBAAsB,CAAC,eAlCJ,EAmCnB,sBAAsB,CAAC,WAnCJ,EAoCnB,IApCmB,CAoCd,IApCc,CAArB;AAsCA,QAAM,SAAS,GAAG,2BAA2B,CAAC,iBAA5B,CAA8C,YAA9C,CAAlB;AACA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,EAiBL,2BAA2B,CAAC,iBAjBvB,EAkBL,sBAAsB,CAAC,0BAlBlB,EAmBL,sBAAsB,CAAC,aAnBlB,CAAP;AAqBD;AAED;;;;;;;;;;;;;AAaG;;;AACH,SAAS,yCAAT,CACE,sBADF,EAEE,2BAFF,EAE0D;AAExD,EAAA,sBAAsB,GAAG,wCAAwC,CAAC,sBAAD,CAAjE,CAFwD,CAIxD;;AACA,MAAI,CAAC,sBAAsB,CAAC,WAAxB,IAAuC,CAAC,sBAAsB,CAAC,SAAnE,EAA8E;AAC5E,UAAM,IAAI,UAAJ,CACJ,yGADI,CAAN;AAGD;;AAED,MAAI,QAAQ,GAAW,GAAvB;AACA,MAAI,SAAS,GAAG,sBAAsB,CAAC,YAAvC;;AACA,MAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,IAAA,QAAQ,GAAG,GAAX;;AACA,QAAI,sBAAsB,CAAC,YAA3B,EAAyC;AACvC,MAAA,QAAQ,GAAG,IAAX;AACD,KAFD,MAEO,IAAI,sBAAsB,CAAC,SAA3B,EAAsC;AAC3C,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,sBAAsB,CAAC,SAAnC;AACD;AACF,GArBuD,CAuBxD;;;AACA,MAAI,mBAAJ;;AACA,MAAI,sBAAsB,CAAC,WAA3B,EAAwC;AACtC,QAAI,sBAAsB,CAAC,QAA3B,EAAqC;AACnC,MAAA,mBAAmB,GAAG,kBAAkB,CAAC,KAAnB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD,KAJD,MAIO;AACL,MAAA,mBAAmB,GAAG,uBAAuB,CAAC,KAAxB,CACpB,sBAAsB,CAAC,WAAvB,CAAmC,QAAnC,EADoB,EAEpB,QAFoB,EAAtB;AAGD;AACF,GAnCuD,CAqCxD;;;AACA,QAAM,YAAY,GAAG,CACnB,mBAAmB,GAAG,mBAAH,GAAyB,EADzB,EAEnB,sBAAsB,CAAC,QAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,QAAxB,EAAkC,KAAlC,CADxB,GAEI,EAJe,EAKnB,sBAAsB,CAAC,SAAvB,GACI,oBAAoB,CAAC,sBAAsB,CAAC,SAAxB,EAAmC,KAAnC,CADxB,GAEI,EAPe,EAQnB,gBAAgB,CACd,2BAA2B,CAAC,WADd,EAEd,sBAAsB,CAAC,aAFT,EAGd,sBAAsB,CAAC,QAHT,CARG,EAanB,2BAA2B,CAAC,iBAA5B,CAA8C,cAb3B,EAcnB,2BAA2B,CAAC,iBAA5B,CAA8C,cAd3B,EAenB,2BAA2B,CAAC,iBAA5B,CAA8C,cAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,cAA/C,EAA+D,KAA/D,CADxB,GAEI,EAjBe,EAkBnB,2BAA2B,CAAC,iBAA5B,CAA8C,eAA9C,GACI,oBAAoB,CAAC,2BAA2B,CAAC,iBAA5B,CAA8C,eAA/C,EAAgE,KAAhE,CADxB,GAEI,EApBe,EAqBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aArB3B,EAsBnB,2BAA2B,CAAC,iBAA5B,CAA8C,aAtB3B,EAuBnB,sBAAsB,CAAC,0BAvBJ,EAwBnB,SAxBmB,EAyBnB,sBAAsB,CAAC,aAzBJ,EA0BnB,sBAAsB,CAAC,OAAvB,GAAiC,eAAe,CAAC,sBAAsB,CAAC,OAAxB,CAAhD,GAAmF,EA1BhE,EA2BnB,sBAAsB,CAAC,QAAvB,GAAkC,sBAAsB,CAAC,QAAzD,GAAoE,EA3BjD,EA4BnB,sBAAsB,CAAC,OA5BJ,EA6BnB,QA7BmB,EA8BnB,SA9BmB,EA+BnB,sBAAsB,CAAC,eA/BJ,EAgCnB,sBAAsB,CAAC,YAhCJ,EAiCnB,sBAAsB,CAAC,kBAjCJ,EAkCnB,sBAAsB,CAAC,eAlCJ,EAmCnB,sBAAsB,CAAC,eAnCJ,EAoCnB,sBAAsB,CAAC,WApCJ,EAqCnB,IArCmB,CAqCd,IArCc,CAArB;AAuCA,QAAM,SAAS,GAAG,2BAA2B,CAAC,iBAA5B,CAA8C,YAA9C,CAAlB;AACA,SAAO,IAAI,kBAAJ,CACL,sBAAsB,CAAC,OADlB,EAEL,SAFK,EAGL,mBAHK,EAIL,SAJK,EAKL,SALK,EAML,sBAAsB,CAAC,QANlB,EAOL,sBAAsB,CAAC,QAPlB,EAQL,sBAAsB,CAAC,SARlB,EASL,sBAAsB,CAAC,OATlB,EAUL,sBAAsB,CAAC,UAVlB,EAWL,QAXK,EAYL,sBAAsB,CAAC,YAZlB,EAaL,sBAAsB,CAAC,kBAblB,EAcL,sBAAsB,CAAC,eAdlB,EAeL,sBAAsB,CAAC,eAflB,EAgBL,sBAAsB,CAAC,WAhBlB,EAiBL,2BAA2B,CAAC,iBAjBvB,EAkBL,sBAAsB,CAAC,0BAlBlB,EAmBL,sBAAsB,CAAC,aAnBlB,EAoBL,sBAAsB,CAAC,eApBlB,CAAP;AAsBD;;AAED,SAAS,gBAAT,CAA0B,WAA1B,EAA+C,aAA/C,EAAsE,QAAtE,EAAuF;AACrF;AACA;AACA,QAAM,QAAQ,GAAa,CAAC,SAAS,WAAW,IAAI,aAAa,EAAtC,CAA3B;;AACA,MAAI,QAAJ,EAAc;AACZ,IAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,QAAQ,EAA1B;AACD;;AACD,SAAO,QAAQ,CAAC,IAAT,CAAc,EAAd,CAAP;AACD;;AAED,SAAS,wCAAT,CACE,sBADF,EACgD;AAE9C,QAAM,OAAO,GAAG,sBAAsB,CAAC,OAAvB,GAAiC,sBAAsB,CAAC,OAAxD,GAAkE,eAAlF;;AACA,MAAI,sBAAsB,CAAC,YAAvB,IAAuC,OAAO,GAAG,YAArD,EAAmE;AACjE,UAAM,UAAU,CAAC,kEAAD,CAAhB;AACD;;AACD,MAAI,sBAAsB,CAAC,QAAvB,KAAoC,SAApC,IAAiD,sBAAsB,CAAC,YAA5E,EAA0F;AACxF,UAAM,UAAU,CAAC,wDAAD,CAAhB;AACD;;AAED,MAAI,sBAAsB,CAAC,SAAvB,IAAoC,OAAO,GAAG,YAAlD,EAAgE;AAC9D,UAAM,UAAU,CAAC,+DAAD,CAAhB;AACD;;AACD,MAAI,sBAAsB,CAAC,QAAvB,KAAoC,SAApC,IAAiD,sBAAsB,CAAC,SAA5E,EAAuF;AACrF,UAAM,UAAU,CAAC,qDAAD,CAAhB;AACD;;AAED,MACE,sBAAsB,CAAC,WAAvB,IACA,sBAAsB,CAAC,WAAvB,CAAmC,qBADnC,IAEA,OAAO,GAAG,YAHZ,EAIE;AACA,UAAM,UAAU,CAAC,iEAAD,CAAhB;AACD;;AAED,MACE,sBAAsB,CAAC,WAAvB,IACA,sBAAsB,CAAC,WAAvB,CAAmC,aADnC,IAEA,OAAO,GAAG,YAHZ,EAIE;AACA,UAAM,UAAU,CAAC,kEAAD,CAAhB;AACD;;AAED,MACE,sBAAsB,CAAC,WAAvB,IACA,sBAAsB,CAAC,WAAvB,CAAmC,eADnC,IAEA,OAAO,GAAG,YAHZ,EAIE;AACA,UAAM,UAAU,CAAC,kEAAD,CAAhB;AACD;;AAED,MACE,sBAAsB,CAAC,WAAvB,IACA,sBAAsB,CAAC,WAAvB,CAAmC,GADnC,IAEA,OAAO,GAAG,YAHZ,EAIE;AACA,UAAM,UAAU,CAAC,kEAAD,CAAhB;AACD;;AAED,MACE,OAAO,GAAG,YAAV,IACA,sBAAsB,CAAC,WADvB,KAEC,sBAAsB,CAAC,WAAvB,CAAmC,IAAnC,IAA2C,sBAAsB,CAAC,WAAvB,CAAmC,OAF/E,CADF,EAIE;AACA,UAAM,UAAU,CAAC,6EAAD,CAAhB;AACD;;AAED,MACE,OAAO,GAAG,YAAV,IACA,sBAAsB,CAAC,WADvB,IAEC,sBAAsB,CAAC,WAAvB,CAA+D,YAHlE,EAIE;AACA,UAAM,UAAU,CAAC,sEAAD,CAAhB;AACD;;AAED,MACE,OAAO,GAAG,YAAV,KACC,sBAAsB,CAAC,0BAAvB,IAAqD,sBAAsB,CAAC,aAD7E,CADF,EAGE;AACA,UAAM,UAAU,CACd,mGADc,CAAhB;AAGD;;AAED,MAAI,sBAAsB,CAAC,eAAvB,IAA0C,OAAO,GAAG,YAAxD,EAAsE;AACpE,UAAM,UAAU,CAAC,2EAAD,CAAhB;AACD;;AAED,EAAA,sBAAsB,CAAC,OAAvB,GAAiC,OAAjC;AACA,SAAO,sBAAP;AACD","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BlobSASPermissions } from \"./BlobSASPermissions\";\nimport { UserDelegationKey } from \"../BlobServiceClient\";\nimport { ContainerSASPermissions } from \"./ContainerSASPermissions\";\nimport { StorageSharedKeyCredential } from \"../credentials/StorageSharedKeyCredential\";\nimport { UserDelegationKeyCredential } from \"../credentials/UserDelegationKeyCredential\";\nimport { ipRangeToString, SasIPRange } from \"./SasIPRange\";\nimport { SASProtocol, SASQueryParameters } from \"./SASQueryParameters\";\nimport { SERVICE_VERSION } from \"../utils/constants\";\nimport { truncatedISO8061Date } from \"../utils/utils.common\";\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * BlobSASSignatureValues is used to help generating Blob service SAS tokens for containers or blobs.\n */\nexport interface BlobSASSignatureValues {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols, HTTPS only or HTTPSandHTTP\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n\n  /**\n   * Optional only when identifier is provided. The time after which the SAS will no longer work.\n   */\n  expiresOn?: Date;\n\n  /**\n   * Optional only when identifier is provided.\n   * Please refer to either {@link ContainerSASPermissions} or {@link BlobSASPermissions} depending on the resource\n   * being accessed for help constructing the permissions string.\n   */\n  permissions?: BlobSASPermissions | ContainerSASPermissions;\n\n  /**\n   * Optional. IP ranges allowed in this SAS.\n   */\n  ipRange?: SasIPRange;\n\n  /**\n   * The name of the container the SAS user may access.\n   */\n  containerName: string;\n\n  /**\n   * Optional. The blob name of the SAS user may access. Required if snapshotTime or versionId is provided.\n   */\n  blobName?: string;\n\n  /**\n   * Optional. Snapshot timestamp string the SAS user may access. Only supported from API version 2018-11-09.\n   */\n  snapshotTime?: string;\n\n  /**\n   * Optional. VersionId of the blob version the SAS user may access. Only supported from API version 2019-10-10.\n   */\n  versionId?: string;\n\n  /**\n   * Optional. The name of the access policy on the container this SAS references if any.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/establishing-a-stored-access-policy\n   */\n  identifier?: string;\n\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n\n  /**\n   * Optional. The cache-control header for the SAS.\n   */\n  cacheControl?: string;\n\n  /**\n   * Optional. The content-disposition header for the SAS.\n   */\n  contentDisposition?: string;\n\n  /**\n   * Optional. The content-encoding header for the SAS.\n   */\n  contentEncoding?: string;\n\n  /**\n   * Optional. The content-language header for the SAS.\n   */\n  contentLanguage?: string;\n\n  /**\n   * Optional. The content-type header for the SAS.\n   */\n  contentType?: string;\n\n  /**\n   * Optional. Beginning in version 2020-02-10, specifies the Authorized AAD Object ID in GUID format. The AAD Object ID of a user\n   * authorized by the owner of the user delegation key to perform the action granted by the SAS. The Azure Storage service will\n   * ensure that the owner of the user delegation key has the required permissions before granting access but no additional permission\n   * check for the user specified in this value will be performed. This is only used for User Delegation SAS.\n   */\n  preauthorizedAgentObjectId?: string;\n\n  /**\n   * Optional. Beginning in version 2020-02-10, this is a GUID value that will be logged in the storage diagnostic logs and can be used to\n   * correlate SAS generation with storage resource access. This is only used for User Delegation SAS.\n   */\n  correlationId?: string;\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * Fill in the required details before running the following snippets.\n *\n * Example usage:\n *\n * ```js\n * // Generate service level SAS for a container\n * const containerSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     permissions: ContainerSASPermissions.parse(\"racwdl\"), // Required\n *     startsOn: new Date(), // Optional\n *     expiresOn: new Date(new Date().valueOf() + 86400), // Required. Date type\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2016-05-31\" // Optional\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * Example using an identifier:\n *\n * ```js\n * // Generate service level SAS for a container with identifier\n * // startsOn & permissions are optional when identifier is provided\n * const identifier = \"unique-id\";\n * await containerClient.setAccessPolicy(undefined, [\n *   {\n *     accessPolicy: {\n *       expiresOn: new Date(new Date().valueOf() + 86400), // Date type\n *       permissions: ContainerSASPermissions.parse(\"racwdl\").toString(),\n *       startsOn: new Date() // Date type\n *     },\n *     id: identifier\n *   }\n * ]);\n *\n * const containerSAS = generateBlobSASQueryParameters(\n *   {\n *     containerName, // Required\n *     identifier // Required\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * Example using a blob name:\n *\n * ```js\n * // Generate service level SAS for a blob\n * const blobSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     blobName, // Required\n *     permissions: BlobSASPermissions.parse(\"racwd\"), // Required\n *     startsOn: new Date(), // Optional\n *     expiresOn: new Date(new Date().valueOf() + 86400), // Required. Date type\n *     cacheControl: \"cache-control-override\", // Optional\n *     contentDisposition: \"content-disposition-override\", // Optional\n *     contentEncoding: \"content-encoding-override\", // Optional\n *     contentLanguage: \"content-language-override\", // Optional\n *     contentType: \"content-type-override\", // Optional\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2016-05-31\" // Optional\n *   },\n *   sharedKeyCredential // StorageSharedKeyCredential - `new StorageSharedKeyCredential(account, accountKey)`\n * ).toString();\n * ```\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential\n): SASQueryParameters;\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n *\n * Creates an instance of SASQueryParameters.\n * WARNING: identifier will be ignored when generating user delegation SAS, permissions and expiresOn are required.\n *\n * Example usage:\n *\n * ```js\n * // Generate user delegation SAS for a container\n * const userDelegationKey = await blobServiceClient.getUserDelegationKey(startsOn, expiresOn);\n * const containerSAS = generateBlobSASQueryParameters({\n *     containerName, // Required\n *     permissions: ContainerSASPermissions.parse(\"racwdl\"), // Required\n *     startsOn, // Optional. Date type\n *     expiresOn, // Required. Date type\n *     ipRange: { start: \"0.0.0.0\", end: \"255.255.255.255\" }, // Optional\n *     protocol: SASProtocol.HttpsAndHttp, // Optional\n *     version: \"2018-11-09\" // Must greater than or equal to 2018-11-09 to generate user delegation SAS\n *   },\n *   userDelegationKey, // UserDelegationKey\n *   accountName\n * ).toString();\n * ```\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKey - Return value of `blobServiceClient.getUserDelegationKey()`\n * @param accountName -\n */\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKey: UserDelegationKey,\n  accountName: string\n): SASQueryParameters;\n\nexport function generateBlobSASQueryParameters(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredentialOrUserDelegationKey: StorageSharedKeyCredential | UserDelegationKey,\n  accountName?: string\n): SASQueryParameters {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n\n  const sharedKeyCredential =\n    sharedKeyCredentialOrUserDelegationKey instanceof StorageSharedKeyCredential\n      ? sharedKeyCredentialOrUserDelegationKey\n      : undefined;\n  let userDelegationKeyCredential: UserDelegationKeyCredential | undefined;\n\n  if (sharedKeyCredential === undefined && accountName !== undefined) {\n    userDelegationKeyCredential = new UserDelegationKeyCredential(\n      accountName,\n      sharedKeyCredentialOrUserDelegationKey as UserDelegationKey\n    );\n  }\n\n  if (sharedKeyCredential === undefined && userDelegationKeyCredential === undefined) {\n    throw TypeError(\"Invalid sharedKeyCredential, userDelegationKey or accountName.\");\n  }\n\n  // Version 2020-12-06 adds support for encryptionscope in SAS.\n  if (version >= \"2020-12-06\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20201206(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      return generateBlobSASQueryParametersUDK20201206(\n        blobSASSignatureValues,\n        userDelegationKeyCredential!\n      );\n    }\n  }\n\n  // Version 2019-12-12 adds support for the blob tags permission.\n  // Version 2018-11-09 adds support for the signed resource and signed blob snapshot time fields.\n  // https://docs.microsoft.com/en-us/rest/api/storageservices/constructing-a-service-sas#constructing-the-signature-string\n  if (version >= \"2018-11-09\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20181109(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      // Version 2020-02-10 delegation SAS signature construction includes preauthorizedAgentObjectId, agentObjectId, correlationId.\n      if (version >= \"2020-02-10\") {\n        return generateBlobSASQueryParametersUDK20200210(\n          blobSASSignatureValues,\n          userDelegationKeyCredential!\n        );\n      } else {\n        return generateBlobSASQueryParametersUDK20181109(\n          blobSASSignatureValues,\n          userDelegationKeyCredential!\n        );\n      }\n    }\n  }\n\n  if (version >= \"2015-04-05\") {\n    if (sharedKeyCredential !== undefined) {\n      return generateBlobSASQueryParameters20150405(blobSASSignatureValues, sharedKeyCredential);\n    } else {\n      throw new RangeError(\n        \"'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.\"\n      );\n    }\n  }\n\n  throw new RangeError(\"'version' must be >= '2015-04-05'.\");\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2015-04-05 AND BEFORE 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20150405(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType\n  );\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20181109(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType\n  );\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn and identifier.\n *\n * WARNING: When identifier is not provided, permissions and expiresOn are required.\n * You MUST assign value to identifier or expiresOn & permissions manually if you initial with\n * this constructor.\n *\n * @param blobSASSignatureValues -\n * @param sharedKeyCredential -\n */\nfunction generateBlobSASQueryParameters20201206(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  sharedKeyCredential: StorageSharedKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  if (\n    !blobSASSignatureValues.identifier &&\n    !(blobSASSignatureValues.permissions && blobSASSignatureValues.expiresOn)\n  ) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      sharedKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    blobSASSignatureValues.identifier,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.encryptionScope,\n    blobSASSignatureValues.cacheControl ? blobSASSignatureValues.cacheControl : \"\",\n    blobSASSignatureValues.contentDisposition ? blobSASSignatureValues.contentDisposition : \"\",\n    blobSASSignatureValues.contentEncoding ? blobSASSignatureValues.contentEncoding : \"\",\n    blobSASSignatureValues.contentLanguage ? blobSASSignatureValues.contentLanguage : \"\",\n    blobSASSignatureValues.contentType ? blobSASSignatureValues.contentType : \"\",\n  ].join(\"\\n\");\n\n  const signature = sharedKeyCredential.computeHMACSHA256(stringToSign);\n\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n    undefined,\n    undefined,\n    undefined,\n    blobSASSignatureValues.encryptionScope\n  );\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2018-11-09.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20181109(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n    userDelegationKeyCredential.userDelegationKey\n  );\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-02-10.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20200210(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    undefined, // agentObjectId\n    blobSASSignatureValues.correlationId,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n    userDelegationKeyCredential.userDelegationKey,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    blobSASSignatureValues.correlationId\n  );\n}\n\n/**\n * ONLY AVAILABLE IN NODE.JS RUNTIME.\n * IMPLEMENTATION FOR API VERSION FROM 2020-12-06.\n *\n * Creates an instance of SASQueryParameters.\n *\n * Only accepts required settings needed to create a SAS. For optional settings please\n * set corresponding properties directly, such as permissions, startsOn.\n *\n * WARNING: identifier will be ignored, permissions and expiresOn are required.\n *\n * @param blobSASSignatureValues -\n * @param userDelegationKeyCredential -\n */\nfunction generateBlobSASQueryParametersUDK20201206(\n  blobSASSignatureValues: BlobSASSignatureValues,\n  userDelegationKeyCredential: UserDelegationKeyCredential\n): SASQueryParameters {\n  blobSASSignatureValues = SASSignatureValuesSanityCheckAndAutofill(blobSASSignatureValues);\n\n  // Stored access policies are not supported for a user delegation SAS.\n  if (!blobSASSignatureValues.permissions || !blobSASSignatureValues.expiresOn) {\n    throw new RangeError(\n      \"Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.\"\n    );\n  }\n\n  let resource: string = \"c\";\n  let timestamp = blobSASSignatureValues.snapshotTime;\n  if (blobSASSignatureValues.blobName) {\n    resource = \"b\";\n    if (blobSASSignatureValues.snapshotTime) {\n      resource = \"bs\";\n    } else if (blobSASSignatureValues.versionId) {\n      resource = \"bv\";\n      timestamp = blobSASSignatureValues.versionId;\n    }\n  }\n\n  // Calling parse and toString guarantees the proper ordering and throws on invalid characters.\n  let verifiedPermissions: string | undefined;\n  if (blobSASSignatureValues.permissions) {\n    if (blobSASSignatureValues.blobName) {\n      verifiedPermissions = BlobSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    } else {\n      verifiedPermissions = ContainerSASPermissions.parse(\n        blobSASSignatureValues.permissions.toString()\n      ).toString();\n    }\n  }\n\n  // Signature is generated on the un-url-encoded values.\n  const stringToSign = [\n    verifiedPermissions ? verifiedPermissions : \"\",\n    blobSASSignatureValues.startsOn\n      ? truncatedISO8061Date(blobSASSignatureValues.startsOn, false)\n      : \"\",\n    blobSASSignatureValues.expiresOn\n      ? truncatedISO8061Date(blobSASSignatureValues.expiresOn, false)\n      : \"\",\n    getCanonicalName(\n      userDelegationKeyCredential.accountName,\n      blobSASSignatureValues.containerName,\n      blobSASSignatureValues.blobName\n    ),\n    userDelegationKeyCredential.userDelegationKey.signedObjectId,\n    userDelegationKeyCredential.userDelegationKey.signedTenantId,\n    userDelegationKeyCredential.userDelegationKey.signedStartsOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedStartsOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedExpiresOn\n      ? truncatedISO8061Date(userDelegationKeyCredential.userDelegationKey.signedExpiresOn, false)\n      : \"\",\n    userDelegationKeyCredential.userDelegationKey.signedService,\n    userDelegationKeyCredential.userDelegationKey.signedVersion,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    undefined, // agentObjectId\n    blobSASSignatureValues.correlationId,\n    blobSASSignatureValues.ipRange ? ipRangeToString(blobSASSignatureValues.ipRange) : \"\",\n    blobSASSignatureValues.protocol ? blobSASSignatureValues.protocol : \"\",\n    blobSASSignatureValues.version,\n    resource,\n    timestamp,\n    blobSASSignatureValues.encryptionScope,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n  ].join(\"\\n\");\n\n  const signature = userDelegationKeyCredential.computeHMACSHA256(stringToSign);\n  return new SASQueryParameters(\n    blobSASSignatureValues.version!,\n    signature,\n    verifiedPermissions,\n    undefined,\n    undefined,\n    blobSASSignatureValues.protocol,\n    blobSASSignatureValues.startsOn,\n    blobSASSignatureValues.expiresOn,\n    blobSASSignatureValues.ipRange,\n    blobSASSignatureValues.identifier,\n    resource,\n    blobSASSignatureValues.cacheControl,\n    blobSASSignatureValues.contentDisposition,\n    blobSASSignatureValues.contentEncoding,\n    blobSASSignatureValues.contentLanguage,\n    blobSASSignatureValues.contentType,\n    userDelegationKeyCredential.userDelegationKey,\n    blobSASSignatureValues.preauthorizedAgentObjectId,\n    blobSASSignatureValues.correlationId,\n    blobSASSignatureValues.encryptionScope\n  );\n}\n\nfunction getCanonicalName(accountName: string, containerName: string, blobName?: string): string {\n  // Container: \"/blob/account/containerName\"\n  // Blob:      \"/blob/account/containerName/blobName\"\n  const elements: string[] = [`/blob/${accountName}/${containerName}`];\n  if (blobName) {\n    elements.push(`/${blobName}`);\n  }\n  return elements.join(\"\");\n}\n\nfunction SASSignatureValuesSanityCheckAndAutofill(\n  blobSASSignatureValues: BlobSASSignatureValues\n): BlobSASSignatureValues {\n  const version = blobSASSignatureValues.version ? blobSASSignatureValues.version : SERVICE_VERSION;\n  if (blobSASSignatureValues.snapshotTime && version < \"2018-11-09\") {\n    throw RangeError(\"'version' must be >= '2018-11-09' when providing 'snapshotTime'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.snapshotTime) {\n    throw RangeError(\"Must provide 'blobName' when providing 'snapshotTime'.\");\n  }\n\n  if (blobSASSignatureValues.versionId && version < \"2019-10-10\") {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'versionId'.\");\n  }\n  if (blobSASSignatureValues.blobName === undefined && blobSASSignatureValues.versionId) {\n    throw RangeError(\"Must provide 'blobName' when providing 'versionId'.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.setImmutabilityPolicy &&\n    version < \"2020-08-04\"\n  ) {\n    throw RangeError(\"'version' must be >= '2020-08-04' when provided 'i' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.deleteVersion &&\n    version < \"2019-10-10\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'x' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.permanentDelete &&\n    version < \"2019-10-10\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-10-10' when providing 'y' permission.\");\n  }\n\n  if (\n    blobSASSignatureValues.permissions &&\n    blobSASSignatureValues.permissions.tag &&\n    version < \"2019-12-12\"\n  ) {\n    throw RangeError(\"'version' must be >= '2019-12-12' when providing 't' permission.\");\n  }\n\n  if (\n    version < \"2020-02-10\" &&\n    blobSASSignatureValues.permissions &&\n    (blobSASSignatureValues.permissions.move || blobSASSignatureValues.permissions.execute)\n  ) {\n    throw RangeError(\"'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.\");\n  }\n\n  if (\n    version < \"2021-04-10\" &&\n    blobSASSignatureValues.permissions &&\n    (blobSASSignatureValues.permissions as ContainerSASPermissions).filterByTags\n  ) {\n    throw RangeError(\"'version' must be >= '2021-04-10' when providing the 'f' permission.\");\n  }\n\n  if (\n    version < \"2020-02-10\" &&\n    (blobSASSignatureValues.preauthorizedAgentObjectId || blobSASSignatureValues.correlationId)\n  ) {\n    throw RangeError(\n      \"'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.\"\n    );\n  }\n\n  if (blobSASSignatureValues.encryptionScope && version < \"2020-12-06\") {\n    throw RangeError(\"'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.\");\n  }\n\n  blobSASSignatureValues.version = version;\n  return blobSASSignatureValues;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}