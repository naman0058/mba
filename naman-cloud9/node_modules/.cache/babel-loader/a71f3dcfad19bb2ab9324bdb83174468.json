{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/* eslint-disable eqeqeq */\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\"; // This file contains utility code to serialize and deserialize network operations according to `OperationSpec` objects generated by AutoRest.TypeScript from OpenAPI specifications.\n\n/**\n * Used to map raw response objects to final shapes.\n * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.\n * Also allows pulling values from headers, as well as inserting default values and constants.\n */\n\nexport class Serializer {\n  constructor() {\n    let modelMappers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let\n    /**\n     * Whether the contents are XML or not.\n     */\n    isXML = arguments.length > 1 ? arguments[1] : undefined;\n    this.modelMappers = modelMappers;\n    this.isXML = isXML;\n  }\n  /**\n   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.\n   * @param mapper - The definition of data models.\n   * @param value - The value.\n   * @param objectName - Name of the object. Used in the error messages.\n   * @deprecated Removing the constraints validation on client side.\n   */\n\n\n  validateConstraints(mapper, value, objectName) {\n    const failValidation = (constraintName, constraintValue) => {\n      throw new Error(`\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`);\n    };\n\n    if (mapper.constraints && value != undefined) {\n      const valueAsNumber = value;\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems\n      } = mapper.constraints;\n\n      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n\n      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n\n      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n\n      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n\n      const valueAsArray = value;\n\n      if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n\n      if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n\n      if (MinItems != undefined && valueAsArray.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n\n      if (MinLength != undefined && valueAsArray.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n\n      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n\n      if (Pattern) {\n        const pattern = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n\n      if (UniqueItems && valueAsArray.some((item, i, ar) => ar.indexOf(item) !== i)) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n  /**\n   * Serialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param object - A valid Javascript object to be serialized.\n   * @param objectName - Name of the serialized object.\n   * @param options - additional options to deserialization.\n   * @returns A valid serialized Javascript object.\n   */\n\n\n  serialize(mapper, object, objectName) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    var _a, _b, _c;\n\n    const updatedOptions = {\n      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    let payload = {};\n    const mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    } // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n\n    const {\n      required,\n      nullable\n    } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper = mapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);\n      }\n    }\n\n    return payload;\n  }\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param responseBody - A valid Javascript entity to be deserialized.\n   * @param objectName - Name of the deserialized object.\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object.\n   */\n\n\n  deserialize(mapper, responseBody, objectName) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    var _a, _b, _c;\n\n    const updatedOptions = {\n      rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      } // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n\n\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n\n      return responseBody;\n    }\n\n    let payload;\n    const mapperType = mapper.type.name;\n\n    if (!objectName) {\n      objectName = mapper.serializedName;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xmlCharKey;\n        const castResponseBody = responseBody;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n\n        if (castResponseBody[XML_ATTRKEY] != undefined && castResponseBody[xmlCharKey] != undefined) {\n          responseBody = castResponseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody);\n\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n\n}\n\nfunction trimEnd(str, ch) {\n  let len = str.length;\n\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer) {\n  if (!buffer) {\n    return undefined;\n  }\n\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  } // Uint8Array to Base64.\n\n\n  const str = base64.encodeByteArray(buffer); // Base64 to Base64Url.\n\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str) {\n  if (!str) {\n    return undefined;\n  }\n\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  } // Base64Url to Base64.\n\n\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\"); // Base64 to Uint8Array.\n\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop) {\n  const classes = [];\n  let partialclass = \"\";\n\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d) {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d);\n  }\n\n  return Math.floor(d.getTime() / 1000);\n}\n\nfunction unixTimeToDate(n) {\n  if (!n) {\n    return undefined;\n  }\n\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName, objectName, value) {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n\n      if (objectType !== \"string\" && objectType !== \"function\" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)) {\n        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName, allowedValues, value) {\n  if (!allowedValues) {\n    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n  }\n\n  const isPresent = allowedValues.some(item => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n\n    return item === value;\n  });\n\n  if (!isPresent) {\n    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n  }\n\n  return value;\n}\n\nfunction serializeByteArrayType(objectName, value) {\n  let returnValue = \"\";\n\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n\n    returnValue = base64.encodeByteArray(value);\n  }\n\n  return returnValue;\n}\n\nfunction serializeBase64UrlType(objectName, value) {\n  let returnValue = \"\";\n\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n\n  return returnValue;\n}\n\nfunction serializeDateTypes(typeName, value, objectName) {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n\n      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (!(value instanceof Date || typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` + `for it to be serialized in UnixTime/Epoch format.`);\n      }\n\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n\n  const elementType = mapper.type.element;\n\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  }\n\n  const tempArray = [];\n\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : \"xmlns\";\n\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = Object.assign({}, serializedValue);\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = {\n          [xmlnsKey]: elementType.xmlNamespace\n        };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n\n  return tempArray;\n}\n\nfunction serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n\n  const valueType = mapper.type.value;\n\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}.`);\n  }\n\n  const tempDictionary = {};\n\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options); // If the element needs an XML namespace we need to add it within the $ property\n\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  } // Add the namespace to the root element if needed\n\n\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = {\n      [xmlnsKey]: mapper.xmlNamespace\n    };\n    return result;\n  }\n\n  return tempDictionary;\n}\n/**\n * Resolves the additionalProperties property from a referenced mapper.\n * @param serializer - The serializer containing the entire set of mappers.\n * @param mapper - The composite mapper to resolve.\n * @param objectName - Name of the object being serialized.\n */\n\n\nfunction resolveAdditionalProperties(serializer, mapper, objectName) {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n/**\n * Finds the mapper referenced by `className`.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\n\n\nfunction resolveReferencedMapper(serializer, mapper, objectName) {\n  const className = mapper.type.className;\n\n  if (!className) {\n    throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, undefined, 2)}\".`);\n  }\n\n  return serializer.modelMappers[className];\n}\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\n\n\nfunction resolveModelProperties(serializer, mapper, objectName) {\n  let modelProps = mapper.type.modelProperties;\n\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n\n    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;\n\n    if (!modelProps) {\n      throw new Error(`modelProperties cannot be null or undefined in the ` + `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName;\n      let parentObject = payload;\n\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n\n          if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) {\n            parentObject[pathName] = {};\n          }\n\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), {\n            [xmlnsKey]: mapper.xmlNamespace\n          });\n        }\n\n        const propertyObjectName = propertyMapper.serializedName !== \"\" ? objectName + \".\" + propertyMapper.serializedName : objectName;\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);\n\n        if (serializedValue !== undefined && propName != undefined) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = {\n              [propertyMapper.xmlElementName]: value\n            };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every(pn => pn !== clientPropName);\n\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '[\"' + clientPropName + '\"]', options);\n        }\n      }\n    }\n\n    return payload;\n  }\n\n  return object;\n}\n\nfunction getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : \"xmlns\";\n  const xmlNamespace = {\n    [xmlnsKey]: propertyMapper.xmlNamespace\n  };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result = Object.assign({}, serializedValue);\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n\n  const result = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName, options) {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {\n  var _a, _b;\n\n  const xmlCharKey = (_a = options.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;\n\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance = {};\n  const handledPropertyNames = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName);\n    handledPropertyNames.push(paths[0]);\n    const {\n      serializedName,\n      xmlName,\n      xmlElementName\n    } = propertyMapper;\n    let propertyObjectName = objectName;\n\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;\n\n    if (headerCollectionPrefix) {\n      const dictionary = {};\n\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName];\n          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];\n          instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);\n          handledPropertyNames.push(xmlName);\n        } else {\n          const property = responseBody[propertyName];\n          instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);\n          handledPropertyNames.push(propertyName);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody; // traversing the object step by step.\n\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator; // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n\n      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue; // paging\n\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options); // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = responsePropName => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '[\"' + responsePropName + '\"]', options);\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {\n  const value = mapper.type.value;\n\n  if (!value || typeof value !== \"object\") {\n    throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n\n  if (responseBody) {\n    const tempDictionary = {};\n\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n\n    return tempDictionary;\n  }\n\n  return responseBody;\n}\n\nfunction deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {\n  const element = mapper.type.element;\n\n  if (!element || typeof element !== \"object\") {\n    throw new Error(`element\" metadata for an Array must be defined in the ` + `mapper and it must of type \"object\" in ${objectName}`);\n  }\n\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);\n    }\n\n    return tempArray;\n  }\n\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(serializer, mapper) {\n  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer, typeName) {\n  return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;\n}\n/**\n * Utility function that serializes an object that might contain binary information into a plain object, array or a string.\n */\n\n\nexport function serializeObject(toSerialize) {\n  const castToSerialize = toSerialize;\n  if (toSerialize == undefined) return undefined;\n\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary = {};\n\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n\n    return dictionary;\n  }\n\n  return toSerialize;\n}\n/**\n * Utility function to create a K:V from a list of strings\n */\n\nfunction strEnum(o) {\n  const result = {};\n\n  for (const key of o) {\n    result[key] = key;\n  }\n\n  return result;\n}\n/**\n * String enum containing the string types of property mappers.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\n\n\nexport const MapperType = strEnum([\"Base64Url\", \"Boolean\", \"ByteArray\", \"Composite\", \"Date\", \"DateTime\", \"DateTimeRfc1123\", \"Dictionary\", \"Enum\", \"Number\", \"Object\", \"Sequence\", \"String\", \"Stream\", \"TimeSpan\", \"UnixTime\"]);","map":{"version":3,"sources":["../../src/serializer.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AAEA,OAAO,KAAK,MAAZ,MAAwB,eAAxB;AACA,OAAO,KAAK,KAAZ,MAAuB,cAAvB;AACA,SAA4B,WAA5B,EAAyC,WAAzC,QAA4D,0BAA5D,C,CAEA;;AAEA;;;;AAIG;;AACH,OAAM,MAAO,UAAP,CAAiB;AACrB,EAAA,WAAA,GAQiC;AAAA,QAJf,YAIe,uEAJwB,EAIxB;AAAA;AAH/B;;AAEG;AACa,IAAA,KAAe;AAJf,SAAA,YAAA,GAAA,YAAA;AAIA,SAAA,KAAA,GAAA,KAAA;AACd;AAEJ;;;;;;AAMG;;;AACH,EAAA,mBAAmB,CAAC,MAAD,EAAiB,KAAjB,EAAiC,UAAjC,EAAmD;AACpE,UAAM,cAAc,GAAG,CACrB,cADqB,EAErB,eAFqB,KAGZ;AACT,YAAM,IAAI,KAAJ,CACJ,IAAI,UAAU,iBAAiB,KAAK,oCAAoC,cAAc,MAAM,eAAe,GADvG,CAAN;AAGD,KAPD;;AAQA,QAAI,MAAM,CAAC,WAAP,IAAsB,KAAK,IAAI,SAAnC,EAA8C;AAC5C,YAAM,aAAa,GAAG,KAAtB;AACA,YAAM;AACJ,QAAA,gBADI;AAEJ,QAAA,gBAFI;AAGJ,QAAA,gBAHI;AAIJ,QAAA,gBAJI;AAKJ,QAAA,QALI;AAMJ,QAAA,SANI;AAOJ,QAAA,QAPI;AAQJ,QAAA,SARI;AASJ,QAAA,UATI;AAUJ,QAAA,OAVI;AAWJ,QAAA;AAXI,UAYF,MAAM,CAAC,WAZX;;AAaA,UAAI,gBAAgB,IAAI,SAApB,IAAiC,aAAa,IAAI,gBAAtD,EAAwE;AACtE,QAAA,cAAc,CAAC,kBAAD,EAAqB,gBAArB,CAAd;AACD;;AACD,UAAI,gBAAgB,IAAI,SAApB,IAAiC,aAAa,IAAI,gBAAtD,EAAwE;AACtE,QAAA,cAAc,CAAC,kBAAD,EAAqB,gBAArB,CAAd;AACD;;AACD,UAAI,gBAAgB,IAAI,SAApB,IAAiC,aAAa,GAAG,gBAArD,EAAuE;AACrE,QAAA,cAAc,CAAC,kBAAD,EAAqB,gBAArB,CAAd;AACD;;AACD,UAAI,gBAAgB,IAAI,SAApB,IAAiC,aAAa,GAAG,gBAArD,EAAuE;AACrE,QAAA,cAAc,CAAC,kBAAD,EAAqB,gBAArB,CAAd;AACD;;AACD,YAAM,YAAY,GAAG,KAArB;;AACA,UAAI,QAAQ,IAAI,SAAZ,IAAyB,YAAY,CAAC,MAAb,GAAsB,QAAnD,EAA6D;AAC3D,QAAA,cAAc,CAAC,UAAD,EAAa,QAAb,CAAd;AACD;;AACD,UAAI,SAAS,IAAI,SAAb,IAA0B,YAAY,CAAC,MAAb,GAAsB,SAApD,EAA+D;AAC7D,QAAA,cAAc,CAAC,WAAD,EAAc,SAAd,CAAd;AACD;;AACD,UAAI,QAAQ,IAAI,SAAZ,IAAyB,YAAY,CAAC,MAAb,GAAsB,QAAnD,EAA6D;AAC3D,QAAA,cAAc,CAAC,UAAD,EAAa,QAAb,CAAd;AACD;;AACD,UAAI,SAAS,IAAI,SAAb,IAA0B,YAAY,CAAC,MAAb,GAAsB,SAApD,EAA+D;AAC7D,QAAA,cAAc,CAAC,WAAD,EAAc,SAAd,CAAd;AACD;;AACD,UAAI,UAAU,IAAI,SAAd,IAA2B,aAAa,GAAG,UAAhB,KAA+B,CAA9D,EAAiE;AAC/D,QAAA,cAAc,CAAC,YAAD,EAAe,UAAf,CAAd;AACD;;AACD,UAAI,OAAJ,EAAa;AACX,cAAM,OAAO,GAAW,OAAO,OAAP,KAAmB,QAAnB,GAA8B,IAAI,MAAJ,CAAW,OAAX,CAA9B,GAAoD,OAA5E;;AACA,YAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,KAAK,CAAC,KAAN,CAAY,OAAZ,MAAyB,IAA1D,EAAgE;AAC9D,UAAA,cAAc,CAAC,SAAD,EAAY,OAAZ,CAAd;AACD;AACF;;AACD,UACE,WAAW,IACX,YAAY,CAAC,IAAb,CAAkB,CAAC,IAAD,EAAY,CAAZ,EAAuB,EAAvB,KAA0C,EAAE,CAAC,OAAH,CAAW,IAAX,MAAqB,CAAjF,CAFF,EAGE;AACA,QAAA,cAAc,CAAC,aAAD,EAAgB,WAAhB,CAAd;AACD;AACF;AACF;AAED;;;;;;;;AAQG;;;AACH,EAAA,SAAS,CACP,MADO,EAEP,MAFO,EAGP,UAHO,EAIwB;AAAA,QAA/B,OAA+B,uEAAF,EAAE;;;;AAE/B,UAAM,cAAc,GAAgC;AAClD,MAAA,QAAQ,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,QAAR,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAoB,EADoB;AAElD,MAAA,WAAW,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,WAAR,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,KAFc;AAGlD,MAAA,UAAU,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,UAAR,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB;AAHgB,KAApD;AAKA,QAAI,OAAO,GAAQ,EAAnB;AACA,UAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,IAA/B;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf,MAAA,UAAU,GAAG,MAAM,CAAC,cAApB;AACD;;AACD,QAAI,UAAU,CAAC,KAAX,CAAiB,aAAjB,MAAoC,IAAxC,EAA8C;AAC5C,MAAA,OAAO,GAAG,EAAV;AACD;;AAED,QAAI,MAAM,CAAC,UAAX,EAAuB;AACrB,MAAA,MAAM,GAAG,MAAM,CAAC,YAAhB;AACD,KAlB8B,CAoB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,UAAM;AAAE,MAAA,QAAF;AAAY,MAAA;AAAZ,QAAyB,MAA/B;;AAEA,QAAI,QAAQ,IAAI,QAAZ,IAAwB,MAAM,KAAK,SAAvC,EAAkD;AAChD,YAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,uBAAvB,CAAN;AACD;;AACD,QAAI,QAAQ,IAAI,CAAC,QAAb,IAAyB,MAAM,IAAI,SAAvC,EAAkD;AAChD,YAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,+BAAvB,CAAN;AACD;;AACD,QAAI,CAAC,QAAD,IAAa,QAAQ,KAAK,KAA1B,IAAmC,MAAM,KAAK,IAAlD,EAAwD;AACtD,YAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,kBAAvB,CAAN;AACD;;AAED,QAAI,MAAM,IAAI,SAAd,EAAyB;AACvB,MAAA,OAAO,GAAG,MAAV;AACD,KAFD,MAEO;AACL,UAAI,UAAU,CAAC,KAAX,CAAiB,QAAjB,MAA+B,IAAnC,EAAyC;AACvC,QAAA,OAAO,GAAG,MAAV;AACD,OAFD,MAEO,IAAI,UAAU,CAAC,KAAX,CAAiB,+CAAjB,MAAsE,IAA1E,EAAgF;AACrF,QAAA,OAAO,GAAG,mBAAmB,CAAC,UAAD,EAAa,UAAb,EAAyB,MAAzB,CAA7B;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,SAAjB,MAAgC,IAApC,EAA0C;AAC/C,cAAM,UAAU,GAAe,MAA/B;AACA,QAAA,OAAO,GAAG,iBAAiB,CAAC,UAAD,EAAa,UAAU,CAAC,IAAX,CAAgB,aAA7B,EAA4C,MAA5C,CAA3B;AACD,OAHM,MAGA,IACL,UAAU,CAAC,KAAX,CAAiB,sDAAjB,MAA6E,IADxE,EAEL;AACA,QAAA,OAAO,GAAG,kBAAkB,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAA5B;AACD,OAJM,MAIA,IAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AACpD,QAAA,OAAO,GAAG,sBAAsB,CAAC,UAAD,EAAa,MAAb,CAAhC;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AACpD,QAAA,OAAO,GAAG,sBAAsB,CAAC,UAAD,EAAa,MAAb,CAAhC;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,aAAjB,MAAoC,IAAxC,EAA8C;AACnD,QAAA,OAAO,GAAG,qBAAqB,CAC7B,IAD6B,EAE7B,MAF6B,EAG7B,MAH6B,EAI7B,UAJ6B,EAK7B,OAAO,CAAC,KAAK,KAAN,CALsB,EAM7B,cAN6B,CAA/B;AAQD,OATM,MASA,IAAI,UAAU,CAAC,KAAX,CAAiB,eAAjB,MAAsC,IAA1C,EAAgD;AACrD,QAAA,OAAO,GAAG,uBAAuB,CAC/B,IAD+B,EAE/B,MAF+B,EAG/B,MAH+B,EAI/B,UAJ+B,EAK/B,OAAO,CAAC,KAAK,KAAN,CALwB,EAM/B,cAN+B,CAAjC;AAQD,OATM,MASA,IAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AACpD,QAAA,OAAO,GAAG,sBAAsB,CAC9B,IAD8B,EAE9B,MAF8B,EAG9B,MAH8B,EAI9B,UAJ8B,EAK9B,OAAO,CAAC,KAAK,KAAN,CALuB,EAM9B,cAN8B,CAAhC;AAQD;AACF;;AACD,WAAO,OAAP;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,WAAW,CACT,MADS,EAET,YAFS,EAGT,UAHS,EAIsB;AAAA,QAA/B,OAA+B,uEAAF,EAAE;;;;AAE/B,UAAM,cAAc,GAAgC;AAClD,MAAA,QAAQ,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,QAAR,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAoB,EADoB;AAElD,MAAA,WAAW,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,WAAR,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,KAFc;AAGlD,MAAA,UAAU,EAAE,CAAA,EAAA,GAAA,OAAO,CAAC,UAAR,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB;AAHgB,KAApD;;AAKA,QAAI,YAAY,IAAI,SAApB,EAA+B;AAC7B,UAAI,KAAK,KAAL,IAAc,MAAM,CAAC,IAAP,CAAY,IAAZ,KAAqB,UAAnC,IAAiD,CAAC,MAAM,CAAC,YAA7D,EAA2E;AACzE;AACA;AACA;AACA,QAAA,YAAY,GAAG,EAAf;AACD,OAN4B,CAO7B;;;AACA,UAAI,MAAM,CAAC,YAAP,KAAwB,SAA5B,EAAuC;AACrC,QAAA,YAAY,GAAG,MAAM,CAAC,YAAtB;AACD;;AACD,aAAO,YAAP;AACD;;AAED,QAAI,OAAJ;AACA,UAAM,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,IAA/B;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf,MAAA,UAAU,GAAG,MAAM,CAAC,cAApB;AACD;;AAED,QAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AAC7C,MAAA,OAAO,GAAG,wBAAwB,CAChC,IADgC,EAEhC,MAFgC,EAGhC,YAHgC,EAIhC,UAJgC,EAKhC,cALgC,CAAlC;AAOD,KARD,MAQO;AACL,UAAI,KAAK,KAAT,EAAgB;AACd,cAAM,UAAU,GAAG,cAAc,CAAC,UAAlC;AACA,cAAM,gBAAgB,GAAG,YAAzB;AACA;;;;AAIG;;AACH,YACE,gBAAgB,CAAC,WAAD,CAAhB,IAAiC,SAAjC,IACA,gBAAgB,CAAC,UAAD,CAAhB,IAAgC,SAFlC,EAGE;AACA,UAAA,YAAY,GAAG,gBAAgB,CAAC,UAAD,CAA/B;AACD;AACF;;AAED,UAAI,UAAU,CAAC,KAAX,CAAiB,WAAjB,MAAkC,IAAtC,EAA4C;AAC1C,QAAA,OAAO,GAAG,UAAU,CAAC,YAAD,CAApB;;AACA,YAAI,KAAK,CAAC,OAAD,CAAT,EAAoB;AAClB,UAAA,OAAO,GAAG,YAAV;AACD;AACF,OALD,MAKO,IAAI,UAAU,CAAC,KAAX,CAAiB,YAAjB,MAAmC,IAAvC,EAA6C;AAClD,YAAI,YAAY,KAAK,MAArB,EAA6B;AAC3B,UAAA,OAAO,GAAG,IAAV;AACD,SAFD,MAEO,IAAI,YAAY,KAAK,OAArB,EAA8B;AACnC,UAAA,OAAO,GAAG,KAAV;AACD,SAFM,MAEA;AACL,UAAA,OAAO,GAAG,YAAV;AACD;AACF,OARM,MAQA,IAAI,UAAU,CAAC,KAAX,CAAiB,kDAAjB,MAAyE,IAA7E,EAAmF;AACxF,QAAA,OAAO,GAAG,YAAV;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,oCAAjB,MAA2D,IAA/D,EAAqE;AAC1E,QAAA,OAAO,GAAG,IAAI,IAAJ,CAAS,YAAT,CAAV;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,aAAjB,MAAoC,IAAxC,EAA8C;AACnD,QAAA,OAAO,GAAG,cAAc,CAAC,YAAD,CAAxB;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AACpD,QAAA,OAAO,GAAG,MAAM,CAAC,YAAP,CAAoB,YAApB,CAAV;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,cAAjB,MAAqC,IAAzC,EAA+C;AACpD,QAAA,OAAO,GAAG,oBAAoB,CAAC,YAAD,CAA9B;AACD,OAFM,MAEA,IAAI,UAAU,CAAC,KAAX,CAAiB,aAAjB,MAAoC,IAAxC,EAA8C;AACnD,QAAA,OAAO,GAAG,uBAAuB,CAC/B,IAD+B,EAE/B,MAF+B,EAG/B,YAH+B,EAI/B,UAJ+B,EAK/B,cAL+B,CAAjC;AAOD,OARM,MAQA,IAAI,UAAU,CAAC,KAAX,CAAiB,eAAjB,MAAsC,IAA1C,EAAgD;AACrD,QAAA,OAAO,GAAG,yBAAyB,CACjC,IADiC,EAEjC,MAFiC,EAGjC,YAHiC,EAIjC,UAJiC,EAKjC,cALiC,CAAnC;AAOD;AACF;;AAED,QAAI,MAAM,CAAC,UAAX,EAAuB;AACrB,MAAA,OAAO,GAAG,MAAM,CAAC,YAAjB;AACD;;AAED,WAAO,OAAP;AACD;;AA/SoB;;AAkTvB,SAAS,OAAT,CAAiB,GAAjB,EAA8B,EAA9B,EAAwC;AACtC,MAAI,GAAG,GAAG,GAAG,CAAC,MAAd;;AACA,SAAO,GAAG,GAAG,CAAN,IAAW,CAAX,IAAgB,GAAG,CAAC,GAAG,GAAG,CAAP,CAAH,KAAiB,EAAxC,EAA4C;AAC1C,MAAE,GAAF;AACD;;AACD,SAAO,GAAG,CAAC,MAAJ,CAAW,CAAX,EAAc,GAAd,CAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,MAA3B,EAAsC;AACpC,MAAI,CAAC,MAAL,EAAa;AACX,WAAO,SAAP;AACD;;AACD,MAAI,EAAE,MAAM,YAAY,UAApB,CAAJ,EAAqC;AACnC,UAAM,IAAI,KAAJ,CAAU,yEAAV,CAAN;AACD,GANmC,CAOpC;;;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,eAAP,CAAuB,MAAvB,CAAZ,CARoC,CASpC;;AACA,SAAO,OAAO,CAAC,GAAD,EAAM,GAAN,CAAP,CAAkB,OAAlB,CAA0B,KAA1B,EAAiC,GAAjC,EAAsC,OAAtC,CAA8C,KAA9C,EAAqD,GAArD,CAAP;AACD;;AAED,SAAS,oBAAT,CAA8B,GAA9B,EAAyC;AACvC,MAAI,CAAC,GAAL,EAAU;AACR,WAAO,SAAP;AACD;;AACD,MAAI,GAAG,IAAI,OAAO,GAAG,CAAC,OAAJ,EAAP,KAAyB,QAApC,EAA8C;AAC5C,UAAM,IAAI,KAAJ,CAAU,qEAAV,CAAN;AACD,GANsC,CAOvC;;;AACA,EAAA,GAAG,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,GAAlB,EAAuB,OAAvB,CAA+B,IAA/B,EAAqC,GAArC,CAAN,CARuC,CASvC;;AACA,SAAO,MAAM,CAAC,YAAP,CAAoB,GAApB,CAAP;AACD;;AAED,SAAS,kBAAT,CAA4B,IAA5B,EAAoD;AAClD,QAAM,OAAO,GAAa,EAA1B;AACA,MAAI,YAAY,GAAG,EAAnB;;AACA,MAAI,IAAJ,EAAU;AACR,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,GAAX,CAAjB;;AAEA,SAAK,MAAM,IAAX,IAAmB,QAAnB,EAA6B;AAC3B,UAAI,IAAI,CAAC,MAAL,CAAY,IAAI,CAAC,MAAL,GAAc,CAA1B,MAAiC,IAArC,EAA2C;AACzC,QAAA,YAAY,IAAI,IAAI,CAAC,MAAL,CAAY,CAAZ,EAAe,IAAI,CAAC,MAAL,GAAc,CAA7B,IAAkC,GAAlD;AACD,OAFD,MAEO;AACL,QAAA,YAAY,IAAI,IAAhB;AACA,QAAA,OAAO,CAAC,IAAR,CAAa,YAAb;AACA,QAAA,YAAY,GAAG,EAAf;AACD;AACF;AACF;;AAED,SAAO,OAAP;AACD;;AAED,SAAS,cAAT,CAAwB,CAAxB,EAAwC;AACtC,MAAI,CAAC,CAAL,EAAQ;AACN,WAAO,SAAP;AACD;;AAED,MAAI,OAAO,CAAC,CAAC,OAAF,EAAP,KAAuB,QAA3B,EAAqC;AACnC,IAAA,CAAC,GAAG,IAAI,IAAJ,CAAS,CAAT,CAAJ;AACD;;AACD,SAAO,IAAI,CAAC,KAAL,CAAY,CAAU,CAAC,OAAX,KAAuB,IAAnC,CAAP;AACD;;AAED,SAAS,cAAT,CAAwB,CAAxB,EAAiC;AAC/B,MAAI,CAAC,CAAL,EAAQ;AACN,WAAO,SAAP;AACD;;AACD,SAAO,IAAI,IAAJ,CAAS,CAAC,GAAG,IAAb,CAAP;AACD;;AAED,SAAS,mBAAT,CAA6B,QAA7B,EAA+C,UAA/C,EAAmE,KAAnE,EAA6E;AAC3E,MAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,SAAhC,EAA2C;AACzC,QAAI,QAAQ,CAAC,KAAT,CAAe,WAAf,MAAgC,IAApC,EAA0C;AACxC,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,eAAe,KAAK,0BAA3C,CAAN;AACD;AACF,KAJD,MAIO,IAAI,QAAQ,CAAC,KAAT,CAAe,WAAf,MAAgC,IAApC,EAA0C;AAC/C,UAAI,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA/B,EAAyC;AACvC,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,gBAAgB,KAAK,2BAA5C,CAAN;AACD;AACF,KAJM,MAIA,IAAI,QAAQ,CAAC,KAAT,CAAe,SAAf,MAA8B,IAAlC,EAAwC;AAC7C,UAAI,EAAE,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA3B,IAAuC,KAAK,CAAC,WAAN,CAAkB,KAAlB,CAAzC,CAAJ,EAAwE;AACtE,cAAM,IAAI,KAAJ,CACJ,GAAG,UAAU,gBAAgB,KAAK,4CAD9B,CAAN;AAGD;AACF,KANM,MAMA,IAAI,QAAQ,CAAC,KAAT,CAAe,YAAf,MAAiC,IAArC,EAA2C;AAChD,UAAI,OAAO,KAAP,KAAiB,SAArB,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,eAAe,KAAK,2BAA3C,CAAN;AACD;AACF,KAJM,MAIA,IAAI,QAAQ,CAAC,KAAT,CAAe,WAAf,MAAgC,IAApC,EAA0C;AAC/C,YAAM,UAAU,GAAG,OAAO,KAA1B;;AACA,UACE,UAAU,KAAK,QAAf,IACA,UAAU,KAAK,UADf,IAEA,EAAE,KAAK,YAAY,WAAnB,CAFA,IAGA,CAAC,WAAW,CAAC,MAAZ,CAAmB,KAAnB,CAHD,IAIA,EAAE,CAAC,OAAO,IAAP,KAAgB,UAAhB,IAA8B,OAAO,IAAP,KAAgB,QAA/C,KAA4D,KAAK,YAAY,IAA/E,CALF,EAME;AACA,cAAM,IAAI,KAAJ,CACJ,GAAG,UAAU,uGADT,CAAN;AAGD;AACF;AACF;;AAED,SAAO,KAAP;AACD;;AAED,SAAS,iBAAT,CAA2B,UAA3B,EAA+C,aAA/C,EAA0E,KAA1E,EAAoF;AAClF,MAAI,CAAC,aAAL,EAAoB;AAClB,UAAM,IAAI,KAAJ,CACJ,qDAAqD,UAAU,mBAD3D,CAAN;AAGD;;AACD,QAAM,SAAS,GAAG,aAAa,CAAC,IAAd,CAAoB,IAAD,IAAS;AAC5C,QAAI,OAAO,IAAI,CAAC,OAAL,EAAP,KAA0B,QAA9B,EAAwC;AACtC,aAAO,IAAI,CAAC,WAAL,OAAuB,KAAK,CAAC,WAAN,EAA9B;AACD;;AACD,WAAO,IAAI,KAAK,KAAhB;AACD,GALiB,CAAlB;;AAMA,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,IAAI,KAAJ,CACJ,GAAG,KAAK,6BAA6B,UAAU,2BAA2B,IAAI,CAAC,SAAL,CACxE,aADwE,CAEzE,GAHG,CAAN;AAKD;;AACD,SAAO,KAAP;AACD;;AAED,SAAS,sBAAT,CAAgC,UAAhC,EAAoD,KAApD,EAAqE;AACnE,MAAI,WAAW,GAAW,EAA1B;;AACA,MAAI,KAAK,IAAI,SAAb,EAAwB;AACtB,QAAI,EAAE,KAAK,YAAY,UAAnB,CAAJ,EAAoC;AAClC,YAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,8BAAvB,CAAN;AACD;;AACD,IAAA,WAAW,GAAG,MAAM,CAAC,eAAP,CAAuB,KAAvB,CAAd;AACD;;AACD,SAAO,WAAP;AACD;;AAED,SAAS,sBAAT,CAAgC,UAAhC,EAAoD,KAApD,EAAqE;AACnE,MAAI,WAAW,GAAW,EAA1B;;AACA,MAAI,KAAK,IAAI,SAAb,EAAwB;AACtB,QAAI,EAAE,KAAK,YAAY,UAAnB,CAAJ,EAAoC;AAClC,YAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,8BAAvB,CAAN;AACD;;AACD,IAAA,WAAW,GAAG,iBAAiB,CAAC,KAAD,CAAjB,IAA4B,EAA1C;AACD;;AACD,SAAO,WAAP;AACD;;AAED,SAAS,kBAAT,CAA4B,QAA5B,EAA8C,KAA9C,EAA0D,UAA1D,EAA4E;AAC1E,MAAI,KAAK,IAAI,SAAb,EAAwB;AACtB,QAAI,QAAQ,CAAC,KAAT,CAAe,SAAf,MAA8B,IAAlC,EAAwC;AACtC,UACE,EACE,KAAK,YAAY,IAAjB,IACC,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA3B,IAAuC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAL,CAAW,KAAX,CAAD,CAFhD,CADF,EAKE;AACA,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,4DAAvB,CAAN;AACD;;AACD,MAAA,KAAK,GACH,KAAK,YAAY,IAAjB,GACI,KAAK,CAAC,WAAN,GAAoB,SAApB,CAA8B,CAA9B,EAAiC,EAAjC,CADJ,GAEI,IAAI,IAAJ,CAAS,KAAT,EAAgB,WAAhB,GAA8B,SAA9B,CAAwC,CAAxC,EAA2C,EAA3C,CAHN;AAID,KAbD,MAaO,IAAI,QAAQ,CAAC,KAAT,CAAe,aAAf,MAAkC,IAAtC,EAA4C;AACjD,UACE,EACE,KAAK,YAAY,IAAjB,IACC,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA3B,IAAuC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAL,CAAW,KAAX,CAAD,CAFhD,CADF,EAKE;AACA,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,4DAAvB,CAAN;AACD;;AACD,MAAA,KAAK,GAAG,KAAK,YAAY,IAAjB,GAAwB,KAAK,CAAC,WAAN,EAAxB,GAA8C,IAAI,IAAJ,CAAS,KAAT,EAAgB,WAAhB,EAAtD;AACD,KAVM,MAUA,IAAI,QAAQ,CAAC,KAAT,CAAe,oBAAf,MAAyC,IAA7C,EAAmD;AACxD,UACE,EACE,KAAK,YAAY,IAAjB,IACC,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA3B,IAAuC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAL,CAAW,KAAX,CAAD,CAFhD,CADF,EAKE;AACA,cAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,6DAAvB,CAAN;AACD;;AACD,MAAA,KAAK,GAAG,KAAK,YAAY,IAAjB,GAAwB,KAAK,CAAC,WAAN,EAAxB,GAA8C,IAAI,IAAJ,CAAS,KAAT,EAAgB,WAAhB,EAAtD;AACD,KAVM,MAUA,IAAI,QAAQ,CAAC,KAAT,CAAe,aAAf,MAAkC,IAAtC,EAA4C;AACjD,UACE,EACE,KAAK,YAAY,IAAjB,IACC,OAAO,KAAK,CAAC,OAAN,EAAP,KAA2B,QAA3B,IAAuC,CAAC,KAAK,CAAC,IAAI,CAAC,KAAL,CAAW,KAAX,CAAD,CAFhD,CADF,EAKE;AACA,cAAM,IAAI,KAAJ,CACJ,GAAG,UAAU,qEAAb,GACE,mDAFE,CAAN;AAID;;AACD,MAAA,KAAK,GAAG,cAAc,CAAC,KAAD,CAAtB;AACD,KAbM,MAaA,IAAI,QAAQ,CAAC,KAAT,CAAe,aAAf,MAAkC,IAAtC,EAA4C;AACjD,UAAI,CAAC,KAAK,CAAC,UAAN,CAAiB,KAAjB,CAAL,EAA8B;AAC5B,cAAM,IAAI,KAAJ,CACJ,GAAG,UAAU,sDAAsD,KAAK,IADpE,CAAN;AAGD;AACF;AACF;;AACD,SAAO,KAAP;AACD;;AAED,SAAS,qBAAT,CACE,UADF,EAEE,MAFF,EAGE,MAHF,EAIE,UAJF,EAKE,KALF,EAME,OANF,EAMsC;AAEpC,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B;AAC1B,UAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,yBAAvB,CAAN;AACD;;AACD,QAAM,WAAW,GAAG,MAAM,CAAC,IAAP,CAAY,OAAhC;;AACA,MAAI,CAAC,WAAD,IAAgB,OAAO,WAAP,KAAuB,QAA3C,EAAqD;AACnD,UAAM,IAAI,KAAJ,CACJ,wDAAA,GACE,0CAA0C,UAAU,GAFlD,CAAN;AAID;;AACD,QAAM,SAAS,GAAG,EAAlB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,UAAM,eAAe,GAAG,UAAU,CAAC,SAAX,CAAqB,WAArB,EAAkC,MAAM,CAAC,CAAD,CAAxC,EAA6C,UAA7C,EAAyD,OAAzD,CAAxB;;AAEA,QAAI,KAAK,IAAI,WAAW,CAAC,YAAzB,EAAuC;AACrC,YAAM,QAAQ,GAAG,WAAW,CAAC,kBAAZ,GACb,SAAS,WAAW,CAAC,kBAAkB,EAD1B,GAEb,OAFJ;;AAGA,UAAI,WAAW,CAAC,IAAZ,CAAiB,IAAjB,KAA0B,WAA9B,EAA2C;AACzC,QAAA,SAAS,CAAC,CAAD,CAAT,GAAY,MAAA,CAAA,MAAA,CAAA,EAAA,EAAQ,eAAR,CAAZ;AACA,QAAA,SAAS,CAAC,CAAD,CAAT,CAAa,WAAb,IAA4B;AAAE,WAAC,QAAD,GAAY,WAAW,CAAC;AAA1B,SAA5B;AACD,OAHD,MAGO;AACL,QAAA,SAAS,CAAC,CAAD,CAAT,GAAe,EAAf;AACA,QAAA,SAAS,CAAC,CAAD,CAAT,CAAa,OAAO,CAAC,UAArB,IAAmC,eAAnC;AACA,QAAA,SAAS,CAAC,CAAD,CAAT,CAAa,WAAb,IAA4B;AAAE,WAAC,QAAD,GAAY,WAAW,CAAC;AAA1B,SAA5B;AACD;AACF,KAZD,MAYO;AACL,MAAA,SAAS,CAAC,CAAD,CAAT,GAAe,eAAf;AACD;AACF;;AACD,SAAO,SAAP;AACD;;AAED,SAAS,uBAAT,CACE,UADF,EAEE,MAFF,EAGE,MAHF,EAIE,UAJF,EAKE,KALF,EAME,OANF,EAMsC;AAEpC,MAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAI,KAAJ,CAAU,GAAG,UAAU,0BAAvB,CAAN;AACD;;AACD,QAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,KAA9B;;AACA,MAAI,CAAC,SAAD,IAAc,OAAO,SAAP,KAAqB,QAAvC,EAAiD;AAC/C,UAAM,IAAI,KAAJ,CACJ,2DAAA,GACE,0CAA0C,UAAU,GAFlD,CAAN;AAID;;AACD,QAAM,cAAc,GAA2B,EAA/C;;AACA,OAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAlB,EAAuC;AACrC,UAAM,eAAe,GAAG,UAAU,CAAC,SAAX,CAAqB,SAArB,EAAgC,MAAM,CAAC,GAAD,CAAtC,EAA6C,UAA7C,EAAyD,OAAzD,CAAxB,CADqC,CAErC;;AACA,IAAA,cAAc,CAAC,GAAD,CAAd,GAAsB,iBAAiB,CAAC,SAAD,EAAY,eAAZ,EAA6B,KAA7B,EAAoC,OAApC,CAAvC;AACD,GAjBmC,CAmBpC;;;AACA,MAAI,KAAK,IAAI,MAAM,CAAC,YAApB,EAAkC;AAChC,UAAM,QAAQ,GAAG,MAAM,CAAC,kBAAP,GAA4B,SAAS,MAAM,CAAC,kBAAkB,EAA9D,GAAmE,OAApF;AAEA,UAAM,MAAM,GAAG,cAAf;AACA,IAAA,MAAM,CAAC,WAAD,CAAN,GAAsB;AAAE,OAAC,QAAD,GAAY,MAAM,CAAC;AAArB,KAAtB;AACA,WAAO,MAAP;AACD;;AAED,SAAO,cAAP;AACD;AAED;;;;;AAKG;;;AACH,SAAS,2BAAT,CACE,UADF,EAEE,MAFF,EAGE,UAHF,EAGoB;AAElB,QAAM,oBAAoB,GAAG,MAAM,CAAC,IAAP,CAAY,oBAAzC;;AAEA,MAAI,CAAC,oBAAD,IAAyB,MAAM,CAAC,IAAP,CAAY,SAAzC,EAAoD;AAClD,UAAM,WAAW,GAAG,uBAAuB,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAA3C;AACA,WAAO,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,IAAb,CAAkB,oBAAzB;AACD;;AAED,SAAO,oBAAP;AACD;AAED;;;;;AAKG;;;AACH,SAAS,uBAAT,CACE,UADF,EAEE,MAFF,EAGE,UAHF,EAGoB;AAElB,QAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,SAA9B;;AACA,MAAI,CAAC,SAAL,EAAgB;AACd,UAAM,IAAI,KAAJ,CACJ,yBAAyB,UAAU,oCAAoC,IAAI,CAAC,SAAL,CACrE,MADqE,EAErE,SAFqE,EAGrE,CAHqE,CAItE,IALG,CAAN;AAOD;;AAED,SAAO,UAAU,CAAC,YAAX,CAAwB,SAAxB,CAAP;AACD;AAED;;;;AAIG;;;AACH,SAAS,sBAAT,CACE,UADF,EAEE,MAFF,EAGE,UAHF,EAGoB;AAElB,MAAI,UAAU,GAAG,MAAM,CAAC,IAAP,CAAY,eAA7B;;AACA,MAAI,CAAC,UAAL,EAAiB;AACf,UAAM,WAAW,GAAG,uBAAuB,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAA3C;;AACA,QAAI,CAAC,WAAL,EAAkB;AAChB,YAAM,IAAI,KAAJ,CAAU,mDAAmD,MAAM,CAAC,IAAP,CAAY,SAAS,IAAlF,CAAN;AACD;;AACD,IAAA,UAAU,GAAG,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,IAAb,CAAkB,eAA/B;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf,YAAM,IAAI,KAAJ,CACJ,qDAAA,GACE,WAAW,IAAI,CAAC,SAAL,CAAe,WAAf,CAA2B,cACpC,MAAM,CAAC,IAAP,CAAY,SACd,iBAAiB,UAAU,IAJzB,CAAN;AAMD;AACF;;AAED,SAAO,UAAP;AACD;;AAED,SAAS,sBAAT,CACE,UADF,EAEE,MAFF,EAGE,MAHF,EAIE,UAJF,EAKE,KALF,EAME,OANF,EAMsC;AAEpC,MAAI,sCAAsC,CAAC,UAAD,EAAa,MAAb,CAA1C,EAAgE;AAC9D,IAAA,MAAM,GAAG,oBAAoB,CAAC,UAAD,EAAa,MAAb,EAAqB,MAArB,EAA6B,YAA7B,CAA7B;AACD;;AAED,MAAI,MAAM,IAAI,SAAd,EAAyB;AACvB,UAAM,OAAO,GAAQ,EAArB;AACA,UAAM,UAAU,GAAG,sBAAsB,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAAzC;;AACA,SAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,UAAZ,CAAlB,EAA2C;AACzC,YAAM,cAAc,GAAG,UAAU,CAAC,GAAD,CAAjC;;AACA,UAAI,cAAc,CAAC,QAAnB,EAA6B;AAC3B;AACD;;AAED,UAAI,QAAJ;AACA,UAAI,YAAY,GAAQ,OAAxB;;AACA,UAAI,UAAU,CAAC,KAAf,EAAsB;AACpB,YAAI,cAAc,CAAC,YAAnB,EAAiC;AAC/B,UAAA,QAAQ,GAAG,cAAc,CAAC,OAA1B;AACD,SAFD,MAEO;AACL,UAAA,QAAQ,GAAG,cAAc,CAAC,cAAf,IAAiC,cAAc,CAAC,OAA3D;AACD;AACF,OAND,MAMO;AACL,cAAM,KAAK,GAAG,kBAAkB,CAAC,cAAc,CAAC,cAAhB,CAAhC;AACA,QAAA,QAAQ,GAAG,KAAK,CAAC,GAAN,EAAX;;AAEA,aAAK,MAAM,QAAX,IAAuB,KAAvB,EAA8B;AAC5B,gBAAM,WAAW,GAAG,YAAY,CAAC,QAAD,CAAhC;;AACA,cACE,WAAW,IAAI,SAAf,KACC,MAAM,CAAC,GAAD,CAAN,IAAe,SAAf,IAA4B,cAAc,CAAC,YAAf,KAAgC,SAD7D,CADF,EAGE;AACA,YAAA,YAAY,CAAC,QAAD,CAAZ,GAAyB,EAAzB;AACD;;AACD,UAAA,YAAY,GAAG,YAAY,CAAC,QAAD,CAA3B;AACD;AACF;;AAED,UAAI,YAAY,IAAI,SAApB,EAA+B;AAC7B,YAAI,KAAK,IAAI,MAAM,CAAC,YAApB,EAAkC;AAChC,gBAAM,QAAQ,GAAG,MAAM,CAAC,kBAAP,GACb,SAAS,MAAM,CAAC,kBAAkB,EADrB,GAEb,OAFJ;AAGA,UAAA,YAAY,CAAC,WAAD,CAAZ,GAAyB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACpB,YAAY,CAAC,WAAD,CADQ,CAAA,EACK;AAC5B,aAAC,QAAD,GAAY,MAAM,CAAC;AADS,WADL,CAAzB;AAID;;AACD,cAAM,kBAAkB,GACtB,cAAc,CAAC,cAAf,KAAkC,EAAlC,GACI,UAAU,GAAG,GAAb,GAAmB,cAAc,CAAC,cADtC,GAEI,UAHN;AAKA,YAAI,WAAW,GAAG,MAAM,CAAC,GAAD,CAAxB;AACA,cAAM,wBAAwB,GAAG,sCAAsC,CAAC,UAAD,EAAa,MAAb,CAAvE;;AACA,YACE,wBAAwB,IACxB,wBAAwB,CAAC,UAAzB,KAAwC,GADxC,IAEA,WAAW,IAAI,SAHjB,EAIE;AACA,UAAA,WAAW,GAAG,MAAM,CAAC,cAArB;AACD;;AAED,cAAM,eAAe,GAAG,UAAU,CAAC,SAAX,CACtB,cADsB,EAEtB,WAFsB,EAGtB,kBAHsB,EAItB,OAJsB,CAAxB;;AAOA,YAAI,eAAe,KAAK,SAApB,IAAiC,QAAQ,IAAI,SAAjD,EAA4D;AAC1D,gBAAM,KAAK,GAAG,iBAAiB,CAAC,cAAD,EAAiB,eAAjB,EAAkC,KAAlC,EAAyC,OAAzC,CAA/B;;AACA,cAAI,KAAK,IAAI,cAAc,CAAC,cAA5B,EAA4C;AAC1C;AACA;AACA;AACA,YAAA,YAAY,CAAC,WAAD,CAAZ,GAA4B,YAAY,CAAC,WAAD,CAAZ,IAA6B,EAAzD;AACA,YAAA,YAAY,CAAC,WAAD,CAAZ,CAA0B,QAA1B,IAAsC,eAAtC;AACD,WAND,MAMO,IAAI,KAAK,IAAI,cAAc,CAAC,YAA5B,EAA0C;AAC/C,YAAA,YAAY,CAAC,QAAD,CAAZ,GAAyB;AAAE,eAAC,cAAc,CAAC,cAAhB,GAAkC;AAApC,aAAzB;AACD,WAFM,MAEA;AACL,YAAA,YAAY,CAAC,QAAD,CAAZ,GAAyB,KAAzB;AACD;AACF;AACF;AACF;;AAED,UAAM,0BAA0B,GAAG,2BAA2B,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAA9D;;AACA,QAAI,0BAAJ,EAAgC;AAC9B,YAAM,SAAS,GAAG,MAAM,CAAC,IAAP,CAAY,UAAZ,CAAlB;;AACA,WAAK,MAAM,cAAX,IAA6B,MAA7B,EAAqC;AACnC,cAAM,oBAAoB,GAAG,SAAS,CAAC,KAAV,CAAiB,EAAD,IAAQ,EAAE,KAAK,cAA/B,CAA7B;;AACA,YAAI,oBAAJ,EAA0B;AACxB,UAAA,OAAO,CAAC,cAAD,CAAP,GAA0B,UAAU,CAAC,SAAX,CACxB,0BADwB,EAExB,MAAM,CAAC,cAAD,CAFkB,EAGxB,UAAU,GAAG,IAAb,GAAoB,cAApB,GAAqC,IAHb,EAIxB,OAJwB,CAA1B;AAMD;AACF;AACF;;AAED,WAAO,OAAP;AACD;;AACD,SAAO,MAAP;AACD;;AAED,SAAS,iBAAT,CACE,cADF,EAEE,eAFF,EAGE,KAHF,EAIE,OAJF,EAIsC;AAEpC,MAAI,CAAC,KAAD,IAAU,CAAC,cAAc,CAAC,YAA9B,EAA4C;AAC1C,WAAO,eAAP;AACD;;AAED,QAAM,QAAQ,GAAG,cAAc,CAAC,kBAAf,GACb,SAAS,cAAc,CAAC,kBAAkB,EAD7B,GAEb,OAFJ;AAGA,QAAM,YAAY,GAAG;AAAE,KAAC,QAAD,GAAY,cAAc,CAAC;AAA7B,GAArB;;AAEA,MAAI,CAAC,WAAD,EAAc,QAAd,CAAuB,cAAc,CAAC,IAAf,CAAoB,IAA3C,CAAJ,EAAsD;AACpD,QAAI,eAAe,CAAC,WAAD,CAAnB,EAAkC;AAChC,aAAO,eAAP;AACD,KAFD,MAEO;AACL,YAAM,MAAM,GAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAa,eAAb,CAAZ;AACA,MAAA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAtB;AACA,aAAO,MAAP;AACD;AACF;;AACD,QAAM,MAAM,GAAQ,EAApB;AACA,EAAA,MAAM,CAAC,OAAO,CAAC,UAAT,CAAN,GAA6B,eAA7B;AACA,EAAA,MAAM,CAAC,WAAD,CAAN,GAAsB,YAAtB;AACA,SAAO,MAAP;AACD;;AAED,SAAS,oBAAT,CAA8B,YAA9B,EAAoD,OAApD,EAAwF;AACtF,SAAO,CAAC,WAAD,EAAc,OAAO,CAAC,UAAtB,EAAkC,QAAlC,CAA2C,YAA3C,CAAP;AACD;;AAED,SAAS,wBAAT,CACE,UADF,EAEE,MAFF,EAGE,YAHF,EAIE,UAJF,EAKE,OALF,EAKsC;;;AAEpC,QAAM,UAAU,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,UAAR,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB,WAAzC;;AACA,MAAI,sCAAsC,CAAC,UAAD,EAAa,MAAb,CAA1C,EAAgE;AAC9D,IAAA,MAAM,GAAG,oBAAoB,CAAC,UAAD,EAAa,MAAb,EAAqB,YAArB,EAAmC,gBAAnC,CAA7B;AACD;;AAED,QAAM,UAAU,GAAG,sBAAsB,CAAC,UAAD,EAAa,MAAb,EAAqB,UAArB,CAAzC;AACA,MAAI,QAAQ,GAA2B,EAAvC;AACA,QAAM,oBAAoB,GAAa,EAAvC;;AAEA,OAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,UAAZ,CAAlB,EAA2C;AACzC,UAAM,cAAc,GAAG,UAAU,CAAC,GAAD,CAAjC;AACA,UAAM,KAAK,GAAG,kBAAkB,CAAC,UAAU,CAAC,GAAD,CAAV,CAAgB,cAAjB,CAAhC;AACA,IAAA,oBAAoB,CAAC,IAArB,CAA0B,KAAK,CAAC,CAAD,CAA/B;AACA,UAAM;AAAE,MAAA,cAAF;AAAkB,MAAA,OAAlB;AAA2B,MAAA;AAA3B,QAA8C,cAApD;AACA,QAAI,kBAAkB,GAAG,UAAzB;;AACA,QAAI,cAAc,KAAK,EAAnB,IAAyB,cAAc,KAAK,SAAhD,EAA2D;AACzD,MAAA,kBAAkB,GAAG,UAAU,GAAG,GAAb,GAAmB,cAAxC;AACD;;AAED,UAAM,sBAAsB,GAAI,cAAmC,CAAC,sBAApE;;AACA,QAAI,sBAAJ,EAA4B;AAC1B,YAAM,UAAU,GAAQ,EAAxB;;AACA,WAAK,MAAM,SAAX,IAAwB,MAAM,CAAC,IAAP,CAAY,YAAZ,CAAxB,EAAmD;AACjD,YAAI,SAAS,CAAC,UAAV,CAAqB,sBAArB,CAAJ,EAAkD;AAChD,UAAA,UAAU,CAAC,SAAS,CAAC,SAAV,CAAoB,sBAAsB,CAAC,MAA3C,CAAD,CAAV,GAAiE,UAAU,CAAC,WAAX,CAC9D,cAAmC,CAAC,IAApC,CAAyC,KADqB,EAE/D,YAAY,CAAC,SAAD,CAFmD,EAG/D,kBAH+D,EAI/D,OAJ+D,CAAjE;AAMD;;AAED,QAAA,oBAAoB,CAAC,IAArB,CAA0B,SAA1B;AACD;;AACD,MAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,UAAhB;AACD,KAfD,MAeO,IAAI,UAAU,CAAC,KAAf,EAAsB;AAC3B,UAAI,cAAc,CAAC,cAAf,IAAiC,YAAY,CAAC,WAAD,CAAjD,EAAgE;AAC9D,QAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,UAAU,CAAC,WAAX,CACd,cADc,EAEd,YAAY,CAAC,WAAD,CAAZ,CAA0B,OAA1B,CAFc,EAGd,kBAHc,EAId,OAJc,CAAhB;AAMD,OAPD,MAOO,IAAI,cAAc,CAAC,WAAnB,EAAgC;AACrC,YAAI,YAAY,CAAC,UAAD,CAAZ,KAA6B,SAAjC,EAA4C;AAC1C,UAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,YAAY,CAAC,UAAD,CAA5B;AACD,SAFD,MAEO,IAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AAC3C;AACA;AACA,UAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,YAAhB;AACD;AACF,OARM,MAQA;AACL,cAAM,YAAY,GAAG,cAAc,IAAI,OAAlB,IAA6B,cAAlD;;AACA,YAAI,cAAc,CAAC,YAAnB,EAAiC;AAC/B;;;;;;;;;;;;;AAaE;AACF,gBAAM,OAAO,GAAG,YAAY,CAAC,OAAD,CAA5B;AACA,gBAAM,WAAW,GAAG,CAAA,EAAA,GAAA,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAG,cAAH,CAAP,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,EAAlD;AACA,UAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,UAAU,CAAC,WAAX,CACd,cADc,EAEd,WAFc,EAGd,kBAHc,EAId,OAJc,CAAhB;AAMA,UAAA,oBAAoB,CAAC,IAArB,CAA0B,OAA1B;AACD,SAxBD,MAwBO;AACL,gBAAM,QAAQ,GAAG,YAAY,CAAC,YAAD,CAA7B;AACA,UAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,UAAU,CAAC,WAAX,CACd,cADc,EAEd,QAFc,EAGd,kBAHc,EAId,OAJc,CAAhB;AAMA,UAAA,oBAAoB,CAAC,IAArB,CAA0B,YAA1B;AACD;AACF;AACF,KArDM,MAqDA;AACL;AACA,UAAI,gBAAJ;AACA,UAAI,GAAG,GAAG,YAAV,CAHK,CAIL;;AACA,WAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;AACxB,YAAI,CAAC,GAAL,EAAU;AACV,QAAA,GAAG,GAAG,GAAG,CAAC,IAAD,CAAT;AACD;;AACD,MAAA,gBAAgB,GAAG,GAAnB;AACA,YAAM,wBAAwB,GAAG,MAAM,CAAC,IAAP,CAAY,wBAA7C,CAVK,CAWL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UACE,wBAAwB,IACxB,GAAG,KAAK,wBAAwB,CAAC,UADjC,IAEA,gBAAgB,IAAI,SAHtB,EAIE;AACA,QAAA,gBAAgB,GAAG,MAAM,CAAC,cAA1B;AACD;;AAED,UAAI,eAAJ,CA5BK,CA6BL;;AACA,UAAI,KAAK,CAAC,OAAN,CAAc,YAAY,CAAC,GAAD,CAA1B,KAAoC,UAAU,CAAC,GAAD,CAAV,CAAgB,cAAhB,KAAmC,EAA3E,EAA+E;AAC7E,QAAA,gBAAgB,GAAG,YAAY,CAAC,GAAD,CAA/B;AACA,cAAM,aAAa,GAAG,UAAU,CAAC,WAAX,CACpB,cADoB,EAEpB,gBAFoB,EAGpB,kBAHoB,EAIpB,OAJoB,CAAtB,CAF6E,CAQ7E;AACA;;AACA,aAAK,MAAM,CAAC,CAAD,EAAI,CAAJ,CAAX,IAAqB,MAAM,CAAC,OAAP,CAAe,QAAf,CAArB,EAA+C;AAC7C,cAAI,CAAC,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,aAArC,EAAoD,CAApD,CAAL,EAA6D;AAC3D,YAAA,aAAa,CAAC,CAAD,CAAb,GAAmB,CAAnB;AACD;AACF;;AACD,QAAA,QAAQ,GAAG,aAAX;AACD,OAhBD,MAgBO,IAAI,gBAAgB,KAAK,SAArB,IAAkC,cAAc,CAAC,YAAf,KAAgC,SAAtE,EAAiF;AACtF,QAAA,eAAe,GAAG,UAAU,CAAC,WAAX,CAChB,cADgB,EAEhB,gBAFgB,EAGhB,kBAHgB,EAIhB,OAJgB,CAAlB;AAMA,QAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,eAAhB;AACD;AACF;AACF;;AAED,QAAM,0BAA0B,GAAG,MAAM,CAAC,IAAP,CAAY,oBAA/C;;AACA,MAAI,0BAAJ,EAAgC;AAC9B,UAAM,oBAAoB,GAAI,gBAAD,IAAsC;AACjE,WAAK,MAAM,cAAX,IAA6B,UAA7B,EAAyC;AACvC,cAAM,KAAK,GAAG,kBAAkB,CAAC,UAAU,CAAC,cAAD,CAAV,CAA2B,cAA5B,CAAhC;;AACA,YAAI,KAAK,CAAC,CAAD,CAAL,KAAa,gBAAjB,EAAmC;AACjC,iBAAO,KAAP;AACD;AACF;;AACD,aAAO,IAAP;AACD,KARD;;AAUA,SAAK,MAAM,gBAAX,IAA+B,YAA/B,EAA6C;AAC3C,UAAI,oBAAoB,CAAC,gBAAD,CAAxB,EAA4C;AAC1C,QAAA,QAAQ,CAAC,gBAAD,CAAR,GAA6B,UAAU,CAAC,WAAX,CAC3B,0BAD2B,EAE3B,YAAY,CAAC,gBAAD,CAFe,EAG3B,UAAU,GAAG,IAAb,GAAoB,gBAApB,GAAuC,IAHZ,EAI3B,OAJ2B,CAA7B;AAMD;AACF;AACF,GArBD,MAqBO,IAAI,YAAJ,EAAkB;AACvB,SAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,YAAZ,CAAlB,EAA6C;AAC3C,UACE,QAAQ,CAAC,GAAD,CAAR,KAAkB,SAAlB,IACA,CAAC,oBAAoB,CAAC,QAArB,CAA8B,GAA9B,CADD,IAEA,CAAC,oBAAoB,CAAC,GAAD,EAAM,OAAN,CAHvB,EAIE;AACA,QAAA,QAAQ,CAAC,GAAD,CAAR,GAAgB,YAAY,CAAC,GAAD,CAA5B;AACD;AACF;AACF;;AAED,SAAO,QAAP;AACD;;AAED,SAAS,yBAAT,CACE,UADF,EAEE,MAFF,EAGE,YAHF,EAIE,UAJF,EAKE,OALF,EAKsC;AAEpC,QAAM,KAAK,GAAG,MAAM,CAAC,IAAP,CAAY,KAA1B;;AACA,MAAI,CAAC,KAAD,IAAU,OAAO,KAAP,KAAiB,QAA/B,EAAyC;AACvC,UAAM,IAAI,KAAJ,CACJ,2DAAA,GACE,0CAA0C,UAAU,EAFlD,CAAN;AAID;;AACD,MAAI,YAAJ,EAAkB;AAChB,UAAM,cAAc,GAA2B,EAA/C;;AACA,SAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,IAAP,CAAY,YAAZ,CAAlB,EAA6C;AAC3C,MAAA,cAAc,CAAC,GAAD,CAAd,GAAsB,UAAU,CAAC,WAAX,CAAuB,KAAvB,EAA8B,YAAY,CAAC,GAAD,CAA1C,EAAiD,UAAjD,EAA6D,OAA7D,CAAtB;AACD;;AACD,WAAO,cAAP;AACD;;AACD,SAAO,YAAP;AACD;;AAED,SAAS,uBAAT,CACE,UADF,EAEE,MAFF,EAGE,YAHF,EAIE,UAJF,EAKE,OALF,EAKsC;AAEpC,QAAM,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,OAA5B;;AACA,MAAI,CAAC,OAAD,IAAY,OAAO,OAAP,KAAmB,QAAnC,EAA6C;AAC3C,UAAM,IAAI,KAAJ,CACJ,wDAAA,GACE,0CAA0C,UAAU,EAFlD,CAAN;AAID;;AACD,MAAI,YAAJ,EAAkB;AAChB,QAAI,CAAC,KAAK,CAAC,OAAN,CAAc,YAAd,CAAL,EAAkC;AAChC;AACA,MAAA,YAAY,GAAG,CAAC,YAAD,CAAf;AACD;;AAED,UAAM,SAAS,GAAG,EAAlB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAAY,CAAC,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC5C,MAAA,SAAS,CAAC,CAAD,CAAT,GAAe,UAAU,CAAC,WAAX,CACb,OADa,EAEb,YAAY,CAAC,CAAD,CAFC,EAGb,GAAG,UAAU,IAAI,CAAC,GAHL,EAIb,OAJa,CAAf;AAMD;;AACD,WAAO,SAAP;AACD;;AACD,SAAO,YAAP;AACD;;AAED,SAAS,oBAAT,CACE,UADF,EAEE,MAFF,EAGE,MAHF,EAIE,uBAJF,EAI0D;AAExD,QAAM,wBAAwB,GAAG,sCAAsC,CAAC,UAAD,EAAa,MAAb,CAAvE;;AACA,MAAI,wBAAJ,EAA8B;AAC5B,UAAM,iBAAiB,GAAG,wBAAwB,CAAC,uBAAD,CAAlD;;AACA,QAAI,iBAAiB,IAAI,SAAzB,EAAoC;AAClC,YAAM,kBAAkB,GAAG,MAAM,CAAC,iBAAD,CAAjC;;AACA,UAAI,kBAAkB,IAAI,SAA1B,EAAqC;AACnC,cAAM,QAAQ,GAAG,MAAM,CAAC,IAAP,CAAY,UAAZ,IAA0B,MAAM,CAAC,IAAP,CAAY,SAAvD;AACA,cAAM,kBAAkB,GACtB,kBAAkB,KAAK,QAAvB,GACI,kBADJ,GAEI,QAAQ,GAAG,GAAX,GAAiB,kBAHvB;AAIA,cAAM,iBAAiB,GAAG,UAAU,CAAC,YAAX,CAAwB,cAAxB,CAAuC,kBAAvC,CAA1B;;AACA,YAAI,iBAAJ,EAAuB;AACrB,UAAA,MAAM,GAAG,iBAAT;AACD;AACF;AACF;AACF;;AACD,SAAO,MAAP;AACD;;AAED,SAAS,sCAAT,CACE,UADF,EAEE,MAFF,EAEyB;AAEvB,SACE,MAAM,CAAC,IAAP,CAAY,wBAAZ,IACA,iCAAiC,CAAC,UAAD,EAAa,MAAM,CAAC,IAAP,CAAY,UAAzB,CADjC,IAEA,iCAAiC,CAAC,UAAD,EAAa,MAAM,CAAC,IAAP,CAAY,SAAzB,CAHnC;AAKD;;AAED,SAAS,iCAAT,CAA2C,UAA3C,EAAmE,QAAnE,EAAoF;AAClF,SACE,QAAQ,IACR,UAAU,CAAC,YAAX,CAAwB,QAAxB,CADA,IAEA,UAAU,CAAC,YAAX,CAAwB,QAAxB,EAAkC,IAAlC,CAAuC,wBAHzC;AAKD;AA6TD;;AAEG;;;AACH,OAAM,SAAU,eAAV,CAA0B,WAA1B,EAA8C;AAClD,QAAM,eAAe,GAAG,WAAxB;AACA,MAAI,WAAW,IAAI,SAAnB,EAA8B,OAAO,SAAP;;AAC9B,MAAI,WAAW,YAAY,UAA3B,EAAuC;AACrC,IAAA,WAAW,GAAG,MAAM,CAAC,eAAP,CAAuB,WAAvB,CAAd;AACA,WAAO,WAAP;AACD,GAHD,MAGO,IAAI,WAAW,YAAY,IAA3B,EAAiC;AACtC,WAAO,WAAW,CAAC,WAAZ,EAAP;AACD,GAFM,MAEA,IAAI,KAAK,CAAC,OAAN,CAAc,WAAd,CAAJ,EAAgC;AACrC,UAAM,KAAK,GAAG,EAAd;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,MAAA,KAAK,CAAC,IAAN,CAAW,eAAe,CAAC,WAAW,CAAC,CAAD,CAAZ,CAA1B;AACD;;AACD,WAAO,KAAP;AACD,GANM,MAMA,IAAI,OAAO,WAAP,KAAuB,QAA3B,EAAqC;AAC1C,UAAM,UAAU,GAA2B,EAA3C;;AACA,SAAK,MAAM,QAAX,IAAuB,WAAvB,EAAoC;AAClC,MAAA,UAAU,CAAC,QAAD,CAAV,GAAuB,eAAe,CAAC,eAAe,CAAC,QAAD,CAAhB,CAAtC;AACD;;AACD,WAAO,UAAP;AACD;;AACD,SAAO,WAAP;AACD;AAED;;AAEG;;AACH,SAAS,OAAT,CAAmC,CAAnC,EAA8C;AAC5C,QAAM,MAAM,GAAQ,EAApB;;AACA,OAAK,MAAM,GAAX,IAAkB,CAAlB,EAAqB;AACnB,IAAA,MAAM,CAAC,GAAD,CAAN,GAAc,GAAd;AACD;;AACD,SAAO,MAAP;AACD;AAED;;AAEG;AACH;;;AACA,OAAO,MAAM,UAAU,GAAG,OAAO,CAAC,CAChC,WADgC,EAEhC,SAFgC,EAGhC,WAHgC,EAIhC,WAJgC,EAKhC,MALgC,EAMhC,UANgC,EAOhC,iBAPgC,EAQhC,YARgC,EAShC,MATgC,EAUhC,QAVgC,EAWhC,QAXgC,EAYhC,UAZgC,EAahC,QAbgC,EAchC,QAdgC,EAehC,UAfgC,EAgBhC,UAhBgC,CAAD,CAA1B","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/* eslint-disable eqeqeq */\n\nimport * as base64 from \"./util/base64\";\nimport * as utils from \"./util/utils\";\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./util/serializer.common\";\n\n// This file contains utility code to serialize and deserialize network operations according to `OperationSpec` objects generated by AutoRest.TypeScript from OpenAPI specifications.\n\n/**\n * Used to map raw response objects to final shapes.\n * Helps packing and unpacking Dates and other encoded types that are not intrinsic to JSON.\n * Also allows pulling values from headers, as well as inserting default values and constants.\n */\nexport class Serializer {\n  constructor(\n    /**\n     * The provided model mapper.\n     */\n    public readonly modelMappers: { [key: string]: any } = {},\n    /**\n     * Whether the contents are XML or not.\n     */\n    public readonly isXML?: boolean\n  ) {}\n\n  /**\n   * Validates constraints, if any. This function will throw if the provided value does not respect those constraints.\n   * @param mapper - The definition of data models.\n   * @param value - The value.\n   * @param objectName - Name of the object. Used in the error messages.\n   * @deprecated Removing the constraints validation on client side.\n   */\n  validateConstraints(mapper: Mapper, value: unknown, objectName: string): void {\n    const failValidation = (\n      constraintName: keyof MapperConstraints,\n      constraintValue: any\n    ): Error => {\n      throw new Error(\n        `\"${objectName}\" with value \"${value}\" should satisfy the constraint \"${constraintName}\": ${constraintValue}.`\n      );\n    };\n    if (mapper.constraints && value != undefined) {\n      const valueAsNumber = value as number;\n      const {\n        ExclusiveMaximum,\n        ExclusiveMinimum,\n        InclusiveMaximum,\n        InclusiveMinimum,\n        MaxItems,\n        MaxLength,\n        MinItems,\n        MinLength,\n        MultipleOf,\n        Pattern,\n        UniqueItems,\n      } = mapper.constraints;\n      if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) {\n        failValidation(\"ExclusiveMaximum\", ExclusiveMaximum);\n      }\n      if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) {\n        failValidation(\"ExclusiveMinimum\", ExclusiveMinimum);\n      }\n      if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) {\n        failValidation(\"InclusiveMaximum\", InclusiveMaximum);\n      }\n      if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) {\n        failValidation(\"InclusiveMinimum\", InclusiveMinimum);\n      }\n      const valueAsArray = value as any[];\n      if (MaxItems != undefined && valueAsArray.length > MaxItems) {\n        failValidation(\"MaxItems\", MaxItems);\n      }\n      if (MaxLength != undefined && valueAsArray.length > MaxLength) {\n        failValidation(\"MaxLength\", MaxLength);\n      }\n      if (MinItems != undefined && valueAsArray.length < MinItems) {\n        failValidation(\"MinItems\", MinItems);\n      }\n      if (MinLength != undefined && valueAsArray.length < MinLength) {\n        failValidation(\"MinLength\", MinLength);\n      }\n      if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) {\n        failValidation(\"MultipleOf\", MultipleOf);\n      }\n      if (Pattern) {\n        const pattern: RegExp = typeof Pattern === \"string\" ? new RegExp(Pattern) : Pattern;\n        if (typeof value !== \"string\" || value.match(pattern) === null) {\n          failValidation(\"Pattern\", Pattern);\n        }\n      }\n      if (\n        UniqueItems &&\n        valueAsArray.some((item: any, i: number, ar: Array<any>) => ar.indexOf(item) !== i)\n      ) {\n        failValidation(\"UniqueItems\", UniqueItems);\n      }\n    }\n  }\n\n  /**\n   * Serialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param object - A valid Javascript object to be serialized.\n   * @param objectName - Name of the serialized object.\n   * @param options - additional options to deserialization.\n   * @returns A valid serialized Javascript object.\n   */\n  serialize(\n    mapper: Mapper,\n    object: unknown,\n    objectName?: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,\n    };\n    let payload: any = {};\n    const mapperType = mapper.type.name as string;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n    if (mapperType.match(/^Sequence$/i) !== null) {\n      payload = [];\n    }\n\n    if (mapper.isConstant) {\n      object = mapper.defaultValue;\n    }\n\n    // This table of allowed values should help explain\n    // the mapper.required and mapper.nullable properties.\n    // X means \"neither undefined or null are allowed\".\n    //           || required\n    //           || true      | false\n    //  nullable || ==========================\n    //      true || null      | undefined/null\n    //     false || X         | undefined\n    // undefined || X         | undefined/null\n\n    const { required, nullable } = mapper;\n\n    if (required && nullable && object === undefined) {\n      throw new Error(`${objectName} cannot be undefined.`);\n    }\n    if (required && !nullable && object == undefined) {\n      throw new Error(`${objectName} cannot be null or undefined.`);\n    }\n    if (!required && nullable === false && object === null) {\n      throw new Error(`${objectName} cannot be null.`);\n    }\n\n    if (object == undefined) {\n      payload = object;\n    } else {\n      if (mapperType.match(/^any$/i) !== null) {\n        payload = object;\n      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {\n        payload = serializeBasicTypes(mapperType, objectName, object);\n      } else if (mapperType.match(/^Enum$/i) !== null) {\n        const enumMapper: EnumMapper = mapper as EnumMapper;\n        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n      } else if (\n        mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null\n      ) {\n        payload = serializeDateTypes(mapperType, object, objectName);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = serializeByteArrayType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = serializeBase64UrlType(objectName, object as Uint8Array);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = serializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = serializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Composite$/i) !== null) {\n        payload = serializeCompositeType(\n          this,\n          mapper as CompositeMapper,\n          object,\n          objectName,\n          Boolean(this.isXML),\n          updatedOptions\n        );\n      }\n    }\n    return payload;\n  }\n\n  /**\n   * Deserialize the given object based on its metadata defined in the mapper.\n   *\n   * @param mapper - The mapper which defines the metadata of the serializable object.\n   * @param responseBody - A valid Javascript entity to be deserialized.\n   * @param objectName - Name of the deserialized object.\n   * @param options - Controls behavior of XML parser and builder.\n   * @returns A valid deserialized Javascript object.\n   */\n  deserialize(\n    mapper: Mapper,\n    responseBody: unknown,\n    objectName: string,\n    options: SerializerOptions = {}\n  ): any {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: options.rootName ?? \"\",\n      includeRoot: options.includeRoot ?? false,\n      xmlCharKey: options.xmlCharKey ?? XML_CHARKEY,\n    };\n    if (responseBody == undefined) {\n      if (this.isXML && mapper.type.name === \"Sequence\" && !mapper.xmlIsWrapped) {\n        // Edge case for empty XML non-wrapped lists. xml2js can't distinguish\n        // between the list being empty versus being missing,\n        // so let's do the more user-friendly thing and return an empty list.\n        responseBody = [];\n      }\n      // specifically check for undefined as default value can be a falsey value `0, \"\", false, null`\n      if (mapper.defaultValue !== undefined) {\n        responseBody = mapper.defaultValue;\n      }\n      return responseBody;\n    }\n\n    let payload: any;\n    const mapperType = mapper.type.name;\n    if (!objectName) {\n      objectName = mapper.serializedName!;\n    }\n\n    if (mapperType.match(/^Composite$/i) !== null) {\n      payload = deserializeCompositeType(\n        this,\n        mapper as CompositeMapper,\n        responseBody,\n        objectName,\n        updatedOptions\n      );\n    } else {\n      if (this.isXML) {\n        const xmlCharKey = updatedOptions.xmlCharKey;\n        const castResponseBody = responseBody as Record<string, unknown>;\n        /**\n         * If the mapper specifies this as a non-composite type value but the responseBody contains\n         * both header (\"$\" i.e., XML_ATTRKEY) and body (\"#\" i.e., XML_CHARKEY) properties,\n         * then just reduce the responseBody value to the body (\"#\" i.e., XML_CHARKEY) property.\n         */\n        if (\n          castResponseBody[XML_ATTRKEY] != undefined &&\n          castResponseBody[xmlCharKey] != undefined\n        ) {\n          responseBody = castResponseBody[xmlCharKey];\n        }\n      }\n\n      if (mapperType.match(/^Number$/i) !== null) {\n        payload = parseFloat(responseBody as string);\n        if (isNaN(payload)) {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^Boolean$/i) !== null) {\n        if (responseBody === \"true\") {\n          payload = true;\n        } else if (responseBody === \"false\") {\n          payload = false;\n        } else {\n          payload = responseBody;\n        }\n      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {\n        payload = responseBody;\n      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {\n        payload = new Date(responseBody as string);\n      } else if (mapperType.match(/^UnixTime$/i) !== null) {\n        payload = unixTimeToDate(responseBody as number);\n      } else if (mapperType.match(/^ByteArray$/i) !== null) {\n        payload = base64.decodeString(responseBody as string);\n      } else if (mapperType.match(/^Base64Url$/i) !== null) {\n        payload = base64UrlToByteArray(responseBody as string);\n      } else if (mapperType.match(/^Sequence$/i) !== null) {\n        payload = deserializeSequenceType(\n          this,\n          mapper as SequenceMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      } else if (mapperType.match(/^Dictionary$/i) !== null) {\n        payload = deserializeDictionaryType(\n          this,\n          mapper as DictionaryMapper,\n          responseBody,\n          objectName,\n          updatedOptions\n        );\n      }\n    }\n\n    if (mapper.isConstant) {\n      payload = mapper.defaultValue;\n    }\n\n    return payload;\n  }\n}\n\nfunction trimEnd(str: string, ch: string): string {\n  let len = str.length;\n  while (len - 1 >= 0 && str[len - 1] === ch) {\n    --len;\n  }\n  return str.substr(0, len);\n}\n\nfunction bufferToBase64Url(buffer: any): string | undefined {\n  if (!buffer) {\n    return undefined;\n  }\n  if (!(buffer instanceof Uint8Array)) {\n    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);\n  }\n  // Uint8Array to Base64.\n  const str = base64.encodeByteArray(buffer);\n  // Base64 to Base64Url.\n  return trimEnd(str, \"=\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n\nfunction base64UrlToByteArray(str: string): Uint8Array | undefined {\n  if (!str) {\n    return undefined;\n  }\n  if (str && typeof str.valueOf() !== \"string\") {\n    throw new Error(\"Please provide an input of type string for converting to Uint8Array\");\n  }\n  // Base64Url to Base64.\n  str = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Base64 to Uint8Array.\n  return base64.decodeString(str);\n}\n\nfunction splitSerializeName(prop: string | undefined): string[] {\n  const classes: string[] = [];\n  let partialclass = \"\";\n  if (prop) {\n    const subwords = prop.split(\".\");\n\n    for (const item of subwords) {\n      if (item.charAt(item.length - 1) === \"\\\\\") {\n        partialclass += item.substr(0, item.length - 1) + \".\";\n      } else {\n        partialclass += item;\n        classes.push(partialclass);\n        partialclass = \"\";\n      }\n    }\n  }\n\n  return classes;\n}\n\nfunction dateToUnixTime(d: string | Date): number | undefined {\n  if (!d) {\n    return undefined;\n  }\n\n  if (typeof d.valueOf() === \"string\") {\n    d = new Date(d as string);\n  }\n  return Math.floor((d as Date).getTime() / 1000);\n}\n\nfunction unixTimeToDate(n: number): Date | undefined {\n  if (!n) {\n    return undefined;\n  }\n  return new Date(n * 1000);\n}\n\nfunction serializeBasicTypes(typeName: string, objectName: string, value: any): any {\n  if (value !== null && value !== undefined) {\n    if (typeName.match(/^Number$/i) !== null) {\n      if (typeof value !== \"number\") {\n        throw new Error(`${objectName} with value ${value} must be of type number.`);\n      }\n    } else if (typeName.match(/^String$/i) !== null) {\n      if (typeof value.valueOf() !== \"string\") {\n        throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n      }\n    } else if (typeName.match(/^Uuid$/i) !== null) {\n      if (!(typeof value.valueOf() === \"string\" && utils.isValidUuid(value))) {\n        throw new Error(\n          `${objectName} with value \"${value}\" must be of type string and a valid uuid.`\n        );\n      }\n    } else if (typeName.match(/^Boolean$/i) !== null) {\n      if (typeof value !== \"boolean\") {\n        throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n      }\n    } else if (typeName.match(/^Stream$/i) !== null) {\n      const objectType = typeof value;\n      if (\n        objectType !== \"string\" &&\n        objectType !== \"function\" &&\n        !(value instanceof ArrayBuffer) &&\n        !ArrayBuffer.isView(value) &&\n        !((typeof Blob === \"function\" || typeof Blob === \"object\") && value instanceof Blob)\n      ) {\n        throw new Error(\n          `${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.`\n        );\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction serializeEnumType(objectName: string, allowedValues: Array<any>, value: any): any {\n  if (!allowedValues) {\n    throw new Error(\n      `Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`\n    );\n  }\n  const isPresent = allowedValues.some((item) => {\n    if (typeof item.valueOf() === \"string\") {\n      return item.toLowerCase() === value.toLowerCase();\n    }\n    return item === value;\n  });\n  if (!isPresent) {\n    throw new Error(\n      `${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(\n        allowedValues\n      )}.`\n    );\n  }\n  return value;\n}\n\nfunction serializeByteArrayType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = base64.encodeByteArray(value);\n  }\n  return returnValue;\n}\n\nfunction serializeBase64UrlType(objectName: string, value: Uint8Array): string {\n  let returnValue: string = \"\";\n  if (value != undefined) {\n    if (!(value instanceof Uint8Array)) {\n      throw new Error(`${objectName} must be of type Uint8Array.`);\n    }\n    returnValue = bufferToBase64Url(value) || \"\";\n  }\n  return returnValue;\n}\n\nfunction serializeDateTypes(typeName: string, value: any, objectName: string): any {\n  if (value != undefined) {\n    if (typeName.match(/^Date$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value =\n        value instanceof Date\n          ? value.toISOString().substring(0, 10)\n          : new Date(value).toISOString().substring(0, 10);\n    } else if (typeName.match(/^DateTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n      }\n      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();\n    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n      }\n      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();\n    } else if (typeName.match(/^UnixTime$/i) !== null) {\n      if (\n        !(\n          value instanceof Date ||\n          (typeof value.valueOf() === \"string\" && !isNaN(Date.parse(value)))\n        )\n      ) {\n        throw new Error(\n          `${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n            `for it to be serialized in UnixTime/Epoch format.`\n        );\n      }\n      value = dateToUnixTime(value);\n    } else if (typeName.match(/^TimeSpan$/i) !== null) {\n      if (!utils.isDuration(value)) {\n        throw new Error(\n          `${objectName} must be a string in ISO 8601 format. Instead was \"${value}\".`\n        );\n      }\n    }\n  }\n  return value;\n}\n\nfunction serializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any[] {\n  if (!Array.isArray(object)) {\n    throw new Error(`${objectName} must be of type Array.`);\n  }\n  const elementType = mapper.type.element;\n  if (!elementType || typeof elementType !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempArray = [];\n  for (let i = 0; i < object.length; i++) {\n    const serializedValue = serializer.serialize(elementType, object[i], objectName, options);\n\n    if (isXml && elementType.xmlNamespace) {\n      const xmlnsKey = elementType.xmlNamespacePrefix\n        ? `xmlns:${elementType.xmlNamespacePrefix}`\n        : \"xmlns\";\n      if (elementType.type.name === \"Composite\") {\n        tempArray[i] = { ...serializedValue };\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      } else {\n        tempArray[i] = {};\n        tempArray[i][options.xmlCharKey] = serializedValue;\n        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };\n      }\n    } else {\n      tempArray[i] = serializedValue;\n    }\n  }\n  return tempArray;\n}\n\nfunction serializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  if (typeof object !== \"object\") {\n    throw new Error(`${objectName} must be of type object.`);\n  }\n  const valueType = mapper.type.value;\n  if (!valueType || typeof valueType !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}.`\n    );\n  }\n  const tempDictionary: { [key: string]: any } = {};\n  for (const key of Object.keys(object)) {\n    const serializedValue = serializer.serialize(valueType, object[key], objectName, options);\n    // If the element needs an XML namespace we need to add it within the $ property\n    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);\n  }\n\n  // Add the namespace to the root element if needed\n  if (isXml && mapper.xmlNamespace) {\n    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : \"xmlns\";\n\n    const result = tempDictionary;\n    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };\n    return result;\n  }\n\n  return tempDictionary;\n}\n\n/**\n * Resolves the additionalProperties property from a referenced mapper.\n * @param serializer - The serializer containing the entire set of mappers.\n * @param mapper - The composite mapper to resolve.\n * @param objectName - Name of the object being serialized.\n */\nfunction resolveAdditionalProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): SequenceMapper | BaseMapper | CompositeMapper | DictionaryMapper | EnumMapper | undefined {\n  const additionalProperties = mapper.type.additionalProperties;\n\n  if (!additionalProperties && mapper.type.className) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    return modelMapper?.type.additionalProperties;\n  }\n\n  return additionalProperties;\n}\n\n/**\n * Finds the mapper referenced by `className`.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n * @param objectName - Name of the object being serialized\n */\nfunction resolveReferencedMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): CompositeMapper | undefined {\n  const className = mapper.type.className;\n  if (!className) {\n    throw new Error(\n      `Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(\n        mapper,\n        undefined,\n        2\n      )}\".`\n    );\n  }\n\n  return serializer.modelMappers[className];\n}\n\n/**\n * Resolves a composite mapper's modelProperties.\n * @param serializer - The serializer containing the entire set of mappers\n * @param mapper - The composite mapper to resolve\n */\nfunction resolveModelProperties(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  objectName: string\n): { [propertyName: string]: Mapper } {\n  let modelProps = mapper.type.modelProperties;\n  if (!modelProps) {\n    const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);\n    if (!modelMapper) {\n      throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n    }\n    modelProps = modelMapper?.type.modelProperties;\n    if (!modelProps) {\n      throw new Error(\n        `modelProperties cannot be null or undefined in the ` +\n          `mapper \"${JSON.stringify(modelMapper)}\" of type \"${\n            mapper.type.className\n          }\" for object \"${objectName}\".`\n      );\n    }\n  }\n\n  return modelProps;\n}\n\nfunction serializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  objectName: string,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, object, \"clientName\");\n  }\n\n  if (object != undefined) {\n    const payload: any = {};\n    const modelProps = resolveModelProperties(serializer, mapper, objectName);\n    for (const key of Object.keys(modelProps)) {\n      const propertyMapper = modelProps[key];\n      if (propertyMapper.readOnly) {\n        continue;\n      }\n\n      let propName: string | undefined;\n      let parentObject: any = payload;\n      if (serializer.isXML) {\n        if (propertyMapper.xmlIsWrapped) {\n          propName = propertyMapper.xmlName;\n        } else {\n          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;\n        }\n      } else {\n        const paths = splitSerializeName(propertyMapper.serializedName!);\n        propName = paths.pop();\n\n        for (const pathName of paths) {\n          const childObject = parentObject[pathName];\n          if (\n            childObject == undefined &&\n            (object[key] != undefined || propertyMapper.defaultValue !== undefined)\n          ) {\n            parentObject[pathName] = {};\n          }\n          parentObject = parentObject[pathName];\n        }\n      }\n\n      if (parentObject != undefined) {\n        if (isXml && mapper.xmlNamespace) {\n          const xmlnsKey = mapper.xmlNamespacePrefix\n            ? `xmlns:${mapper.xmlNamespacePrefix}`\n            : \"xmlns\";\n          parentObject[XML_ATTRKEY] = {\n            ...parentObject[XML_ATTRKEY],\n            [xmlnsKey]: mapper.xmlNamespace,\n          };\n        }\n        const propertyObjectName =\n          propertyMapper.serializedName !== \"\"\n            ? objectName + \".\" + propertyMapper.serializedName\n            : objectName;\n\n        let toSerialize = object[key];\n        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n        if (\n          polymorphicDiscriminator &&\n          polymorphicDiscriminator.clientName === key &&\n          toSerialize == undefined\n        ) {\n          toSerialize = mapper.serializedName;\n        }\n\n        const serializedValue = serializer.serialize(\n          propertyMapper,\n          toSerialize,\n          propertyObjectName,\n          options\n        );\n\n        if (serializedValue !== undefined && propName != undefined) {\n          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);\n          if (isXml && propertyMapper.xmlIsAttribute) {\n            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.\n            // This keeps things simple while preventing name collision\n            // with names in user documents.\n            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};\n            parentObject[XML_ATTRKEY][propName] = serializedValue;\n          } else if (isXml && propertyMapper.xmlIsWrapped) {\n            parentObject[propName] = { [propertyMapper.xmlElementName!]: value };\n          } else {\n            parentObject[propName] = value;\n          }\n        }\n      }\n    }\n\n    const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);\n    if (additionalPropertiesMapper) {\n      const propNames = Object.keys(modelProps);\n      for (const clientPropName in object) {\n        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);\n        if (isAdditionalProperty) {\n          payload[clientPropName] = serializer.serialize(\n            additionalPropertiesMapper,\n            object[clientPropName],\n            objectName + '[\"' + clientPropName + '\"]',\n            options\n          );\n        }\n      }\n    }\n\n    return payload;\n  }\n  return object;\n}\n\nfunction getXmlObjectValue(\n  propertyMapper: Mapper,\n  serializedValue: any,\n  isXml: boolean,\n  options: Required<SerializerOptions>\n): any {\n  if (!isXml || !propertyMapper.xmlNamespace) {\n    return serializedValue;\n  }\n\n  const xmlnsKey = propertyMapper.xmlNamespacePrefix\n    ? `xmlns:${propertyMapper.xmlNamespacePrefix}`\n    : \"xmlns\";\n  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };\n\n  if ([\"Composite\"].includes(propertyMapper.type.name)) {\n    if (serializedValue[XML_ATTRKEY]) {\n      return serializedValue;\n    } else {\n      const result: any = { ...serializedValue };\n      result[XML_ATTRKEY] = xmlNamespace;\n      return result;\n    }\n  }\n  const result: any = {};\n  result[options.xmlCharKey] = serializedValue;\n  result[XML_ATTRKEY] = xmlNamespace;\n  return result;\n}\n\nfunction isSpecialXmlProperty(propertyName: string, options: Required<SerializerOptions>): boolean {\n  return [XML_ATTRKEY, options.xmlCharKey].includes(propertyName);\n}\n\nfunction deserializeCompositeType(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any {\n  const xmlCharKey = options.xmlCharKey ?? XML_CHARKEY;\n  if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {\n    mapper = getPolymorphicMapper(serializer, mapper, responseBody, \"serializedName\");\n  }\n\n  const modelProps = resolveModelProperties(serializer, mapper, objectName);\n  let instance: { [key: string]: any } = {};\n  const handledPropertyNames: string[] = [];\n\n  for (const key of Object.keys(modelProps)) {\n    const propertyMapper = modelProps[key];\n    const paths = splitSerializeName(modelProps[key].serializedName!);\n    handledPropertyNames.push(paths[0]);\n    const { serializedName, xmlName, xmlElementName } = propertyMapper;\n    let propertyObjectName = objectName;\n    if (serializedName !== \"\" && serializedName !== undefined) {\n      propertyObjectName = objectName + \".\" + serializedName;\n    }\n\n    const headerCollectionPrefix = (propertyMapper as DictionaryMapper).headerCollectionPrefix;\n    if (headerCollectionPrefix) {\n      const dictionary: any = {};\n      for (const headerKey of Object.keys(responseBody)) {\n        if (headerKey.startsWith(headerCollectionPrefix)) {\n          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(\n            (propertyMapper as DictionaryMapper).type.value,\n            responseBody[headerKey],\n            propertyObjectName,\n            options\n          );\n        }\n\n        handledPropertyNames.push(headerKey);\n      }\n      instance[key] = dictionary;\n    } else if (serializer.isXML) {\n      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {\n        instance[key] = serializer.deserialize(\n          propertyMapper,\n          responseBody[XML_ATTRKEY][xmlName!],\n          propertyObjectName,\n          options\n        );\n      } else if (propertyMapper.xmlIsMsText) {\n        if (responseBody[xmlCharKey] !== undefined) {\n          instance[key] = responseBody[xmlCharKey];\n        } else if (typeof responseBody === \"string\") {\n          // The special case where xml parser parses \"<Name>content</Name>\" into JSON of\n          //   `{ name: \"content\"}` instead of `{ name: { \"_\": \"content\" }}`\n          instance[key] = responseBody;\n        }\n      } else {\n        const propertyName = xmlElementName || xmlName || serializedName;\n        if (propertyMapper.xmlIsWrapped) {\n          /* a list of <xmlElementName> wrapped by <xmlName>\n            For the xml example below\n              <Cors>\n                <CorsRule>...</CorsRule>\n                <CorsRule>...</CorsRule>\n              </Cors>\n            the responseBody has\n              {\n                Cors: {\n                  CorsRule: [{...}, {...}]\n                }\n              }\n            xmlName is \"Cors\" and xmlElementName is\"CorsRule\".\n          */\n          const wrapped = responseBody[xmlName!];\n          const elementList = wrapped?.[xmlElementName!] ?? [];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            elementList,\n            propertyObjectName,\n            options\n          );\n          handledPropertyNames.push(xmlName!);\n        } else {\n          const property = responseBody[propertyName!];\n          instance[key] = serializer.deserialize(\n            propertyMapper,\n            property,\n            propertyObjectName,\n            options\n          );\n          handledPropertyNames.push(propertyName!);\n        }\n      }\n    } else {\n      // deserialize the property if it is present in the provided responseBody instance\n      let propertyInstance;\n      let res = responseBody;\n      // traversing the object step by step.\n      for (const item of paths) {\n        if (!res) break;\n        res = res[item];\n      }\n      propertyInstance = res;\n      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;\n      // checking that the model property name (key)(ex: \"fishtype\") and the\n      // clientName of the polymorphicDiscriminator {metadata} (ex: \"fishtype\")\n      // instead of the serializedName of the polymorphicDiscriminator (ex: \"fish.type\")\n      // is a better approach. The generator is not consistent with escaping '\\.' in the\n      // serializedName of the property (ex: \"fish\\.type\") that is marked as polymorphic discriminator\n      // and the serializedName of the metadata polymorphicDiscriminator (ex: \"fish.type\"). However,\n      // the clientName transformation of the polymorphicDiscriminator (ex: \"fishtype\") and\n      // the transformation of model property name (ex: \"fishtype\") is done consistently.\n      // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.\n      if (\n        polymorphicDiscriminator &&\n        key === polymorphicDiscriminator.clientName &&\n        propertyInstance == undefined\n      ) {\n        propertyInstance = mapper.serializedName;\n      }\n\n      let serializedValue;\n      // paging\n      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === \"\") {\n        propertyInstance = responseBody[key];\n        const arrayInstance = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        // Copy over any properties that have already been added into the instance, where they do\n        // not exist on the newly de-serialized array\n        for (const [k, v] of Object.entries(instance)) {\n          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {\n            arrayInstance[k] = v;\n          }\n        }\n        instance = arrayInstance;\n      } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {\n        serializedValue = serializer.deserialize(\n          propertyMapper,\n          propertyInstance,\n          propertyObjectName,\n          options\n        );\n        instance[key] = serializedValue;\n      }\n    }\n  }\n\n  const additionalPropertiesMapper = mapper.type.additionalProperties;\n  if (additionalPropertiesMapper) {\n    const isAdditionalProperty = (responsePropName: string): boolean => {\n      for (const clientPropName in modelProps) {\n        const paths = splitSerializeName(modelProps[clientPropName].serializedName);\n        if (paths[0] === responsePropName) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    for (const responsePropName in responseBody) {\n      if (isAdditionalProperty(responsePropName)) {\n        instance[responsePropName] = serializer.deserialize(\n          additionalPropertiesMapper,\n          responseBody[responsePropName],\n          objectName + '[\"' + responsePropName + '\"]',\n          options\n        );\n      }\n    }\n  } else if (responseBody) {\n    for (const key of Object.keys(responseBody)) {\n      if (\n        instance[key] === undefined &&\n        !handledPropertyNames.includes(key) &&\n        !isSpecialXmlProperty(key, options)\n      ) {\n        instance[key] = responseBody[key];\n      }\n    }\n  }\n\n  return instance;\n}\n\nfunction deserializeDictionaryType(\n  serializer: Serializer,\n  mapper: DictionaryMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): { [key: string]: any } {\n  const value = mapper.type.value;\n  if (!value || typeof value !== \"object\") {\n    throw new Error(\n      `\"value\" metadata for a Dictionary must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    const tempDictionary: { [key: string]: any } = {};\n    for (const key of Object.keys(responseBody)) {\n      tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);\n    }\n    return tempDictionary;\n  }\n  return responseBody;\n}\n\nfunction deserializeSequenceType(\n  serializer: Serializer,\n  mapper: SequenceMapper,\n  responseBody: any,\n  objectName: string,\n  options: Required<SerializerOptions>\n): any[] {\n  const element = mapper.type.element;\n  if (!element || typeof element !== \"object\") {\n    throw new Error(\n      `element\" metadata for an Array must be defined in the ` +\n        `mapper and it must of type \"object\" in ${objectName}`\n    );\n  }\n  if (responseBody) {\n    if (!Array.isArray(responseBody)) {\n      // xml2js will interpret a single element array as just the element, so force it to be an array\n      responseBody = [responseBody];\n    }\n\n    const tempArray = [];\n    for (let i = 0; i < responseBody.length; i++) {\n      tempArray[i] = serializer.deserialize(\n        element,\n        responseBody[i],\n        `${objectName}[${i}]`,\n        options\n      );\n    }\n    return tempArray;\n  }\n  return responseBody;\n}\n\nfunction getPolymorphicMapper(\n  serializer: Serializer,\n  mapper: CompositeMapper,\n  object: any,\n  polymorphicPropertyName: \"clientName\" | \"serializedName\"\n): CompositeMapper {\n  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);\n  if (polymorphicDiscriminator) {\n    const discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];\n    if (discriminatorName != undefined) {\n      const discriminatorValue = object[discriminatorName];\n      if (discriminatorValue != undefined) {\n        const typeName = mapper.type.uberParent || mapper.type.className;\n        const indexDiscriminator =\n          discriminatorValue === typeName\n            ? discriminatorValue\n            : typeName + \".\" + discriminatorValue;\n        const polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];\n        if (polymorphicMapper) {\n          mapper = polymorphicMapper;\n        }\n      }\n    }\n  }\n  return mapper;\n}\n\nfunction getPolymorphicDiscriminatorRecursively(\n  serializer: Serializer,\n  mapper: CompositeMapper\n): PolymorphicDiscriminator | undefined {\n  return (\n    mapper.type.polymorphicDiscriminator ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||\n    getPolymorphicDiscriminatorSafely(serializer, mapper.type.className)\n  );\n}\n\nfunction getPolymorphicDiscriminatorSafely(serializer: Serializer, typeName?: string): any {\n  return (\n    typeName &&\n    serializer.modelMappers[typeName] &&\n    serializer.modelMappers[typeName].type.polymorphicDiscriminator\n  );\n}\n\n/**\n * Description of various value constraints such as integer ranges and string regex.\n */\nexport interface MapperConstraints {\n  /**\n   * The value should be less than or equal to the `InclusiveMaximum` value.\n   */\n  InclusiveMaximum?: number;\n  /**\n   * The value should be less than the `ExclusiveMaximum` value.\n   */\n  ExclusiveMaximum?: number;\n  /**\n   * The value should be greater than or equal to the `InclusiveMinimum` value.\n   */\n  InclusiveMinimum?: number;\n  /**\n   * The value should be greater than the `InclusiveMinimum` value.\n   */\n  ExclusiveMinimum?: number;\n  /**\n   * The length should be smaller than the `MaxLength`.\n   */\n  MaxLength?: number;\n  /**\n   * The length should be bigger than the `MinLength`.\n   */\n  MinLength?: number;\n  /**\n   * The value must match the pattern.\n   */\n  Pattern?: RegExp;\n  /**\n   * The value must contain fewer items than the MaxItems value.\n   */\n  MaxItems?: number;\n  /**\n   * The value must contain more items than the `MinItems` value.\n   */\n  MinItems?: number;\n  /**\n   * The value must contain only unique items.\n   */\n  UniqueItems?: true;\n  /**\n   * The value should be exactly divisible by the `MultipleOf` value.\n   */\n  MultipleOf?: number;\n}\n\n/**\n * Type of the mapper. Includes known mappers.\n */\nexport type MapperType =\n  | SimpleMapperType\n  | CompositeMapperType\n  | SequenceMapperType\n  | DictionaryMapperType\n  | EnumMapperType;\n\n/**\n * The type of a simple mapper.\n */\nexport interface SimpleMapperType {\n  /**\n   * Name of the type of the property.\n   */\n  name:\n    | \"Base64Url\"\n    | \"Boolean\"\n    | \"ByteArray\"\n    | \"Date\"\n    | \"DateTime\"\n    | \"DateTimeRfc1123\"\n    | \"Object\"\n    | \"Stream\"\n    | \"String\"\n    | \"TimeSpan\"\n    | \"UnixTime\"\n    | \"Uuid\"\n    | \"Number\"\n    | \"any\";\n}\n\n/**\n * Helps build a mapper that describes how to map a set of properties of an object based on other mappers.\n *\n * Only one of the following properties should be present: `className`, `modelProperties` and `additionalProperties`.\n */\nexport interface CompositeMapperType {\n  /**\n   * Name of the composite mapper type.\n   */\n  name: \"Composite\";\n\n  /**\n   * Use `className` to reference another type definition.\n   */\n  className?: string;\n\n  /**\n   * Use `modelProperties` when the reference to the other type has been resolved.\n   */\n  modelProperties?: { [propertyName: string]: Mapper };\n\n  /**\n   * Used when a model has `additionalProperties: true`. Allows the generic processing of unnamed model properties on the response object.\n   */\n  additionalProperties?: Mapper;\n\n  /**\n   * The name of the top-most parent scheme, the one that has no parents.\n   */\n  uberParent?: string;\n\n  /**\n   * A polymorphic discriminator.\n   */\n  polymorphicDiscriminator?: PolymorphicDiscriminator;\n}\n\n/**\n * Helps build a mapper that describes how to parse a sequence of mapped values.\n */\nexport interface SequenceMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Sequence\";\n  /**\n   * The mapper to use to map each one of the properties of the sequence.\n   */\n  element: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse a dictionary of mapped values.\n */\nexport interface DictionaryMapperType {\n  /**\n   * Name of the sequence type mapper.\n   */\n  name: \"Dictionary\";\n  /**\n   * The mapper to use to map the value of each property in the dictionary.\n   */\n  value: Mapper;\n}\n\n/**\n * Helps build a mapper that describes how to parse an enum value.\n */\nexport interface EnumMapperType {\n  /**\n   * Name of the enum type mapper.\n   */\n  name: \"Enum\";\n  /**\n   * Values allowed by this mapper.\n   */\n  allowedValues: any[];\n}\n\n/**\n * The base definition of a mapper. Can be used for XML and plain JavaScript objects.\n */\nexport interface BaseMapper {\n  /**\n   * Name for the xml element\n   */\n  xmlName?: string;\n  /**\n   * Xml element namespace\n   */\n  xmlNamespace?: string;\n  /**\n   * Xml element namespace prefix\n   */\n  xmlNamespacePrefix?: string;\n  /**\n   * Determines if the current property should be serialized as an attribute of the parent xml element\n   */\n  xmlIsAttribute?: boolean;\n  /**\n   * Determines if the current property should be serialized as the inner content of the xml element\n   */\n  xmlIsMsText?: boolean;\n  /**\n   * Name for the xml elements when serializing an array\n   */\n  xmlElementName?: string;\n  /**\n   * Whether or not the current property should have a wrapping XML element\n   */\n  xmlIsWrapped?: boolean;\n  /**\n   * Whether or not the current property is readonly\n   */\n  readOnly?: boolean;\n  /**\n   * Whether or not the current property is a constant\n   */\n  isConstant?: boolean;\n  /**\n   * Whether or not the current property is required\n   */\n  required?: boolean;\n  /**\n   * Whether or not the current property allows mull as a value\n   */\n  nullable?: boolean;\n  /**\n   * The name to use when serializing\n   */\n  serializedName?: string;\n  /**\n   * Type of the mapper\n   */\n  type: MapperType;\n  /**\n   * Default value when one is not explicitly provided\n   */\n  defaultValue?: any;\n  /**\n   * Constraints to test the current value against\n   */\n  constraints?: MapperConstraints;\n}\n\n/**\n * Mappers are definitions of the data models used in the library.\n * These data models are part of the Operation or Client definitions in the responses or parameters.\n */\nexport type Mapper = BaseMapper | CompositeMapper | SequenceMapper | DictionaryMapper | EnumMapper;\n\n/**\n * Used to disambiguate discriminated type unions.\n * For example, if response can have many shapes but also includes a 'kind' field (or similar),\n * that field can be used to determine how to deserialize the response to the correct type.\n */\nexport interface PolymorphicDiscriminator {\n  /**\n   * Name of the discriminant property in the original JSON payload, e.g. `@odata.kind`.\n   */\n  serializedName: string;\n  /**\n   * Name to use on the resulting object instead of the original property name.\n   * Useful since the JSON property could be difficult to work with.\n   * For example: For a field received as `@odata.kind`, the final object could instead include a property simply named `kind`.\n   */\n  clientName: string;\n  /**\n   * It may contain any other property.\n   */\n  [key: string]: string;\n}\n\n/**\n * A mapper composed of other mappers.\n */\nexport interface CompositeMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `CompositeMapper`.\n   */\n  type: CompositeMapperType;\n}\n\n/**\n * A mapper describing arrays.\n */\nexport interface SequenceMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `SequenceMapper`.\n   */\n  type: SequenceMapperType;\n}\n\n/**\n * A mapper describing plain JavaScript objects used as key/value pairs.\n */\nexport interface DictionaryMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `DictionaryMapper`.\n   */\n  type: DictionaryMapperType;\n  /**\n   * Optionally, a prefix to add to the header collection.\n   */\n  headerCollectionPrefix?: string;\n}\n\n/**\n * A mapper describing an enum value.\n */\nexport interface EnumMapper extends BaseMapper {\n  /**\n   * The type descriptor of the `EnumMapper`.\n   */\n  type: EnumMapperType;\n}\n\n/**\n * An interface representing an URL parameter value.\n */\nexport interface UrlParameterValue {\n  /**\n   * The URL value.\n   */\n  value: string;\n  /**\n   * Whether to keep or skip URL encoding.\n   */\n  skipUrlEncoding: boolean;\n}\n\n/**\n * Utility function that serializes an object that might contain binary information into a plain object, array or a string.\n */\nexport function serializeObject(toSerialize: unknown): any {\n  const castToSerialize = toSerialize as Record<string, unknown>;\n  if (toSerialize == undefined) return undefined;\n  if (toSerialize instanceof Uint8Array) {\n    toSerialize = base64.encodeByteArray(toSerialize);\n    return toSerialize;\n  } else if (toSerialize instanceof Date) {\n    return toSerialize.toISOString();\n  } else if (Array.isArray(toSerialize)) {\n    const array = [];\n    for (let i = 0; i < toSerialize.length; i++) {\n      array.push(serializeObject(toSerialize[i]));\n    }\n    return array;\n  } else if (typeof toSerialize === \"object\") {\n    const dictionary: { [key: string]: any } = {};\n    for (const property in toSerialize) {\n      dictionary[property] = serializeObject(castToSerialize[property]);\n    }\n    return dictionary;\n  }\n  return toSerialize;\n}\n\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum<T extends string>(o: Array<T>): { [K in T]: K } {\n  const result: any = {};\n  for (const key of o) {\n    result[key] = key;\n  }\n  return result;\n}\n\n/**\n * String enum containing the string types of property mappers.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const MapperType = strEnum([\n  \"Base64Url\",\n  \"Boolean\",\n  \"ByteArray\",\n  \"Composite\",\n  \"Date\",\n  \"DateTime\",\n  \"DateTimeRfc1123\",\n  \"Dictionary\",\n  \"Enum\",\n  \"Number\",\n  \"Object\",\n  \"Sequence\",\n  \"String\",\n  \"Stream\",\n  \"TimeSpan\",\n  \"UnixTime\",\n]);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}