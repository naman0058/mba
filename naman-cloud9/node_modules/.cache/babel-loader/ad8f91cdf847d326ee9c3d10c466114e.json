{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isNode, URLBuilder } from \"@azure/core-http\";\nimport { DevelopmentConnectionString, HeaderConstants, PathStylePorts, URLConstants } from \"./constants\";\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\n\nexport function escapeURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path || \"/\";\n  path = escape(path);\n  urlParsed.setPath(path);\n  return urlParsed.toString();\n}\n\nfunction getProxyUriFromDevConnString(connectionString) {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")[1];\n      }\n    }\n  }\n\n  return proxyUri;\n}\n\nexport function getValueInConnString(connectionString, argument) {\n  const elements = connectionString.split(\";\");\n\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")[1];\n    }\n  }\n\n  return \"\";\n}\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\n\nexport function extractConnectionStringParts(connectionString) {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  } // Matching BlobEndpoint in the Account connection string\n\n\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\"); // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 && connectionString.search(\"AccountKey=\") !== -1) {\n    // Account connection string\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\"; // Get account name and key\n\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol.toLowerCase();\n\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\");\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri\n    };\n  } else {\n    // SAS connection string\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    const accountName = getAccountNameFromUrl(blobEndpoint);\n\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return {\n      kind: \"SASConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountSas\n    };\n  }\n}\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\n\nfunction escape(text) {\n  return encodeURIComponent(text).replace(/%2F/g, \"/\") // Don't escape for \"/\"\n  .replace(/'/g, \"%27\") // Escape for \"'\"\n  .replace(/\\+/g, \"%20\").replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\n\n\nexport function appendToURLPath(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  let path = urlParsed.getPath();\n  path = path ? path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}` : name;\n  urlParsed.setPath(path);\n  const normalizedUrl = new URL(urlParsed.toString());\n  return normalizedUrl.toString();\n}\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\n\nexport function setURLParameter(url, name, value) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\n\nexport function getURLParameter(url, name) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\n\nexport function setURLHost(url, host) {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPath(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLScheme(url) {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\n\nexport function getURLPathAndQuery(url) {\n  const urlParsed = URLBuilder.parse(url);\n  const pathString = urlParsed.getPath();\n\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\n\nexport function getURLQueries(url) {\n  let queryString = URLBuilder.parse(url).getQuery();\n\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n  let querySubStrings = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter(value => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1;\n  });\n  const queries = {};\n\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key = splitResults[0];\n    const value = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\n\nexport function appendToURLQuery(url, queryParts) {\n  const urlParsed = URLBuilder.parse(url);\n  let query = urlParsed.getQuery();\n\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\n\nexport function truncatedISO8061Date(date) {\n  let withMilliseconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n  return withMilliseconds ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\" : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n/**\n * Base64 encode.\n *\n * @param content -\n */\n\nexport function base64encode(content) {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\n\nexport function base64decode(encodedString) {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\n\nexport function generateBlockID(blockIDPrefix, blockIndex) {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48; // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n\n  const maxBlockIndexLength = 6;\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n\n  const res = blockIDPrefix + padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\n\nexport async function delay(timeInMs, aborter, abortError) {\n  return new Promise((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout;\n\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n\n      reject(abortError);\n    };\n\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n\n      resolve();\n    };\n\n    timeout = setTimeout(resolveHandler, timeInMs);\n\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\n\nexport function padStart(currentString, targetLength) {\n  let padString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \" \";\n\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\nexport function sanitizeURL(url) {\n  let safeURL = url;\n\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\nexport function sanitizeHeaders(originalHeader) {\n  const headers = new HttpHeaders();\n\n  for (const header of originalHeader.headersArray()) {\n    if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(header.name, \"*****\");\n    } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(header.name, sanitizeURL(header.value));\n    } else {\n      headers.set(header.name, header.value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\n\nexport function iEqual(str1, str2) {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\n\nexport function getAccountNameFromUrl(url) {\n  const parsedUrl = URLBuilder.parse(url);\n  let accountName;\n\n  try {\n    if (parsedUrl.getHost().split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost().split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath().split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n\n    return accountName;\n  } catch (error) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\nexport function isIpEndpointStyle(parsedUrl) {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n\n  const host = parsedUrl.getHost() + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort()); // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n\n  return /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(host) || parsedUrl.getPort() !== undefined && PathStylePorts.includes(parsedUrl.getPort());\n}\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\n\nexport function toBlobTagsString(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\n\nexport function toBlobTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {\n    blobTagSet: []\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value\n      });\n    }\n  }\n\n  return res;\n}\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\n\nexport function toTags(tags) {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res = {};\n\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n\n  return res;\n}\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\n\nexport function toQuerySerialization(textConfiguration) {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false\n          }\n        }\n      };\n\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator\n          }\n        }\n      };\n\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema\n          }\n        }\n      };\n\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\"\n        }\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\nexport function parseObjectReplicationRecord(objectReplicationRecord) {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties = [];\n\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n\n    const rule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key]\n    };\n    const policyIndex = orProperties.findIndex(policy => policy.policyId === ids[0]);\n\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule]\n      });\n    }\n  }\n\n  return orProperties;\n}\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\n\nexport function attachCredential(thing, credential) {\n  thing.credential = credential;\n  return thing;\n}\nexport function httpAuthorizationToString(httpAuthorization) {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\nexport function BlobNameToString(name) {\n  if (name.encoded) {\n    return decodeURIComponent(name.content);\n  } else {\n    return name.content;\n  }\n}\nexport function ConvertInternalResponseOfListBlobFlat(internalResponse) {\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nexport function ConvertInternalResponseOfListBlobHierarchy(internalResponse) {\n  var _a;\n\n  return Object.assign(Object.assign({}, internalResponse), {\n    segment: {\n      blobPrefixes: (_a = internalResponse.segment.blobPrefixes) === null || _a === void 0 ? void 0 : _a.map(blobPrefixInternal => {\n        const blobPrefix = {\n          name: BlobNameToString(blobPrefixInternal.name)\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map(blobItemInteral => {\n        const blobItem = Object.assign(Object.assign({}, blobItemInteral), {\n          name: BlobNameToString(blobItemInteral.name)\n        });\n        return blobItem;\n      })\n    }\n  });\n}\nexport function* ExtractPageRangeInfoItems(getPageRangesSegment) {\n  let pageRange = [];\n  let clearRange = [];\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true\n      };\n      ++clearRangeIndex;\n    }\n  }\n\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false\n    };\n  }\n\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true\n    };\n  }\n}\n/**\n * Escape the blobName but keep path separator ('/').\n */\n\nexport function EscapePath(blobName) {\n  const split = blobName.split(\"/\");\n\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n\n  return split.join(\"/\");\n}","map":{"version":3,"sources":["../../../../src/utils/utils.common.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpHeaders, isNode, URLBuilder, TokenCredential } from \"@azure/core-http\";\n\nimport {\n  BlobQueryArrowConfiguration,\n  BlobQueryCsvTextConfiguration,\n  BlobQueryJsonTextConfiguration,\n  BlobQueryParquetConfiguration,\n} from \"../Clients\";\nimport {\n  QuerySerialization,\n  BlobTags,\n  BlobName,\n  ListBlobsFlatSegmentResponse,\n  ListBlobsHierarchySegmentResponse,\n  PageRange,\n  ClearRange,\n} from \"../generated/src/models\";\nimport {\n  DevelopmentConnectionString,\n  HeaderConstants,\n  PathStylePorts,\n  URLConstants,\n} from \"./constants\";\nimport {\n  Tags,\n  ObjectReplicationPolicy,\n  ObjectReplicationRule,\n  ObjectReplicationStatus,\n  HttpAuthorization,\n} from \"../models\";\nimport {\n  ListBlobsFlatSegmentResponseModel,\n  BlobItemInternal as BlobItemInternalModel,\n  ListBlobsHierarchySegmentResponseModel,\n  BlobPrefix as BlobPrefixModel,\n  PageBlobGetPageRangesDiffResponseModel,\n  PageRangeInfo,\n} from \"../generatedModels\";\n\n/**\n * Reserved URL characters must be properly escaped for Storage services like Blob or File.\n *\n * ## URL encode and escape strategy for JS SDKs\n *\n * When customers pass a URL string into XxxClient classes constructor, the URL string may already be URL encoded or not.\n * But before sending to Azure Storage server, the URL must be encoded. However, it's hard for a SDK to guess whether the URL\n * string has been encoded or not. We have 2 potential strategies, and chose strategy two for the XxxClient constructors.\n *\n * ### Strategy One: Assume the customer URL string is not encoded, and always encode URL string in SDK.\n *\n * This is what legacy V2 SDK does, simple and works for most of the cases.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   SDK will encode it to \"http://account.blob.core.windows.net/con/b%253A\" and send to server. A blob named \"b%3A\" will be created.\n *\n * But this strategy will make it not possible to create a blob with \"?\" in it's name. Because when customer URL string is\n * \"http://account.blob.core.windows.net/con/blob?name\", the \"?name\" will be treated as URL paramter instead of blob name.\n * If customer URL string is \"http://account.blob.core.windows.net/con/blob%3Fname\", a blob named \"blob%3Fname\" will be created.\n * V2 SDK doesn't have this issue because it doesn't allow customer pass in a full URL, it accepts a separate blob name and encodeURIComponent for it.\n * We cannot accept a SDK cannot create a blob name with \"?\". So we implement strategy two:\n *\n * ### Strategy Two: SDK doesn't assume the URL has been encoded or not. It will just escape the special characters.\n *\n * This is what V10 Blob Go SDK does. It accepts a URL type in Go, and call url.EscapedPath() to escape the special chars unescaped.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b:\",\n *   SDK will escape \":\" like \"http://account.blob.core.windows.net/con/b%3A\" and send to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%3A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%3A\" to server. A blob named \"b:\" will be created.\n * - When customer URL string is \"http://account.blob.core.windows.net/con/b%253A\",\n *   There is no special characters, so send \"http://account.blob.core.windows.net/con/b%253A\" to server. A blob named \"b%3A\" will be created.\n *\n * This strategy gives us flexibility to create with any special characters. But \"%\" will be treated as a special characters, if the URL string\n * is not encoded, there shouldn't a \"%\" in the URL string, otherwise the URL is not a valid URL.\n * If customer needs to create a blob with \"%\" in it's blob name, use \"%25\" instead of \"%\". Just like above 3rd sample.\n * And following URL strings are invalid:\n * - \"http://account.blob.core.windows.net/con/b%\"\n * - \"http://account.blob.core.windows.net/con/b%2\"\n * - \"http://account.blob.core.windows.net/con/b%G\"\n *\n * Another special character is \"?\", use \"%2F\" to represent a blob name with \"?\" in a URL string.\n *\n * ### Strategy for containerName, blobName or other specific XXXName parameters in methods such as `containerClient.getBlobClient(blobName)`\n *\n * We will apply strategy one, and call encodeURIComponent for these parameters like blobName. Because what customers passes in is a plain name instead of a URL.\n *\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-containers--blobs--and-metadata\n * @see https://docs.microsoft.com/en-us/rest/api/storageservices/naming-and-referencing-shares--directories--files--and-metadata\n *\n * @param url -\n */\nexport function escapeURLPath(url: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let path = urlParsed.getPath();\n  path = path || \"/\";\n\n  path = escape(path);\n  urlParsed.setPath(path);\n\n  return urlParsed.toString();\n}\n\nexport interface ConnectionString {\n  kind: \"AccountConnString\" | \"SASConnString\";\n  url: string;\n  accountName: string;\n  accountKey?: any;\n  accountSas?: string;\n  proxyUri?: string; // Development Connection String may contain proxyUri\n}\n\nfunction getProxyUriFromDevConnString(connectionString: string): string {\n  // Development Connection String\n  // https://docs.microsoft.com/en-us/azure/storage/common/storage-configure-connection-string#connect-to-the-emulator-account-using-the-well-known-account-name-and-key\n  let proxyUri = \"\";\n  if (connectionString.search(\"DevelopmentStorageProxyUri=\") !== -1) {\n    // CONNECTION_STRING=UseDevelopmentStorage=true;DevelopmentStorageProxyUri=http://myProxyUri\n    const matchCredentials = connectionString.split(\";\");\n    for (const element of matchCredentials) {\n      if (element.trim().startsWith(\"DevelopmentStorageProxyUri=\")) {\n        proxyUri = element.trim().match(\"DevelopmentStorageProxyUri=(.*)\")![1];\n      }\n    }\n  }\n  return proxyUri;\n}\n\nexport function getValueInConnString(\n  connectionString: string,\n  argument:\n    | \"BlobEndpoint\"\n    | \"AccountName\"\n    | \"AccountKey\"\n    | \"DefaultEndpointsProtocol\"\n    | \"EndpointSuffix\"\n    | \"SharedAccessSignature\"\n): string {\n  const elements = connectionString.split(\";\");\n  for (const element of elements) {\n    if (element.trim().startsWith(argument)) {\n      return element.trim().match(argument + \"=(.*)\")![1];\n    }\n  }\n  return \"\";\n}\n\n/**\n * Extracts the parts of an Azure Storage account connection string.\n *\n * @param connectionString - Connection string.\n * @returns String key value pairs of the storage account's url and credentials.\n */\nexport function extractConnectionStringParts(connectionString: string): ConnectionString {\n  let proxyUri = \"\";\n\n  if (connectionString.startsWith(\"UseDevelopmentStorage=true\")) {\n    // Development connection string\n    proxyUri = getProxyUriFromDevConnString(connectionString);\n    connectionString = DevelopmentConnectionString;\n  }\n\n  // Matching BlobEndpoint in the Account connection string\n  let blobEndpoint = getValueInConnString(connectionString, \"BlobEndpoint\");\n  // Slicing off '/' at the end if exists\n  // (The methods that use `extractConnectionStringParts` expect the url to not have `/` at the end)\n  blobEndpoint = blobEndpoint.endsWith(\"/\") ? blobEndpoint.slice(0, -1) : blobEndpoint;\n\n  if (\n    connectionString.search(\"DefaultEndpointsProtocol=\") !== -1 &&\n    connectionString.search(\"AccountKey=\") !== -1\n  ) {\n    // Account connection string\n\n    let defaultEndpointsProtocol = \"\";\n    let accountName = \"\";\n    let accountKey = Buffer.from(\"accountKey\", \"base64\");\n    let endpointSuffix = \"\";\n\n    // Get account name and key\n    accountName = getValueInConnString(connectionString, \"AccountName\");\n    accountKey = Buffer.from(getValueInConnString(connectionString, \"AccountKey\"), \"base64\");\n\n    if (!blobEndpoint) {\n      // BlobEndpoint is not present in the Account connection string\n      // Can be obtained from `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`\n\n      defaultEndpointsProtocol = getValueInConnString(connectionString, \"DefaultEndpointsProtocol\");\n      const protocol = defaultEndpointsProtocol!.toLowerCase();\n      if (protocol !== \"https\" && protocol !== \"http\") {\n        throw new Error(\n          \"Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'\"\n        );\n      }\n\n      endpointSuffix = getValueInConnString(connectionString, \"EndpointSuffix\");\n      if (!endpointSuffix) {\n        throw new Error(\"Invalid EndpointSuffix in the provided Connection String\");\n      }\n      blobEndpoint = `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n    }\n\n    if (!accountName) {\n      throw new Error(\"Invalid AccountName in the provided Connection String\");\n    } else if (accountKey.length === 0) {\n      throw new Error(\"Invalid AccountKey in the provided Connection String\");\n    }\n\n    return {\n      kind: \"AccountConnString\",\n      url: blobEndpoint,\n      accountName,\n      accountKey,\n      proxyUri,\n    };\n  } else {\n    // SAS connection string\n\n    const accountSas = getValueInConnString(connectionString, \"SharedAccessSignature\");\n    const accountName = getAccountNameFromUrl(blobEndpoint);\n    if (!blobEndpoint) {\n      throw new Error(\"Invalid BlobEndpoint in the provided SAS Connection String\");\n    } else if (!accountSas) {\n      throw new Error(\"Invalid SharedAccessSignature in the provided SAS Connection String\");\n    }\n\n    return { kind: \"SASConnString\", url: blobEndpoint, accountName, accountSas };\n  }\n}\n\n/**\n * Internal escape method implemented Strategy Two mentioned in escapeURL() description.\n *\n * @param text -\n */\nfunction escape(text: string): string {\n  return encodeURIComponent(text)\n    .replace(/%2F/g, \"/\") // Don't escape for \"/\"\n    .replace(/'/g, \"%27\") // Escape for \"'\"\n    .replace(/\\+/g, \"%20\")\n    .replace(/%25/g, \"%\"); // Revert encoded \"%\"\n}\n\n/**\n * Append a string to URL path. Will remove duplicated \"/\" in front of the string\n * when URL path ends with a \"/\".\n *\n * @param url - Source URL string\n * @param name - String to be appended to URL\n * @returns An updated URL string\n */\nexport function appendToURLPath(url: string, name: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let path = urlParsed.getPath();\n  path = path ? (path.endsWith(\"/\") ? `${path}${name}` : `${path}/${name}`) : name;\n  urlParsed.setPath(path);\n\n  const normalizedUrl = new URL(urlParsed.toString());\n\n  return normalizedUrl.toString();\n}\n\n/**\n * Set URL parameter name and value. If name exists in URL parameters, old value\n * will be replaced by name key. If not provide value, the parameter will be deleted.\n *\n * @param url - Source URL string\n * @param name - Parameter name\n * @param value - Parameter value\n * @returns An updated URL string\n */\nexport function setURLParameter(url: string, name: string, value?: string): string {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setQueryParameter(name, value);\n  return urlParsed.toString();\n}\n\n/**\n * Get URL parameter by name.\n *\n * @param url -\n * @param name -\n */\nexport function getURLParameter(url: string, name: string): string | string[] | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getQueryParameterValue(name);\n}\n\n/**\n * Set URL host.\n *\n * @param url - Source URL string\n * @param host - New host string\n * @returns An updated URL string\n */\nexport function setURLHost(url: string, host: string): string {\n  const urlParsed = URLBuilder.parse(url);\n  urlParsed.setHost(host);\n  return urlParsed.toString();\n}\n\n/**\n * Get URL path from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPath(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getPath();\n}\n\n/**\n * Get URL scheme from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLScheme(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  return urlParsed.getScheme();\n}\n\n/**\n * Get URL path and query from an URL string.\n *\n * @param url - Source URL string\n */\nexport function getURLPathAndQuery(url: string): string | undefined {\n  const urlParsed = URLBuilder.parse(url);\n  const pathString = urlParsed.getPath();\n  if (!pathString) {\n    throw new RangeError(\"Invalid url without valid path.\");\n  }\n\n  let queryString = urlParsed.getQuery() || \"\";\n  queryString = queryString.trim();\n  if (queryString !== \"\") {\n    queryString = queryString.startsWith(\"?\") ? queryString : `?${queryString}`; // Ensure query string start with '?'\n  }\n\n  return `${pathString}${queryString}`;\n}\n\n/**\n * Get URL query key value pairs from an URL string.\n *\n * @param url -\n */\nexport function getURLQueries(url: string): { [key: string]: string } {\n  let queryString = URLBuilder.parse(url).getQuery();\n  if (!queryString) {\n    return {};\n  }\n\n  queryString = queryString.trim();\n  queryString = queryString.startsWith(\"?\") ? queryString.substr(1) : queryString;\n\n  let querySubStrings: string[] = queryString.split(\"&\");\n  querySubStrings = querySubStrings.filter((value: string) => {\n    const indexOfEqual = value.indexOf(\"=\");\n    const lastIndexOfEqual = value.lastIndexOf(\"=\");\n    return (\n      indexOfEqual > 0 && indexOfEqual === lastIndexOfEqual && lastIndexOfEqual < value.length - 1\n    );\n  });\n\n  const queries: { [key: string]: string } = {};\n  for (const querySubString of querySubStrings) {\n    const splitResults = querySubString.split(\"=\");\n    const key: string = splitResults[0];\n    const value: string = splitResults[1];\n    queries[key] = value;\n  }\n\n  return queries;\n}\n\n/**\n * Append a string to URL query.\n *\n * @param url - Source URL string.\n * @param queryParts - String to be appended to the URL query.\n * @returns An updated URL string.\n */\nexport function appendToURLQuery(url: string, queryParts: string): string {\n  const urlParsed = URLBuilder.parse(url);\n\n  let query = urlParsed.getQuery();\n  if (query) {\n    query += \"&\" + queryParts;\n  } else {\n    query = queryParts;\n  }\n\n  urlParsed.setQuery(query);\n  return urlParsed.toString();\n}\n\n/**\n * Rounds a date off to seconds.\n *\n * @param date -\n * @param withMilliseconds - If true, YYYY-MM-DDThh:mm:ss.fffffffZ will be returned;\n *                                          If false, YYYY-MM-DDThh:mm:ssZ will be returned.\n * @returns Date string in ISO8061 format, with or without 7 milliseconds component\n */\nexport function truncatedISO8061Date(date: Date, withMilliseconds: boolean = true): string {\n  // Date.toISOString() will return like \"2018-10-29T06:34:36.139Z\"\n  const dateString = date.toISOString();\n\n  return withMilliseconds\n    ? dateString.substring(0, dateString.length - 1) + \"0000\" + \"Z\"\n    : dateString.substring(0, dateString.length - 5) + \"Z\";\n}\n\n/**\n * Base64 encode.\n *\n * @param content -\n */\nexport function base64encode(content: string): string {\n  return !isNode ? btoa(content) : Buffer.from(content).toString(\"base64\");\n}\n\n/**\n * Base64 decode.\n *\n * @param encodedString -\n */\nexport function base64decode(encodedString: string): string {\n  return !isNode ? atob(encodedString) : Buffer.from(encodedString, \"base64\").toString();\n}\n\n/**\n * Generate a 64 bytes base64 block ID string.\n *\n * @param blockIndex -\n */\nexport function generateBlockID(blockIDPrefix: string, blockIndex: number): string {\n  // To generate a 64 bytes base64 string, source string should be 48\n  const maxSourceStringLength = 48;\n\n  // A blob can have a maximum of 100,000 uncommitted blocks at any given time\n  const maxBlockIndexLength = 6;\n\n  const maxAllowedBlockIDPrefixLength = maxSourceStringLength - maxBlockIndexLength;\n\n  if (blockIDPrefix.length > maxAllowedBlockIDPrefixLength) {\n    blockIDPrefix = blockIDPrefix.slice(0, maxAllowedBlockIDPrefixLength);\n  }\n  const res =\n    blockIDPrefix +\n    padStart(blockIndex.toString(), maxSourceStringLength - blockIDPrefix.length, \"0\");\n  return base64encode(res);\n}\n\n/**\n * Delay specified time interval.\n *\n * @param timeInMs -\n * @param aborter -\n * @param abortError -\n */\nexport async function delay(\n  timeInMs: number,\n  aborter?: AbortSignalLike,\n  abortError?: Error\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    /* eslint-disable-next-line prefer-const */\n    let timeout: any;\n\n    const abortHandler = () => {\n      if (timeout !== undefined) {\n        clearTimeout(timeout);\n      }\n      reject(abortError);\n    };\n\n    const resolveHandler = () => {\n      if (aborter !== undefined) {\n        aborter.removeEventListener(\"abort\", abortHandler);\n      }\n      resolve();\n    };\n\n    timeout = setTimeout(resolveHandler, timeInMs);\n\n    if (aborter !== undefined) {\n      aborter.addEventListener(\"abort\", abortHandler);\n    }\n  });\n}\n\n/**\n * String.prototype.padStart()\n *\n * @param currentString -\n * @param targetLength -\n * @param padString -\n */\nexport function padStart(\n  currentString: string,\n  targetLength: number,\n  padString: string = \" \"\n): string {\n  // @ts-expect-error: TS doesn't know this code needs to run downlevel sometimes\n  if (String.prototype.padStart) {\n    return currentString.padStart(targetLength, padString);\n  }\n\n  padString = padString || \" \";\n  if (currentString.length > targetLength) {\n    return currentString;\n  } else {\n    targetLength = targetLength - currentString.length;\n    if (targetLength > padString.length) {\n      padString += padString.repeat(targetLength / padString.length);\n    }\n    return padString.slice(0, targetLength) + currentString;\n  }\n}\n\nexport function sanitizeURL(url: string): string {\n  let safeURL: string = url;\n  if (getURLParameter(safeURL, URLConstants.Parameters.SIGNATURE)) {\n    safeURL = setURLParameter(safeURL, URLConstants.Parameters.SIGNATURE, \"*****\");\n  }\n\n  return safeURL;\n}\n\nexport function sanitizeHeaders(originalHeader: HttpHeaders): HttpHeaders {\n  const headers: HttpHeaders = new HttpHeaders();\n  for (const header of originalHeader.headersArray()) {\n    if (header.name.toLowerCase() === HeaderConstants.AUTHORIZATION.toLowerCase()) {\n      headers.set(header.name, \"*****\");\n    } else if (header.name.toLowerCase() === HeaderConstants.X_MS_COPY_SOURCE) {\n      headers.set(header.name, sanitizeURL(header.value));\n    } else {\n      headers.set(header.name, header.value);\n    }\n  }\n\n  return headers;\n}\n/**\n * If two strings are equal when compared case insensitive.\n *\n * @param str1 -\n * @param str2 -\n */\nexport function iEqual(str1: string, str2: string): boolean {\n  return str1.toLocaleLowerCase() === str2.toLocaleLowerCase();\n}\n\n/**\n * Extracts account name from the url\n * @param url - url to extract the account name from\n * @returns with the account name\n */\nexport function getAccountNameFromUrl(url: string): string {\n  const parsedUrl: URLBuilder = URLBuilder.parse(url);\n  let accountName;\n  try {\n    if (parsedUrl.getHost()!.split(\".\")[1] === \"blob\") {\n      // `${defaultEndpointsProtocol}://${accountName}.blob.${endpointSuffix}`;\n      accountName = parsedUrl.getHost()!.split(\".\")[0];\n    } else if (isIpEndpointStyle(parsedUrl)) {\n      // IPv4/IPv6 address hosts... Example - http://192.0.0.10:10001/devstoreaccount1/\n      // Single word domain without a [dot] in the endpoint... Example - http://localhost:10001/devstoreaccount1/\n      // .getPath() -> /devstoreaccount1/\n      accountName = parsedUrl.getPath()!.split(\"/\")[1];\n    } else {\n      // Custom domain case: \"https://customdomain.com/containername/blob\".\n      accountName = \"\";\n    }\n    return accountName;\n  } catch (error: any) {\n    throw new Error(\"Unable to extract accountName with provided information.\");\n  }\n}\n\nexport function isIpEndpointStyle(parsedUrl: URLBuilder): boolean {\n  if (parsedUrl.getHost() === undefined) {\n    return false;\n  }\n\n  const host =\n    parsedUrl.getHost()! + (parsedUrl.getPort() === undefined ? \"\" : \":\" + parsedUrl.getPort());\n\n  // Case 1: Ipv6, use a broad regex to find out candidates whose host contains two ':'.\n  // Case 2: localhost(:port), use broad regex to match port part.\n  // Case 3: Ipv4, use broad regex which just check if host contains Ipv4.\n  // For valid host please refer to https://man7.org/linux/man-pages/man7/hostname.7.html.\n  return (\n    /^.*:.*:.*$|^localhost(:[0-9]+)?$|^(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])){3}(:[0-9]+)?$/.test(\n      host\n    ) ||\n    (parsedUrl.getPort() !== undefined && PathStylePorts.includes(parsedUrl.getPort()!))\n  );\n}\n\n/**\n * Convert Tags to encoded string.\n *\n * @param tags -\n */\nexport function toBlobTagsString(tags?: Tags): string | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const tagPairs = [];\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      tagPairs.push(`${encodeURIComponent(key)}=${encodeURIComponent(value)}`);\n    }\n  }\n\n  return tagPairs.join(\"&\");\n}\n\n/**\n * Convert Tags type to BlobTags.\n *\n * @param tags -\n */\nexport function toBlobTags(tags?: Tags): BlobTags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: BlobTags = {\n    blobTagSet: [],\n  };\n\n  for (const key in tags) {\n    if (Object.prototype.hasOwnProperty.call(tags, key)) {\n      const value = tags[key];\n      res.blobTagSet.push({\n        key,\n        value,\n      });\n    }\n  }\n  return res;\n}\n\n/**\n * Covert BlobTags to Tags type.\n *\n * @param tags -\n */\nexport function toTags(tags?: BlobTags): Tags | undefined {\n  if (tags === undefined) {\n    return undefined;\n  }\n\n  const res: Tags = {};\n  for (const blobTag of tags.blobTagSet) {\n    res[blobTag.key] = blobTag.value;\n  }\n  return res;\n}\n\n/**\n * Convert BlobQueryTextConfiguration to QuerySerialization type.\n *\n * @param textConfiguration -\n */\nexport function toQuerySerialization(\n  textConfiguration?:\n    | BlobQueryJsonTextConfiguration\n    | BlobQueryCsvTextConfiguration\n    | BlobQueryArrowConfiguration\n    | BlobQueryParquetConfiguration\n): QuerySerialization | undefined {\n  if (textConfiguration === undefined) {\n    return undefined;\n  }\n\n  switch (textConfiguration.kind) {\n    case \"csv\":\n      return {\n        format: {\n          type: \"delimited\",\n          delimitedTextConfiguration: {\n            columnSeparator: textConfiguration.columnSeparator || \",\",\n            fieldQuote: textConfiguration.fieldQuote || \"\",\n            recordSeparator: textConfiguration.recordSeparator,\n            escapeChar: textConfiguration.escapeCharacter || \"\",\n            headersPresent: textConfiguration.hasHeaders || false,\n          },\n        },\n      };\n    case \"json\":\n      return {\n        format: {\n          type: \"json\",\n          jsonTextConfiguration: {\n            recordSeparator: textConfiguration.recordSeparator,\n          },\n        },\n      };\n    case \"arrow\":\n      return {\n        format: {\n          type: \"arrow\",\n          arrowConfiguration: {\n            schema: textConfiguration.schema,\n          },\n        },\n      };\n    case \"parquet\":\n      return {\n        format: {\n          type: \"parquet\",\n        },\n      };\n\n    default:\n      throw Error(\"Invalid BlobQueryTextConfiguration.\");\n  }\n}\n\nexport function parseObjectReplicationRecord(\n  objectReplicationRecord?: Record<string, string>\n): ObjectReplicationPolicy[] | undefined {\n  if (!objectReplicationRecord) {\n    return undefined;\n  }\n\n  if (\"policy-id\" in objectReplicationRecord) {\n    // If the dictionary contains a key with policy id, we are not required to do any parsing since\n    // the policy id should already be stored in the ObjectReplicationDestinationPolicyId.\n    return undefined;\n  }\n\n  const orProperties: ObjectReplicationPolicy[] = [];\n  for (const key in objectReplicationRecord) {\n    const ids = key.split(\"_\");\n    const policyPrefix = \"or-\";\n    if (ids[0].startsWith(policyPrefix)) {\n      ids[0] = ids[0].substring(policyPrefix.length);\n    }\n    const rule: ObjectReplicationRule = {\n      ruleId: ids[1],\n      replicationStatus: objectReplicationRecord[key] as ObjectReplicationStatus,\n    };\n    const policyIndex = orProperties.findIndex((policy) => policy.policyId === ids[0]);\n    if (policyIndex > -1) {\n      orProperties[policyIndex].rules.push(rule);\n    } else {\n      orProperties.push({\n        policyId: ids[0],\n        rules: [rule],\n      });\n    }\n  }\n  return orProperties;\n}\n\n/**\n * Attach a TokenCredential to an object.\n *\n * @param thing -\n * @param credential -\n */\nexport function attachCredential<T>(thing: T, credential: TokenCredential): T {\n  (thing as any).credential = credential;\n  return thing;\n}\n\nexport function httpAuthorizationToString(\n  httpAuthorization?: HttpAuthorization\n): string | undefined {\n  return httpAuthorization ? httpAuthorization.scheme + \" \" + httpAuthorization.value : undefined;\n}\n\nexport function BlobNameToString(name: BlobName): string {\n  if (name.encoded) {\n    return decodeURIComponent(name.content!);\n  } else {\n    return name.content!;\n  }\n}\n\nexport function ConvertInternalResponseOfListBlobFlat(\n  internalResponse: ListBlobsFlatSegmentResponse\n): ListBlobsFlatSegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nexport function ConvertInternalResponseOfListBlobHierarchy(\n  internalResponse: ListBlobsHierarchySegmentResponse\n): ListBlobsHierarchySegmentResponseModel {\n  return {\n    ...internalResponse,\n    segment: {\n      blobPrefixes: internalResponse.segment.blobPrefixes?.map((blobPrefixInternal) => {\n        const blobPrefix: BlobPrefixModel = {\n          name: BlobNameToString(blobPrefixInternal.name),\n        };\n        return blobPrefix;\n      }),\n      blobItems: internalResponse.segment.blobItems.map((blobItemInteral) => {\n        const blobItem: BlobItemInternalModel = {\n          ...blobItemInteral,\n          name: BlobNameToString(blobItemInteral.name),\n        };\n        return blobItem;\n      }),\n    },\n  };\n}\n\nexport function* ExtractPageRangeInfoItems(\n  getPageRangesSegment: PageBlobGetPageRangesDiffResponseModel\n): IterableIterator<PageRangeInfo> {\n  let pageRange: PageRange[] = [];\n  let clearRange: ClearRange[] = [];\n\n  if (getPageRangesSegment.pageRange) pageRange = getPageRangesSegment.pageRange;\n  if (getPageRangesSegment.clearRange) clearRange = getPageRangesSegment.clearRange;\n\n  let pageRangeIndex = 0;\n  let clearRangeIndex = 0;\n\n  while (pageRangeIndex < pageRange.length && clearRangeIndex < clearRange.length) {\n    if (pageRange[pageRangeIndex].start < clearRange[clearRangeIndex].start) {\n      yield {\n        start: pageRange[pageRangeIndex].start,\n        end: pageRange[pageRangeIndex].end,\n        isClear: false,\n      };\n      ++pageRangeIndex;\n    } else {\n      yield {\n        start: clearRange[clearRangeIndex].start,\n        end: clearRange[clearRangeIndex].end,\n        isClear: true,\n      };\n      ++clearRangeIndex;\n    }\n  }\n\n  for (; pageRangeIndex < pageRange.length; ++pageRangeIndex) {\n    yield {\n      start: pageRange[pageRangeIndex].start,\n      end: pageRange[pageRangeIndex].end,\n      isClear: false,\n    };\n  }\n\n  for (; clearRangeIndex < clearRange.length; ++clearRangeIndex) {\n    yield {\n      start: clearRange[clearRangeIndex].start,\n      end: clearRange[clearRangeIndex].end,\n      isClear: true,\n    };\n  }\n}\n\n/**\n * Escape the blobName but keep path separator ('/').\n */\nexport function EscapePath(blobName: string): string {\n  const split = blobName.split(\"/\");\n  for (let i = 0; i < split.length; i++) {\n    split[i] = encodeURIComponent(split[i]);\n  }\n  return split.join(\"/\");\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}