{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n/**\n * States for Batch.\n */\n\nvar BatchStates;\n\n(function (BatchStates) {\n  BatchStates[BatchStates[\"Good\"] = 0] = \"Good\";\n  BatchStates[BatchStates[\"Error\"] = 1] = \"Error\";\n})(BatchStates || (BatchStates = {}));\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\n\n\nexport class Batch {\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  constructor() {\n    let concurrency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n\n    /**\n     * Number of active operations under execution.\n     */\n    this.actives = 0;\n    /**\n     * Number of completed operations under execution.\n     */\n\n    this.completed = 0;\n    /**\n     * Offset of next operation to be executed.\n     */\n\n    this.offset = 0;\n    /**\n     * Operation array to be executed.\n     */\n\n    this.operations = [];\n    /**\n     * States of Batch. When an error happens, state will turn into error.\n     * Batch will stop execute left operations.\n     */\n\n    this.state = BatchStates.Good;\n\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n\n\n  addOperation(operation) {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n\n\n  async do() {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n    return new Promise((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n      this.emitter.on(\"error\", error => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n\n\n  nextOperation() {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n\n    return null;\n  }\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n\n\n  parallelExecute() {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../../src/utils/Batch.ts"],"names":[],"mappings":"AAAA;AACA;AAEA;AACA;AACA,SAAS,YAAT,QAA6B,QAA7B;AAOA;;AAEG;;AACH,IAAK,WAAL;;AAAA,CAAA,UAAK,WAAL,EAAgB;AACd,EAAA,WAAA,CAAA,WAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACA,EAAA,WAAA,CAAA,WAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACD,CAHD,EAAK,WAAW,KAAX,WAAW,GAAA,EAAA,CAAhB;AAKA;;;;AAIG;;;AACH,OAAM,MAAO,KAAP,CAAY;AAqChB;;;AAGG;AACH,EAAA,WAAA,GAA0C;AAAA,QAAvB,WAAuB,uEAAD,CAAC;;AAnC1C;;AAEG;AACK,SAAA,OAAA,GAAkB,CAAlB;AAER;;AAEG;;AACK,SAAA,SAAA,GAAoB,CAApB;AAER;;AAEG;;AACK,SAAA,MAAA,GAAiB,CAAjB;AAER;;AAEG;;AACK,SAAA,UAAA,GAA0B,EAA1B;AAER;;;AAGG;;AACK,SAAA,KAAA,GAAqB,WAAW,CAAC,IAAjC;;AAYN,QAAI,WAAW,GAAG,CAAlB,EAAqB;AACnB,YAAM,IAAI,UAAJ,CAAe,mCAAf,CAAN;AACD;;AACD,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,OAAL,GAAe,IAAI,YAAJ,EAAf;AACD;AAED;;;;AAIG;;;AACI,EAAA,YAAY,CAAC,SAAD,EAAqB;AACtC,SAAK,UAAL,CAAgB,IAAhB,CAAqB,YAAW;AAC9B,UAAI;AACF,aAAK,OAAL;AACA,cAAM,SAAS,EAAf;AACA,aAAK,OAAL;AACA,aAAK,SAAL;AACA,aAAK,eAAL;AACD,OAND,CAME,OAAO,KAAP,EAAmB;AACnB,aAAK,OAAL,CAAa,IAAb,CAAkB,OAAlB,EAA2B,KAA3B;AACD;AACF,KAVD;AAWD;AAED;;;AAGG;;;AACY,QAAF,EAAE,GAAA;AACb,QAAI,KAAK,UAAL,CAAgB,MAAhB,KAA2B,CAA/B,EAAkC;AAChC,aAAO,OAAO,CAAC,OAAR,EAAP;AACD;;AAED,SAAK,eAAL;AAEA,WAAO,IAAI,OAAJ,CAAkB,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC3C,WAAK,OAAL,CAAa,EAAb,CAAgB,QAAhB,EAA0B,OAA1B;AAEA,WAAK,OAAL,CAAa,EAAb,CAAgB,OAAhB,EAA0B,KAAD,IAAU;AACjC,aAAK,KAAL,GAAa,WAAW,CAAC,KAAzB;AACA,QAAA,MAAM,CAAC,KAAD,CAAN;AACD,OAHD;AAID,KAPM,CAAP;AAQD;AAED;;;AAGG;;;AACK,EAAA,aAAa,GAAA;AACnB,QAAI,KAAK,MAAL,GAAc,KAAK,UAAL,CAAgB,MAAlC,EAA0C;AACxC,aAAO,KAAK,UAAL,CAAgB,KAAK,MAAL,EAAhB,CAAP;AACD;;AACD,WAAO,IAAP;AACD;AAED;;;;AAIG;;;AACK,EAAA,eAAe,GAAA;AACrB,QAAI,KAAK,KAAL,KAAe,WAAW,CAAC,KAA/B,EAAsC;AACpC;AACD;;AAED,QAAI,KAAK,SAAL,IAAkB,KAAK,UAAL,CAAgB,MAAtC,EAA8C;AAC5C,WAAK,OAAL,CAAa,IAAb,CAAkB,QAAlB;AACA;AACD;;AAED,WAAO,KAAK,OAAL,GAAe,KAAK,WAA3B,EAAwC;AACtC,YAAM,SAAS,GAAG,KAAK,aAAL,EAAlB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,SAAS;AACV,OAFD,MAEO;AACL;AACD;AACF;AACF;;AA3He","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n// In browser, during webpack or browserify bundling, this module will be replaced by 'events'\n// https://github.com/Gozala/events\nimport { EventEmitter } from \"events\";\n\n/**\n * Operation is an async function to be executed and managed by Batch.\n */\nexport declare type Operation = () => Promise<any>;\n\n/**\n * States for Batch.\n */\nenum BatchStates {\n  Good,\n  Error,\n}\n\n/**\n * Batch provides basic parallel execution with concurrency limits.\n * Will stop execute left operations when one of the executed operation throws an error.\n * But Batch cannot cancel ongoing operations, you need to cancel them by yourself.\n */\nexport class Batch {\n  /**\n   * Concurrency. Must be lager than 0.\n   */\n  private concurrency: number;\n\n  /**\n   * Number of active operations under execution.\n   */\n  private actives: number = 0;\n\n  /**\n   * Number of completed operations under execution.\n   */\n  private completed: number = 0;\n\n  /**\n   * Offset of next operation to be executed.\n   */\n  private offset: number = 0;\n\n  /**\n   * Operation array to be executed.\n   */\n  private operations: Operation[] = [];\n\n  /**\n   * States of Batch. When an error happens, state will turn into error.\n   * Batch will stop execute left operations.\n   */\n  private state: BatchStates = BatchStates.Good;\n\n  /**\n   * A private emitter used to pass events inside this class.\n   */\n  private emitter: EventEmitter;\n\n  /**\n   * Creates an instance of Batch.\n   * @param concurrency -\n   */\n  public constructor(concurrency: number = 5) {\n    if (concurrency < 1) {\n      throw new RangeError(\"concurrency must be larger than 0\");\n    }\n    this.concurrency = concurrency;\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Add a operation into queue.\n   *\n   * @param operation -\n   */\n  public addOperation(operation: Operation): void {\n    this.operations.push(async () => {\n      try {\n        this.actives++;\n        await operation();\n        this.actives--;\n        this.completed++;\n        this.parallelExecute();\n      } catch (error: any) {\n        this.emitter.emit(\"error\", error);\n      }\n    });\n  }\n\n  /**\n   * Start execute operations in the queue.\n   *\n   */\n  public async do(): Promise<void> {\n    if (this.operations.length === 0) {\n      return Promise.resolve();\n    }\n\n    this.parallelExecute();\n\n    return new Promise<void>((resolve, reject) => {\n      this.emitter.on(\"finish\", resolve);\n\n      this.emitter.on(\"error\", (error) => {\n        this.state = BatchStates.Error;\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Get next operation to be executed. Return null when reaching ends.\n   *\n   */\n  private nextOperation(): Operation | null {\n    if (this.offset < this.operations.length) {\n      return this.operations[this.offset++];\n    }\n    return null;\n  }\n\n  /**\n   * Start execute operations. One one the most important difference between\n   * this method with do() is that do() wraps as an sync method.\n   *\n   */\n  private parallelExecute(): void {\n    if (this.state === BatchStates.Error) {\n      return;\n    }\n\n    if (this.completed >= this.operations.length) {\n      this.emitter.emit(\"finish\");\n      return;\n    }\n\n    while (this.actives < this.concurrency) {\n      const operation = this.nextOperation();\n      if (operation) {\n        operation();\n      } else {\n        return;\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}