{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { HttpHeaders, isHttpHeadersLike } from \"./httpHeaders\";\nimport { Serializer } from \"./serializer\";\nimport { generateUuid } from \"./util/utils\";\nexport function isWebResourceLike(object) {\n  if (object && typeof object === \"object\") {\n    const castObject = object;\n\n    if (typeof castObject.url === \"string\" && typeof castObject.method === \"string\" && typeof castObject.headers === \"object\" && isHttpHeadersLike(castObject.headers) && typeof castObject.validateRequestProperties === \"function\" && typeof castObject.prepare === \"function\" && typeof castObject.clone === \"function\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Creates a new WebResource object.\n *\n * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary\n * properties to initiate a request.\n */\n\nexport class WebResource {\n  constructor(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {\n    this.streamResponseBody = streamResponseBody;\n    this.streamResponseStatusCodes = streamResponseStatusCodes;\n    this.url = url || \"\";\n    this.method = method || \"GET\";\n    this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);\n    this.body = body;\n    this.query = query;\n    this.formData = undefined;\n    this.withCredentials = withCredentials || false;\n    this.abortSignal = abortSignal;\n    this.timeout = timeout || 0;\n    this.onUploadProgress = onUploadProgress;\n    this.onDownloadProgress = onDownloadProgress;\n    this.proxySettings = proxySettings;\n    this.keepAlive = keepAlive;\n    this.decompressResponse = decompressResponse;\n    this.requestId = this.headers.get(\"x-ms-client-request-id\") || generateUuid();\n  }\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   */\n\n\n  validateRequestProperties() {\n    if (!this.method) {\n      throw new Error(\"WebResource.method is required.\");\n    }\n\n    if (!this.url) {\n      throw new Error(\"WebResource.url is required.\");\n    }\n  }\n  /**\n   * Prepares the request.\n   * @param options - Options to provide for preparing the request.\n   * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.\n   */\n\n\n  prepare(options) {\n    if (!options) {\n      throw new Error(\"options object is required\");\n    }\n\n    if (options.method === undefined || options.method === null || typeof options.method.valueOf() !== \"string\") {\n      throw new Error(\"options.method must be a string.\");\n    }\n\n    if (options.url && options.pathTemplate) {\n      throw new Error(\"options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.\");\n    }\n\n    if ((options.pathTemplate === undefined || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== \"string\") && (options.url === undefined || options.url === null || typeof options.url.valueOf() !== \"string\")) {\n      throw new Error(\"Please provide exactly one of options.pathTemplate or options.url.\");\n    } // set the url if it is provided.\n\n\n    if (options.url) {\n      if (typeof options.url !== \"string\") {\n        throw new Error('options.url must be of type \"string\".');\n      }\n\n      this.url = options.url;\n    } // set the method\n\n\n    if (options.method) {\n      const validMethods = [\"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\", \"PATCH\", \"TRACE\"];\n\n      if (validMethods.indexOf(options.method.toUpperCase()) === -1) {\n        throw new Error('The provided method \"' + options.method + '\" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));\n      }\n    }\n\n    this.method = options.method.toUpperCase(); // construct the url if path template is provided\n\n    if (options.pathTemplate) {\n      const {\n        pathTemplate,\n        pathParameters\n      } = options;\n\n      if (typeof pathTemplate !== \"string\") {\n        throw new Error('options.pathTemplate must be of type \"string\".');\n      }\n\n      if (!options.baseUrl) {\n        options.baseUrl = \"https://management.azure.com\";\n      }\n\n      const baseUrl = options.baseUrl;\n      let url = baseUrl + (baseUrl.endsWith(\"/\") ? \"\" : \"/\") + (pathTemplate.startsWith(\"/\") ? pathTemplate.slice(1) : pathTemplate);\n      const segments = url.match(/({[\\w-]*\\s*[\\w-]*})/gi);\n\n      if (segments && segments.length) {\n        if (!pathParameters) {\n          throw new Error(`pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`);\n        }\n\n        segments.forEach(function (item) {\n          const pathParamName = item.slice(1, -1);\n          const pathParam = pathParameters[pathParamName];\n\n          if (pathParam === null || pathParam === undefined || !(typeof pathParam === \"string\" || typeof pathParam === \"object\")) {\n            const stringifiedPathParameters = JSON.stringify(pathParameters, undefined, 2);\n            throw new Error(`pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName}` + ` however, it is not present in parameters: ${stringifiedPathParameters}.` + `The value of the path parameter can either be a \"string\" of the form { ${pathParamName}: \"some sample value\" } or ` + `it can be an \"object\" of the form { \"${pathParamName}\": { value: \"some sample value\", skipUrlEncoding: true } }.`);\n          }\n\n          if (typeof pathParam.valueOf() === \"string\") {\n            url = url.replace(item, encodeURIComponent(pathParam));\n          }\n\n          if (typeof pathParam.valueOf() === \"object\") {\n            if (!pathParam.value) {\n              throw new Error(`options.pathParameters[${pathParamName}] is of type \"object\" but it does not contain a \"value\" property.`);\n            }\n\n            if (pathParam.skipUrlEncoding) {\n              url = url.replace(item, pathParam.value);\n            } else {\n              url = url.replace(item, encodeURIComponent(pathParam.value));\n            }\n          }\n        });\n      }\n\n      this.url = url;\n    } // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.\n\n\n    if (options.queryParameters) {\n      const queryParameters = options.queryParameters;\n\n      if (typeof queryParameters !== \"object\") {\n        throw new Error(`options.queryParameters must be of type object. It should be a JSON object ` + `of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. ` + `The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.`);\n      } // append question mark if it is not present in the url\n\n\n      if (this.url && this.url.indexOf(\"?\") === -1) {\n        this.url += \"?\";\n      } // construct queryString\n\n\n      const queryParams = []; // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().\n\n      this.query = {};\n\n      for (const queryParamName in queryParameters) {\n        const queryParam = queryParameters[queryParamName];\n\n        if (queryParam) {\n          if (typeof queryParam === \"string\") {\n            queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam));\n            this.query[queryParamName] = encodeURIComponent(queryParam);\n          } else if (typeof queryParam === \"object\") {\n            if (!queryParam.value) {\n              throw new Error(`options.queryParameters[${queryParamName}] is of type \"object\" but it does not contain a \"value\" property.`);\n            }\n\n            if (queryParam.skipUrlEncoding) {\n              queryParams.push(queryParamName + \"=\" + queryParam.value);\n              this.query[queryParamName] = queryParam.value;\n            } else {\n              queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam.value));\n              this.query[queryParamName] = encodeURIComponent(queryParam.value);\n            }\n          }\n        }\n      } // end-of-for\n      // append the queryString\n\n\n      this.url += queryParams.join(\"&\");\n    } // add headers to the request if they are provided\n\n\n    if (options.headers) {\n      const headers = options.headers;\n\n      for (const headerName of Object.keys(options.headers)) {\n        this.headers.set(headerName, headers[headerName]);\n      }\n    } // ensure accept-language is set correctly\n\n\n    if (!this.headers.get(\"accept-language\")) {\n      this.headers.set(\"accept-language\", \"en-US\");\n    } // ensure the request-id is set correctly\n\n\n    if (!this.headers.get(\"x-ms-client-request-id\") && !options.disableClientRequestId) {\n      this.headers.set(\"x-ms-client-request-id\", this.requestId);\n    } // default\n\n\n    if (!this.headers.get(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    } // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicitly\n\n\n    this.body = options.body;\n\n    if (options.body !== undefined && options.body !== null) {\n      // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.\n      if (options.bodyIsStream) {\n        if (!this.headers.get(\"Transfer-Encoding\")) {\n          this.headers.set(\"Transfer-Encoding\", \"chunked\");\n        }\n\n        if (this.headers.get(\"Content-Type\") !== \"application/octet-stream\") {\n          this.headers.set(\"Content-Type\", \"application/octet-stream\");\n        }\n      } else {\n        if (options.serializationMapper) {\n          this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, \"requestBody\");\n        }\n\n        if (!options.disableJsonStringifyOnBody) {\n          this.body = JSON.stringify(options.body);\n        }\n      }\n    }\n\n    if (options.spanOptions) {\n      this.spanOptions = options.spanOptions;\n    }\n\n    if (options.tracingContext) {\n      this.tracingContext = options.tracingContext;\n    }\n\n    this.abortSignal = options.abortSignal;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.onUploadProgress = options.onUploadProgress;\n    return this;\n  }\n  /**\n   * Clone this WebResource HTTP request object.\n   * @returns The clone of this WebResource HTTP request object.\n   */\n\n\n  clone() {\n    const result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);\n\n    if (this.formData) {\n      result.formData = this.formData;\n    }\n\n    if (this.operationSpec) {\n      result.operationSpec = this.operationSpec;\n    }\n\n    if (this.shouldDeserialize) {\n      result.shouldDeserialize = this.shouldDeserialize;\n    }\n\n    if (this.operationResponseGetter) {\n      result.operationResponseGetter = this.operationResponseGetter;\n    }\n\n    return result;\n  }\n\n}","map":{"version":3,"sources":["../../src/webResource.ts"],"names":[],"mappings":"AAAA;AACA;AAGA,SAAS,WAAT,EAAuC,iBAAvC,QAAgE,eAAhE;AACA,SAAiB,UAAjB,QAAmC,cAAnC;AAOA,SAAS,YAAT,QAA6B,cAA7B;AAuJA,OAAM,SAAU,iBAAV,CAA4B,MAA5B,EAA2C;AAC/C,MAAI,MAAM,IAAI,OAAO,MAAP,KAAkB,QAAhC,EAA0C;AACxC,UAAM,UAAU,GAAG,MAAnB;;AAQA,QACE,OAAO,UAAU,CAAC,GAAlB,KAA0B,QAA1B,IACA,OAAO,UAAU,CAAC,MAAlB,KAA6B,QAD7B,IAEA,OAAO,UAAU,CAAC,OAAlB,KAA8B,QAF9B,IAGA,iBAAiB,CAAC,UAAU,CAAC,OAAZ,CAHjB,IAIA,OAAO,UAAU,CAAC,yBAAlB,KAAgD,UAJhD,IAKA,OAAO,UAAU,CAAC,OAAlB,KAA8B,UAL9B,IAMA,OAAO,UAAU,CAAC,KAAlB,KAA4B,UAP9B,EAQE;AACA,aAAO,IAAP;AACD;AACF;;AACD,SAAO,KAAP;AACD;AAED;;;;;AAKG;;AACH,OAAM,MAAO,WAAP,CAAkB;AAsGtB,EAAA,WAAA,CACE,GADF,EAEE,MAFF,EAGE,IAHF,EAIE,KAJF,EAKE,OALF,EAME,kBANF,EAOE,eAPF,EAQE,WARF,EASE,OATF,EAUE,gBAVF,EAWE,kBAXF,EAYE,aAZF,EAaE,SAbF,EAcE,kBAdF,EAeE,yBAfF,EAeyC;AAEvC,SAAK,kBAAL,GAA0B,kBAA1B;AACA,SAAK,yBAAL,GAAiC,yBAAjC;AACA,SAAK,GAAL,GAAW,GAAG,IAAI,EAAlB;AACA,SAAK,MAAL,GAAc,MAAM,IAAI,KAAxB;AACA,SAAK,OAAL,GAAe,iBAAiB,CAAC,OAAD,CAAjB,GAA6B,OAA7B,GAAuC,IAAI,WAAJ,CAAgB,OAAhB,CAAtD;AACA,SAAK,IAAL,GAAY,IAAZ;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,QAAL,GAAgB,SAAhB;AACA,SAAK,eAAL,GAAuB,eAAe,IAAI,KAA1C;AACA,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,OAAL,GAAe,OAAO,IAAI,CAA1B;AACA,SAAK,gBAAL,GAAwB,gBAAxB;AACA,SAAK,kBAAL,GAA0B,kBAA1B;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,SAAL,GAAiB,SAAjB;AACA,SAAK,kBAAL,GAA0B,kBAA1B;AACA,SAAK,SAAL,GAAiB,KAAK,OAAL,CAAa,GAAb,CAAiB,wBAAjB,KAA8C,YAAY,EAA3E;AACD;AAED;;;;AAIG;;;AACH,EAAA,yBAAyB,GAAA;AACvB,QAAI,CAAC,KAAK,MAAV,EAAkB;AAChB,YAAM,IAAI,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,QAAI,CAAC,KAAK,GAAV,EAAe;AACb,YAAM,IAAI,KAAJ,CAAU,8BAAV,CAAN;AACD;AACF;AAED;;;;AAIG;;;AACH,EAAA,OAAO,CAAC,OAAD,EAA+B;AACpC,QAAI,CAAC,OAAL,EAAc;AACZ,YAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,QACE,OAAO,CAAC,MAAR,KAAmB,SAAnB,IACA,OAAO,CAAC,MAAR,KAAmB,IADnB,IAEA,OAAO,OAAO,CAAC,MAAR,CAAe,OAAf,EAAP,KAAoC,QAHtC,EAIE;AACA,YAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAED,QAAI,OAAO,CAAC,GAAR,IAAe,OAAO,CAAC,YAA3B,EAAyC;AACvC,YAAM,IAAI,KAAJ,CACJ,kGADI,CAAN;AAGD;;AAED,QACE,CAAC,OAAO,CAAC,YAAR,KAAyB,SAAzB,IACC,OAAO,CAAC,YAAR,KAAyB,IAD1B,IAEC,OAAO,OAAO,CAAC,YAAR,CAAqB,OAArB,EAAP,KAA0C,QAF5C,MAGC,OAAO,CAAC,GAAR,KAAgB,SAAhB,IACC,OAAO,CAAC,GAAR,KAAgB,IADjB,IAEC,OAAO,OAAO,CAAC,GAAR,CAAY,OAAZ,EAAP,KAAiC,QALnC,CADF,EAOE;AACA,YAAM,IAAI,KAAJ,CAAU,oEAAV,CAAN;AACD,KA5BmC,CA8BpC;;;AACA,QAAI,OAAO,CAAC,GAAZ,EAAiB;AACf,UAAI,OAAO,OAAO,CAAC,GAAf,KAAuB,QAA3B,EAAqC;AACnC,cAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;;AACD,WAAK,GAAL,GAAW,OAAO,CAAC,GAAnB;AACD,KApCmC,CAsCpC;;;AACA,QAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,YAAM,YAAY,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,QAAvB,EAAiC,SAAjC,EAA4C,MAA5C,EAAoD,OAApD,EAA6D,OAA7D,CAArB;;AACA,UAAI,YAAY,CAAC,OAAb,CAAqB,OAAO,CAAC,MAAR,CAAe,WAAf,EAArB,MAAuD,CAAC,CAA5D,EAA+D;AAC7D,cAAM,IAAI,KAAJ,CACJ,0BACE,OAAO,CAAC,MADV,GAEE,4CAFF,GAGE,IAAI,CAAC,SAAL,CAAe,YAAf,CAJE,CAAN;AAMD;AACF;;AACD,SAAK,MAAL,GAAc,OAAO,CAAC,MAAR,CAAe,WAAf,EAAd,CAlDoC,CAoDpC;;AACA,QAAI,OAAO,CAAC,YAAZ,EAA0B;AACxB,YAAM;AAAE,QAAA,YAAF;AAAgB,QAAA;AAAhB,UAAmC,OAAzC;;AACA,UAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AACpC,cAAM,IAAI,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,UAAI,CAAC,OAAO,CAAC,OAAb,EAAsB;AACpB,QAAA,OAAO,CAAC,OAAR,GAAkB,8BAAlB;AACD;;AACD,YAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;AACA,UAAI,GAAG,GACL,OAAO,IACN,OAAO,CAAC,QAAR,CAAiB,GAAjB,IAAwB,EAAxB,GAA6B,GADvB,CAAP,IAEC,YAAY,CAAC,UAAb,CAAwB,GAAxB,IAA+B,YAAY,CAAC,KAAb,CAAmB,CAAnB,CAA/B,GAAuD,YAFxD,CADF;AAIA,YAAM,QAAQ,GAAG,GAAG,CAAC,KAAJ,CAAU,uBAAV,CAAjB;;AACA,UAAI,QAAQ,IAAI,QAAQ,CAAC,MAAzB,EAAiC;AAC/B,YAAI,CAAC,cAAL,EAAqB;AACnB,gBAAM,IAAI,KAAJ,CACJ,iBAAiB,YAAY,0EADzB,CAAN;AAGD;;AACD,QAAA,QAAQ,CAAC,OAAT,CAAiB,UAAU,IAAV,EAAc;AAC7B,gBAAM,aAAa,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,CAAtB;AACA,gBAAM,SAAS,GAAI,cAAyC,CAAC,aAAD,CAA5D;;AACA,cACE,SAAS,KAAK,IAAd,IACA,SAAS,KAAK,SADd,IAEA,EAAE,OAAO,SAAP,KAAqB,QAArB,IAAiC,OAAO,SAAP,KAAqB,QAAxD,CAHF,EAIE;AACA,kBAAM,yBAAyB,GAAG,IAAI,CAAC,SAAL,CAAe,cAAf,EAA+B,SAA/B,EAA0C,CAA1C,CAAlC;AACA,kBAAM,IAAI,KAAJ,CACJ,iBAAiB,YAAY,gCAAgC,aAAa,EAA1E,GACE,8CAA8C,yBAAyB,GADzE,GAEE,0EAA0E,aAAa,6BAFzF,GAGE,wCAAwC,aAAa,6DAJnD,CAAN;AAMD;;AAED,cAAI,OAAO,SAAS,CAAC,OAAV,EAAP,KAA+B,QAAnC,EAA6C;AAC3C,YAAA,GAAG,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,kBAAkB,CAAC,SAAD,CAApC,CAAN;AACD;;AAED,cAAI,OAAO,SAAS,CAAC,OAAV,EAAP,KAA+B,QAAnC,EAA6C;AAC3C,gBAAI,CAAC,SAAS,CAAC,KAAf,EAAsB;AACpB,oBAAM,IAAI,KAAJ,CACJ,0BAA0B,aAAa,mEADnC,CAAN;AAGD;;AACD,gBAAI,SAAS,CAAC,eAAd,EAA+B;AAC7B,cAAA,GAAG,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,SAAS,CAAC,KAA5B,CAAN;AACD,aAFD,MAEO;AACL,cAAA,GAAG,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,kBAAkB,CAAC,SAAS,CAAC,KAAX,CAApC,CAAN;AACD;AACF;AACF,SAjCD;AAkCD;;AACD,WAAK,GAAL,GAAW,GAAX;AACD,KA7GmC,CA+GpC;;;AACA,QAAI,OAAO,CAAC,eAAZ,EAA6B;AAC3B,YAAM,eAAe,GAAG,OAAO,CAAC,eAAhC;;AACA,UAAI,OAAO,eAAP,KAA2B,QAA/B,EAAyC;AACvC,cAAM,IAAI,KAAJ,CACJ,6EAAA,GACE,qFADF,GAEE,2IAHE,CAAN;AAKD,OAR0B,CAS3B;;;AACA,UAAI,KAAK,GAAL,IAAY,KAAK,GAAL,CAAS,OAAT,CAAiB,GAAjB,MAA0B,CAAC,CAA3C,EAA8C;AAC5C,aAAK,GAAL,IAAY,GAAZ;AACD,OAZ0B,CAa3B;;;AACA,YAAM,WAAW,GAAG,EAApB,CAd2B,CAe3B;;AACA,WAAK,KAAL,GAAa,EAAb;;AACA,WAAK,MAAM,cAAX,IAA6B,eAA7B,EAA8C;AAC5C,cAAM,UAAU,GAAQ,eAAe,CAAC,cAAD,CAAvC;;AACA,YAAI,UAAJ,EAAgB;AACd,cAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAClC,YAAA,WAAW,CAAC,IAAZ,CAAiB,cAAc,GAAG,GAAjB,GAAuB,kBAAkB,CAAC,UAAD,CAA1D;AACA,iBAAK,KAAL,CAAW,cAAX,IAA6B,kBAAkB,CAAC,UAAD,CAA/C;AACD,WAHD,MAGO,IAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AACzC,gBAAI,CAAC,UAAU,CAAC,KAAhB,EAAuB;AACrB,oBAAM,IAAI,KAAJ,CACJ,2BAA2B,cAAc,mEADrC,CAAN;AAGD;;AACD,gBAAI,UAAU,CAAC,eAAf,EAAgC;AAC9B,cAAA,WAAW,CAAC,IAAZ,CAAiB,cAAc,GAAG,GAAjB,GAAuB,UAAU,CAAC,KAAnD;AACA,mBAAK,KAAL,CAAW,cAAX,IAA6B,UAAU,CAAC,KAAxC;AACD,aAHD,MAGO;AACL,cAAA,WAAW,CAAC,IAAZ,CAAiB,cAAc,GAAG,GAAjB,GAAuB,kBAAkB,CAAC,UAAU,CAAC,KAAZ,CAA1D;AACA,mBAAK,KAAL,CAAW,cAAX,IAA6B,kBAAkB,CAAC,UAAU,CAAC,KAAZ,CAA/C;AACD;AACF;AACF;AACF,OAtC0B,CAsCzB;AACF;;;AACA,WAAK,GAAL,IAAY,WAAW,CAAC,IAAZ,CAAiB,GAAjB,CAAZ;AACD,KAzJmC,CA2JpC;;;AACA,QAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,YAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;;AACA,WAAK,MAAM,UAAX,IAAyB,MAAM,CAAC,IAAP,CAAY,OAAO,CAAC,OAApB,CAAzB,EAAuD;AACrD,aAAK,OAAL,CAAa,GAAb,CAAiB,UAAjB,EAA6B,OAAO,CAAC,UAAD,CAApC;AACD;AACF,KAjKmC,CAkKpC;;;AACA,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,iBAAjB,CAAL,EAA0C;AACxC,WAAK,OAAL,CAAa,GAAb,CAAiB,iBAAjB,EAAoC,OAApC;AACD,KArKmC,CAsKpC;;;AACA,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,wBAAjB,CAAD,IAA+C,CAAC,OAAO,CAAC,sBAA5D,EAAoF;AAClF,WAAK,OAAL,CAAa,GAAb,CAAiB,wBAAjB,EAA2C,KAAK,SAAhD;AACD,KAzKmC,CA2KpC;;;AACA,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,cAAjB,CAAL,EAAuC;AACrC,WAAK,OAAL,CAAa,GAAb,CAAiB,cAAjB,EAAiC,iCAAjC;AACD,KA9KmC,CAgLpC;;;AACA,SAAK,IAAL,GAAY,OAAO,CAAC,IAApB;;AACA,QAAI,OAAO,CAAC,IAAR,KAAiB,SAAjB,IAA8B,OAAO,CAAC,IAAR,KAAiB,IAAnD,EAAyD;AACvD;AACA,UAAI,OAAO,CAAC,YAAZ,EAA0B;AACxB,YAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,mBAAjB,CAAL,EAA4C;AAC1C,eAAK,OAAL,CAAa,GAAb,CAAiB,mBAAjB,EAAsC,SAAtC;AACD;;AACD,YAAI,KAAK,OAAL,CAAa,GAAb,CAAiB,cAAjB,MAAqC,0BAAzC,EAAqE;AACnE,eAAK,OAAL,CAAa,GAAb,CAAiB,cAAjB,EAAiC,0BAAjC;AACD;AACF,OAPD,MAOO;AACL,YAAI,OAAO,CAAC,mBAAZ,EAAiC;AAC/B,eAAK,IAAL,GAAY,IAAI,UAAJ,CAAe,OAAO,CAAC,OAAvB,EAAgC,SAAhC,CACV,OAAO,CAAC,mBADE,EAEV,OAAO,CAAC,IAFE,EAGV,aAHU,CAAZ;AAKD;;AACD,YAAI,CAAC,OAAO,CAAC,0BAAb,EAAyC;AACvC,eAAK,IAAL,GAAY,IAAI,CAAC,SAAL,CAAe,OAAO,CAAC,IAAvB,CAAZ;AACD;AACF;AACF;;AAED,QAAI,OAAO,CAAC,WAAZ,EAAyB;AACvB,WAAK,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACD;;AAED,QAAI,OAAO,CAAC,cAAZ,EAA4B;AAC1B,WAAK,cAAL,GAAsB,OAAO,CAAC,cAA9B;AACD;;AAED,SAAK,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACA,SAAK,kBAAL,GAA0B,OAAO,CAAC,kBAAlC;AACA,SAAK,gBAAL,GAAwB,OAAO,CAAC,gBAAhC;AAEA,WAAO,IAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,KAAK,GAAA;AACH,UAAM,MAAM,GAAG,IAAI,WAAJ,CACb,KAAK,GADQ,EAEb,KAAK,MAFQ,EAGb,KAAK,IAHQ,EAIb,KAAK,KAJQ,EAKb,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,KAAb,EALH,EAMb,KAAK,kBANQ,EAOb,KAAK,eAPQ,EAQb,KAAK,WARQ,EASb,KAAK,OATQ,EAUb,KAAK,gBAVQ,EAWb,KAAK,kBAXQ,EAYb,KAAK,aAZQ,EAab,KAAK,SAbQ,EAcb,KAAK,kBAdQ,EAeb,KAAK,yBAfQ,CAAf;;AAkBA,QAAI,KAAK,QAAT,EAAmB;AACjB,MAAA,MAAM,CAAC,QAAP,GAAkB,KAAK,QAAvB;AACD;;AAED,QAAI,KAAK,aAAT,EAAwB;AACtB,MAAA,MAAM,CAAC,aAAP,GAAuB,KAAK,aAA5B;AACD;;AAED,QAAI,KAAK,iBAAT,EAA4B;AAC1B,MAAA,MAAM,CAAC,iBAAP,GAA2B,KAAK,iBAAhC;AACD;;AAED,QAAI,KAAK,uBAAT,EAAkC;AAChC,MAAA,MAAM,CAAC,uBAAP,GAAiC,KAAK,uBAAtC;AACD;;AAED,WAAO,MAAP;AACD;;AA7ZqB","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Context, SpanOptions } from \"@azure/core-tracing\";\nimport { HttpHeaders, HttpHeadersLike, isHttpHeadersLike } from \"./httpHeaders\";\nimport { Mapper, Serializer } from \"./serializer\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport { HttpOperationResponse } from \"./httpOperationResponse\";\nimport { OperationResponse } from \"./operationResponse\";\nimport { OperationSpec } from \"./operationSpec\";\nimport { ProxySettings } from \"./serviceClient\";\nimport { SerializerOptions } from \"./util/serializer.common\";\nimport { generateUuid } from \"./util/utils\";\n\n/**\n * List of supported HTTP methods.\n */\nexport type HttpMethods =\n  | \"GET\"\n  | \"PUT\"\n  | \"POST\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"HEAD\"\n  | \"OPTIONS\"\n  | \"TRACE\";\n\n/**\n * Possible HTTP request body types\n */\nexport type HttpRequestBody =\n  | Blob\n  | string\n  | ArrayBuffer\n  | ArrayBufferView\n  | (() => NodeJS.ReadableStream);\n\n/**\n * Fired in response to upload or download progress.\n */\nexport type TransferProgressEvent = {\n  /**\n   * The number of bytes loaded so far.\n   */\n  loadedBytes: number;\n};\n\n/**\n * A description of a HTTP request to be made to a remote server.\n */\nexport interface WebResourceLike {\n  /**\n   * The URL being accessed by the request.\n   */\n  url: string;\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method: HttpMethods;\n  /**\n   * The HTTP body contents of the request.\n   */\n  body?: any;\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   * @deprecated Use streamResponseStatusCodes property instead.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * A list of response status codes whose corresponding HttpOperationResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);\n  /**\n   * A function that returns the proper OperationResponse for the given OperationSpec and\n   * HttpOperationResponse combination. If this is undefined, then a simple status code lookup will\n   * be used.\n   */\n  operationResponseGetter?: (\n    operationSpec: OperationSpec,\n    response: HttpOperationResponse\n  ) => undefined | OperationResponse;\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: any;\n  /**\n   * A query string represented as an object.\n   */\n  query?: { [key: string]: any };\n  /**\n   * Used to parse the response.\n   */\n  operationSpec?: OperationSpec;\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   */\n  withCredentials: boolean;\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   */\n  timeout: number;\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * If the connection should be reused.\n   */\n  keepAlive?: boolean;\n  /**\n   * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)\n   */\n  decompressResponse?: boolean;\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId: string;\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Tracing: Context used when creating spans.\n   */\n  tracingContext?: Context;\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   */\n  validateRequestProperties(): void;\n\n  /**\n   * Sets options on the request.\n   */\n  prepare(options: RequestPrepareOptions): WebResourceLike;\n  /**\n   * Clone this request object.\n   */\n  clone(): WebResourceLike;\n}\n\nexport function isWebResourceLike(object: unknown): object is WebResourceLike {\n  if (object && typeof object === \"object\") {\n    const castObject = object as {\n      url: unknown;\n      method: unknown;\n      headers: unknown;\n      validateRequestProperties: unknown;\n      prepare: unknown;\n      clone: unknown;\n    };\n    if (\n      typeof castObject.url === \"string\" &&\n      typeof castObject.method === \"string\" &&\n      typeof castObject.headers === \"object\" &&\n      isHttpHeadersLike(castObject.headers) &&\n      typeof castObject.validateRequestProperties === \"function\" &&\n      typeof castObject.prepare === \"function\" &&\n      typeof castObject.clone === \"function\"\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Creates a new WebResource object.\n *\n * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary\n * properties to initiate a request.\n */\nexport class WebResource implements WebResourceLike {\n  /**\n   * URL of the outgoing request.\n   */\n  url: string;\n  /**\n   * HTTP method to use.\n   */\n  method: HttpMethods;\n  /**\n   * Request body.\n   */\n  body?: any;\n  /**\n   * HTTP headers.\n   */\n  headers: HttpHeadersLike;\n  /**\n   * Whether or not the body of the HttpOperationResponse should be treated as a stream.\n   * @deprecated Use streamResponseStatusCodes property instead.\n   */\n  streamResponseBody?: boolean;\n  /**\n   * A list of status codes whose corresponding HttpOperationResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);\n  /**\n   * A function that returns the proper OperationResponse for the given OperationSpec and\n   * HttpOperationResponse combination. If this is undefined, then a simple status code lookup will\n   * be used.\n   */\n  operationResponseGetter?: (\n    operationSpec: OperationSpec,\n    response: HttpOperationResponse\n  ) => undefined | OperationResponse;\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: any;\n  /**\n   * Query added to the URL.\n   */\n  query?: { [key: string]: any };\n  /**\n   * Specification of the HTTP request.\n   */\n  operationSpec?: OperationSpec;\n  /**\n   * Whether to send credentials (via cookies, authorization headers, or TLS client certificates) when making a request in the browser to a cross-site destination.\n   */\n  withCredentials: boolean;\n  /**\n   * How long to wait in milliseconds before aborting the request.\n   */\n  timeout: number;\n  /**\n   * What proxy to use, if necessary.\n   */\n  proxySettings?: ProxySettings;\n  /**\n   * Whether to keep the HTTP connections alive throughout requests.\n   */\n  keepAlive?: boolean;\n  /**\n   * Whether or not to decompress response according to Accept-Encoding header (node-fetch only)\n   */\n  decompressResponse?: boolean;\n  /**\n   * Unique identifier of the outgoing request.\n   */\n  requestId: string;\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Callback which fires upon download progress.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Tracing: Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n\n  /**\n   * Tracing: Context used when creating Spans.\n   */\n  tracingContext?: Context;\n\n  constructor(\n    url?: string,\n    method?: HttpMethods,\n    body?: unknown,\n    query?: { [key: string]: any },\n    headers?: { [key: string]: any } | HttpHeadersLike,\n    streamResponseBody?: boolean,\n    withCredentials?: boolean,\n    abortSignal?: AbortSignalLike,\n    timeout?: number,\n    onUploadProgress?: (progress: TransferProgressEvent) => void,\n    onDownloadProgress?: (progress: TransferProgressEvent) => void,\n    proxySettings?: ProxySettings,\n    keepAlive?: boolean,\n    decompressResponse?: boolean,\n    streamResponseStatusCodes?: Set<number>\n  ) {\n    this.streamResponseBody = streamResponseBody;\n    this.streamResponseStatusCodes = streamResponseStatusCodes;\n    this.url = url || \"\";\n    this.method = method || \"GET\";\n    this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);\n    this.body = body;\n    this.query = query;\n    this.formData = undefined;\n    this.withCredentials = withCredentials || false;\n    this.abortSignal = abortSignal;\n    this.timeout = timeout || 0;\n    this.onUploadProgress = onUploadProgress;\n    this.onDownloadProgress = onDownloadProgress;\n    this.proxySettings = proxySettings;\n    this.keepAlive = keepAlive;\n    this.decompressResponse = decompressResponse;\n    this.requestId = this.headers.get(\"x-ms-client-request-id\") || generateUuid();\n  }\n\n  /**\n   * Validates that the required properties such as method, url, headers[\"Content-Type\"],\n   * headers[\"accept-language\"] are defined. It will throw an error if one of the above\n   * mentioned properties are not defined.\n   */\n  validateRequestProperties(): void {\n    if (!this.method) {\n      throw new Error(\"WebResource.method is required.\");\n    }\n    if (!this.url) {\n      throw new Error(\"WebResource.url is required.\");\n    }\n  }\n\n  /**\n   * Prepares the request.\n   * @param options - Options to provide for preparing the request.\n   * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.\n   */\n  prepare(options: RequestPrepareOptions): WebResource {\n    if (!options) {\n      throw new Error(\"options object is required\");\n    }\n\n    if (\n      options.method === undefined ||\n      options.method === null ||\n      typeof options.method.valueOf() !== \"string\"\n    ) {\n      throw new Error(\"options.method must be a string.\");\n    }\n\n    if (options.url && options.pathTemplate) {\n      throw new Error(\n        \"options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.\"\n      );\n    }\n\n    if (\n      (options.pathTemplate === undefined ||\n        options.pathTemplate === null ||\n        typeof options.pathTemplate.valueOf() !== \"string\") &&\n      (options.url === undefined ||\n        options.url === null ||\n        typeof options.url.valueOf() !== \"string\")\n    ) {\n      throw new Error(\"Please provide exactly one of options.pathTemplate or options.url.\");\n    }\n\n    // set the url if it is provided.\n    if (options.url) {\n      if (typeof options.url !== \"string\") {\n        throw new Error('options.url must be of type \"string\".');\n      }\n      this.url = options.url;\n    }\n\n    // set the method\n    if (options.method) {\n      const validMethods = [\"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\", \"PATCH\", \"TRACE\"];\n      if (validMethods.indexOf(options.method.toUpperCase()) === -1) {\n        throw new Error(\n          'The provided method \"' +\n            options.method +\n            '\" is invalid. Supported HTTP methods are: ' +\n            JSON.stringify(validMethods)\n        );\n      }\n    }\n    this.method = options.method.toUpperCase() as HttpMethods;\n\n    // construct the url if path template is provided\n    if (options.pathTemplate) {\n      const { pathTemplate, pathParameters } = options;\n      if (typeof pathTemplate !== \"string\") {\n        throw new Error('options.pathTemplate must be of type \"string\".');\n      }\n      if (!options.baseUrl) {\n        options.baseUrl = \"https://management.azure.com\";\n      }\n      const baseUrl = options.baseUrl;\n      let url =\n        baseUrl +\n        (baseUrl.endsWith(\"/\") ? \"\" : \"/\") +\n        (pathTemplate.startsWith(\"/\") ? pathTemplate.slice(1) : pathTemplate);\n      const segments = url.match(/({[\\w-]*\\s*[\\w-]*})/gi);\n      if (segments && segments.length) {\n        if (!pathParameters) {\n          throw new Error(\n            `pathTemplate: ${pathTemplate} has been provided. Hence, options.pathParameters must also be provided.`\n          );\n        }\n        segments.forEach(function (item) {\n          const pathParamName = item.slice(1, -1);\n          const pathParam = (pathParameters as { [key: string]: any })[pathParamName];\n          if (\n            pathParam === null ||\n            pathParam === undefined ||\n            !(typeof pathParam === \"string\" || typeof pathParam === \"object\")\n          ) {\n            const stringifiedPathParameters = JSON.stringify(pathParameters, undefined, 2);\n            throw new Error(\n              `pathTemplate: ${pathTemplate} contains the path parameter ${pathParamName}` +\n                ` however, it is not present in parameters: ${stringifiedPathParameters}.` +\n                `The value of the path parameter can either be a \"string\" of the form { ${pathParamName}: \"some sample value\" } or ` +\n                `it can be an \"object\" of the form { \"${pathParamName}\": { value: \"some sample value\", skipUrlEncoding: true } }.`\n            );\n          }\n\n          if (typeof pathParam.valueOf() === \"string\") {\n            url = url.replace(item, encodeURIComponent(pathParam));\n          }\n\n          if (typeof pathParam.valueOf() === \"object\") {\n            if (!pathParam.value) {\n              throw new Error(\n                `options.pathParameters[${pathParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (pathParam.skipUrlEncoding) {\n              url = url.replace(item, pathParam.value);\n            } else {\n              url = url.replace(item, encodeURIComponent(pathParam.value));\n            }\n          }\n        });\n      }\n      this.url = url;\n    }\n\n    // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.\n    if (options.queryParameters) {\n      const queryParameters = options.queryParameters;\n      if (typeof queryParameters !== \"object\") {\n        throw new Error(\n          `options.queryParameters must be of type object. It should be a JSON object ` +\n            `of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. ` +\n            `The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.`\n        );\n      }\n      // append question mark if it is not present in the url\n      if (this.url && this.url.indexOf(\"?\") === -1) {\n        this.url += \"?\";\n      }\n      // construct queryString\n      const queryParams = [];\n      // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().\n      this.query = {};\n      for (const queryParamName in queryParameters) {\n        const queryParam: any = queryParameters[queryParamName];\n        if (queryParam) {\n          if (typeof queryParam === \"string\") {\n            queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam));\n            this.query[queryParamName] = encodeURIComponent(queryParam);\n          } else if (typeof queryParam === \"object\") {\n            if (!queryParam.value) {\n              throw new Error(\n                `options.queryParameters[${queryParamName}] is of type \"object\" but it does not contain a \"value\" property.`\n              );\n            }\n            if (queryParam.skipUrlEncoding) {\n              queryParams.push(queryParamName + \"=\" + queryParam.value);\n              this.query[queryParamName] = queryParam.value;\n            } else {\n              queryParams.push(queryParamName + \"=\" + encodeURIComponent(queryParam.value));\n              this.query[queryParamName] = encodeURIComponent(queryParam.value);\n            }\n          }\n        }\n      } // end-of-for\n      // append the queryString\n      this.url += queryParams.join(\"&\");\n    }\n\n    // add headers to the request if they are provided\n    if (options.headers) {\n      const headers = options.headers;\n      for (const headerName of Object.keys(options.headers)) {\n        this.headers.set(headerName, headers[headerName]);\n      }\n    }\n    // ensure accept-language is set correctly\n    if (!this.headers.get(\"accept-language\")) {\n      this.headers.set(\"accept-language\", \"en-US\");\n    }\n    // ensure the request-id is set correctly\n    if (!this.headers.get(\"x-ms-client-request-id\") && !options.disableClientRequestId) {\n      this.headers.set(\"x-ms-client-request-id\", this.requestId);\n    }\n\n    // default\n    if (!this.headers.get(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n\n    // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicitly\n    this.body = options.body;\n    if (options.body !== undefined && options.body !== null) {\n      // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.\n      if (options.bodyIsStream) {\n        if (!this.headers.get(\"Transfer-Encoding\")) {\n          this.headers.set(\"Transfer-Encoding\", \"chunked\");\n        }\n        if (this.headers.get(\"Content-Type\") !== \"application/octet-stream\") {\n          this.headers.set(\"Content-Type\", \"application/octet-stream\");\n        }\n      } else {\n        if (options.serializationMapper) {\n          this.body = new Serializer(options.mappers).serialize(\n            options.serializationMapper,\n            options.body,\n            \"requestBody\"\n          );\n        }\n        if (!options.disableJsonStringifyOnBody) {\n          this.body = JSON.stringify(options.body);\n        }\n      }\n    }\n\n    if (options.spanOptions) {\n      this.spanOptions = options.spanOptions;\n    }\n\n    if (options.tracingContext) {\n      this.tracingContext = options.tracingContext;\n    }\n\n    this.abortSignal = options.abortSignal;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.onUploadProgress = options.onUploadProgress;\n\n    return this;\n  }\n\n  /**\n   * Clone this WebResource HTTP request object.\n   * @returns The clone of this WebResource HTTP request object.\n   */\n  clone(): WebResource {\n    const result = new WebResource(\n      this.url,\n      this.method,\n      this.body,\n      this.query,\n      this.headers && this.headers.clone(),\n      this.streamResponseBody,\n      this.withCredentials,\n      this.abortSignal,\n      this.timeout,\n      this.onUploadProgress,\n      this.onDownloadProgress,\n      this.proxySettings,\n      this.keepAlive,\n      this.decompressResponse,\n      this.streamResponseStatusCodes\n    );\n\n    if (this.formData) {\n      result.formData = this.formData;\n    }\n\n    if (this.operationSpec) {\n      result.operationSpec = this.operationSpec;\n    }\n\n    if (this.shouldDeserialize) {\n      result.shouldDeserialize = this.shouldDeserialize;\n    }\n\n    if (this.operationResponseGetter) {\n      result.operationResponseGetter = this.operationResponseGetter;\n    }\n\n    return result;\n  }\n}\n\n/**\n * Options to prepare an outgoing HTTP request.\n */\nexport interface RequestPrepareOptions {\n  /**\n   * The HTTP request method. Valid values are \"GET\", \"PUT\", \"HEAD\", \"DELETE\", \"OPTIONS\", \"POST\",\n   * or \"PATCH\".\n   */\n  method: HttpMethods;\n  /**\n   * The request url. It may or may not have query parameters in it. Either provide the \"url\" or\n   * provide the \"pathTemplate\" in the options object. Both the options are mutually exclusive.\n   */\n  url?: string;\n  /**\n   * A dictionary of query parameters to be appended to the url, where\n   * the \"key\" is the \"query-parameter-name\" and the \"value\" is the \"query-parameter-value\".\n   * The \"query-parameter-value\" can be of type \"string\" or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"query-parameter-value\".\n   * Example:\n   *    - query-parameter-value in \"object\" format: `{ \"query-parameter-name\": { value: \"query-parameter-value\", skipUrlEncoding: true } }`\n   *    - query-parameter-value in \"string\" format: `{ \"query-parameter-name\": \"query-parameter-value\"}`.\n   * Note: \"If options.url already has some query parameters, then the value provided in options.queryParameters will be appended to the url.\n   */\n  queryParameters?: { [key: string]: any | ParameterValue };\n  /**\n   * The path template of the request url. Either provide the \"url\" or provide the \"pathTemplate\" in\n   * the options object. Both the options are mutually exclusive.\n   * Example: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}`\n   */\n  pathTemplate?: string;\n  /**\n   * The base url of the request. Default value is: \"https://management.azure.com\". This is\n   * applicable only with pathTemplate. If you are providing options.url then it is expected that\n   * you provide the complete url.\n   */\n  baseUrl?: string;\n  /**\n   * A dictionary of path parameters that need to be replaced with actual values in the pathTemplate.\n   * Here the key is the \"path-parameter-name\" and the value is the \"path-parameter-value\".\n   * The \"path-parameter-value\" can be of type \"string\"  or it can be of type \"object\".\n   * The \"object\" format should be used when you want to skip url encoding. While using the object format,\n   * the object must have a property named value which provides the \"path-parameter-value\".\n   * Example:\n   *    - path-parameter-value in \"object\" format: `{ \"path-parameter-name\": { value: \"path-parameter-value\", skipUrlEncoding: true } }`\n   *    - path-parameter-value in \"string\" format: `{ \"path-parameter-name\": \"path-parameter-value\" }`.\n   */\n  pathParameters?: { [key: string]: any | ParameterValue };\n  /**\n   * Form data, used to build the request body.\n   */\n  formData?: { [key: string]: any };\n  /**\n   * A dictionary of request headers that need to be applied to the request.\n   * Here the key is the \"header-name\" and the value is the \"header-value\". The header-value MUST be of type string.\n   *  - ContentType must be provided with the key name as \"Content-Type\". Default value \"application/json; charset=utf-8\".\n   *  - \"Transfer-Encoding\" is set to \"chunked\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"Content-Type\" is set to \"application/octet-stream\" by default if \"options.bodyIsStream\" is set to true.\n   *  - \"accept-language\" by default is set to \"en-US\"\n   *  - \"x-ms-client-request-id\" by default is set to a new Guid. To not generate a guid for the request, please set options.disableClientRequestId to true\n   */\n  headers?: { [key: string]: any };\n  /**\n   * When set to true, instructs the client to not set \"x-ms-client-request-id\" header to a new Guid().\n   */\n  disableClientRequestId?: boolean;\n  /**\n   * The request body. It can be of any type. This value will be serialized if it is not a stream.\n   */\n  body?: any;\n  /**\n   * Provides information on how to serialize the request body.\n   */\n  serializationMapper?: Mapper;\n  /**\n   * A dictionary of mappers that may be used while [de]serialization.\n   */\n  mappers?: { [x: string]: any };\n  /**\n   * Provides information on how to deserialize the response body.\n   */\n  deserializationMapper?: Record<string, unknown>;\n  /**\n   * Indicates whether this method should JSON.stringify() the request body. Default value: false.\n   */\n  disableJsonStringifyOnBody?: boolean;\n  /**\n   * Indicates whether the request body is a stream (useful for file upload scenarios).\n   */\n  bodyIsStream?: boolean;\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Allows keeping track of the progress of uploading the outgoing request.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Allows keeping track of the progress of downloading the incoming response.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n  /**\n   * Tracing: Options used to create a span when tracing is enabled.\n   */\n  spanOptions?: SpanOptions;\n  /**\n   * Tracing: Context used when creating spans.\n   */\n  tracingContext?: Context;\n}\n\n/**\n * The Parameter value provided for path or query parameters in RequestPrepareOptions\n */\nexport interface ParameterValue {\n  /**\n   * Value of the parameter.\n   */\n  value: any;\n  /**\n   * Disables URL encoding if set to true.\n   */\n  skipUrlEncoding: boolean;\n  /**\n   * Parameter values may contain any other property.\n   */\n  [key: string]: any;\n}\n\n/**\n * Describes the base structure of the options object that will be used in every operation.\n */\nexport interface RequestOptionsBase {\n  /**\n   * will be applied before the request is sent.\n   */\n  customHeaders?: { [key: string]: string };\n\n  /**\n   * Signal of an abort controller. Can be used to abort both sending a network request and waiting for a response.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   */\n  timeout?: number;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Callback which fires upon download progress.\n   */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /**\n   * Whether or not the HttpOperationResponse should be deserialized. If this is undefined, then the\n   * HttpOperationResponse should be deserialized.\n   */\n  shouldDeserialize?: boolean | ((response: HttpOperationResponse) => boolean);\n\n  /**\n   * Tracing: Context used when creating spans.\n   */\n  tracingContext?: Context;\n\n  /**\n   * May contain other properties.\n   */\n  [key: string]: any;\n\n  /**\n   * Options to override XML parsing/building behavior.\n   */\n  serializerOptions?: SerializerOptions;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}