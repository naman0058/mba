{"ast":null,"code":"import { __asyncDelegator, __asyncGenerator, __asyncValues, __await } from \"tslib\"; // Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, isNode, getDefaultProxySettings } from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, isPipelineLike } from \"./Pipeline\";\nimport { ContainerClient } from \"./ContainerClient\";\nimport { appendToURLPath, appendToURLQuery, extractConnectionStringParts, toTags } from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\n\nexport class BlobServiceClient extends StorageClient {\n  constructor(url, credentialOrPipeline, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    let pipeline;\n\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential || credentialOrPipeline instanceof AnonymousCredential || isTokenCredential(credentialOrPipeline)) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n\n    super(url, pipeline);\n    this.serviceContext = new Service(this.storageClientContext);\n  }\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n\n\n  static fromConnectionString(connectionString, // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n\n  /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n  options) {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);\n\n        if (!options.proxyOptions) {\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        }\n\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\"Connection string must be either an Account connection string or a SAS connection string\");\n    }\n  }\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n\n\n  getContainerClient(containerName) {\n    return new ContainerClient(appendToURLPath(this.url, encodeURIComponent(containerName)), this.pipeline);\n  }\n  /**\n   * Create a Blob container. @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n\n\n  async createContainer(containerName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-createContainer\", options);\n\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      const containerCreateResponse = await containerClient.create(updatedOptions);\n      return {\n        containerClient,\n        containerCreateResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n\n\n  async deleteContainer(containerName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-deleteContainer\", options);\n\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      return await containerClient.delete(updatedOptions);\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n\n\n  async undeleteContainer(deletedContainerName, deletedContainerVersion) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-undeleteContainer\", options);\n\n    try {\n      const containerClient = this.getContainerClient(options.destinationContainerName || deletedContainerName); // Hack to access a protected member.\n\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerUndeleteResponse = await containerContext.restore(Object.assign({\n        deletedContainerName,\n        deletedContainerVersion\n      }, updatedOptions));\n      return {\n        containerClient,\n        containerUndeleteResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n\n\n  async renameContainer(sourceContainerName, destinationContainerName) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var _a;\n\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-renameContainer\", options);\n\n    try {\n      const containerClient = this.getContainerClient(destinationContainerName); // Hack to access a protected member.\n\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerRenameResponse = await containerContext.rename(sourceContainerName, Object.assign(Object.assign({}, updatedOptions), {\n        sourceLeaseId: (_a = options.sourceCondition) === null || _a === void 0 ? void 0 : _a.leaseId\n      }));\n      return {\n        containerClient,\n        containerRenameResponse\n      };\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n\n\n  async getProperties() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-getProperties\", options);\n\n    try {\n      return await this.serviceContext.getProperties(Object.assign({\n        abortSignal: options.abortSignal\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n\n\n  async setProperties(properties) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-setProperties\", options);\n\n    try {\n      return await this.serviceContext.setProperties(properties, Object.assign({\n        abortSignal: options.abortSignal\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n\n\n  async getStatistics() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-getStatistics\", options);\n\n    try {\n      return await this.serviceContext.getStatistics(Object.assign({\n        abortSignal: options.abortSignal\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n\n\n  async getAccountInfo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-getAccountInfo\", options);\n\n    try {\n      return await this.serviceContext.getAccountInfo(Object.assign({\n        abortSignal: options.abortSignal\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n\n\n  async listContainersSegment(marker) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-listContainersSegment\", options);\n\n    try {\n      return await this.serviceContext.listContainersSegment(Object.assign(Object.assign(Object.assign({\n        abortSignal: options.abortSignal,\n        marker\n      }, options), {\n        include: typeof options.include === \"string\" ? [options.include] : options.include\n      }), convertTracingToRequestOptionsBase(updatedOptions)));\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  async findBlobsByTagsSegment(tagFilterSqlExpression, marker) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-findBlobsByTagsSegment\", options);\n\n    try {\n      const response = await this.serviceContext.filterBlobs(Object.assign({\n        abortSignal: options.abortSignal,\n        where: tagFilterSqlExpression,\n        marker,\n        maxPageSize: options.maxPageSize\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n      const wrappedResponse = Object.assign(Object.assign({}, response), {\n        _response: response._response,\n        blobs: response.blobs.map(blob => {\n          var _a;\n\n          let tagValue = \"\";\n\n          if (((_a = blob.tags) === null || _a === void 0 ? void 0 : _a.blobTagSet.length) === 1) {\n            tagValue = blob.tags.blobTagSet[0].value;\n          }\n\n          return Object.assign(Object.assign({}, blob), {\n            tags: toTags(blob.tags),\n            tagValue\n          });\n        })\n      });\n      return wrappedResponse;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTagsSegments(tagFilterSqlExpression, marker) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsSegments_1() {\n      let response;\n\n      if (!!marker || marker === undefined) {\n        do {\n          response = yield __await(this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options));\n          response.blobs = response.blobs || [];\n          marker = response.continuationToken;\n          yield yield __await(response);\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n\n\n  findBlobsByTagsItems(tagFilterSqlExpression) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __asyncGenerator(this, arguments, function* findBlobsByTagsItems_1() {\n      var e_1, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.findBlobsByTagsSegments(tagFilterSqlExpression, marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const segment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.blobs)));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n\n\n  findBlobsByTags(tagFilterSqlExpression) {\n    var _this = this;\n\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions = Object.assign({}, options);\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: function () {\n        let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n\n\n  listSegments(marker) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return __asyncGenerator(this, arguments, function* listSegments_1() {\n      let listContainersSegmentResponse;\n\n      if (!!marker || marker === undefined) {\n        do {\n          listContainersSegmentResponse = yield __await(this.listContainersSegment(marker, options));\n          listContainersSegmentResponse.containerItems = listContainersSegmentResponse.containerItems || [];\n          marker = listContainersSegmentResponse.continuationToken;\n          yield yield __await(yield __await(listContainersSegmentResponse));\n        } while (marker);\n      }\n    });\n  }\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n\n\n  listItems() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return __asyncGenerator(this, arguments, function* listItems_1() {\n      var e_2, _a;\n\n      let marker;\n\n      try {\n        for (var _b = __asyncValues(this.listSegments(marker, options)), _c; _c = yield __await(_b.next()), !_c.done;) {\n          const segment = _c.value;\n          yield __await(yield* __asyncDelegator(__asyncValues(segment.containerItems)));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    });\n  }\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n\n\n  listContainers() {\n    var _this2 = this;\n\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const include = [];\n\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n\n    if (options.includeSystem) {\n      include.push(\"system\");\n    } // AsyncIterableIterator to iterate over containers\n\n\n    const listSegmentOptions = Object.assign(Object.assign({}, options), include.length > 0 ? {\n      include\n    } : {});\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: function () {\n        let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return _this2.listSegments(settings.continuationToken, Object.assign({\n          maxPageSize: settings.maxPageSize\n        }, listSegmentOptions));\n      }\n    };\n  }\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n\n\n  async getUserDelegationKey(startsOn, expiresOn) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      span,\n      updatedOptions\n    } = createSpan(\"BlobServiceClient-getUserDelegationKey\", options);\n\n    try {\n      const response = await this.serviceContext.getUserDelegationKey({\n        startsOn: truncatedISO8061Date(startsOn, false),\n        expiresOn: truncatedISO8061Date(expiresOn, false)\n      }, Object.assign({\n        abortSignal: options.abortSignal\n      }, convertTracingToRequestOptionsBase(updatedOptions)));\n      const userDelegationKey = {\n        signedObjectId: response.signedObjectId,\n        signedTenantId: response.signedTenantId,\n        signedStartsOn: new Date(response.signedStartsOn),\n        signedExpiresOn: new Date(response.signedExpiresOn),\n        signedService: response.signedService,\n        signedVersion: response.signedVersion,\n        value: response.value\n      };\n      const res = Object.assign({\n        _response: response._response,\n        requestId: response.requestId,\n        clientRequestId: response.clientRequestId,\n        version: response.version,\n        date: response.date,\n        errorCode: response.errorCode\n      }, userDelegationKey);\n      return res;\n    } catch (e) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n\n\n  getBlobBatchClient() {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n\n\n  generateAccountSasUrl(expiresOn) {\n    let permissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AccountSASPermissions.parse(\"r\");\n    let resourceTypes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"sco\";\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\"Can only generate the account SAS when the client is initialized with a shared key credential\");\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    const sas = generateAccountSASQueryParameters(Object.assign({\n      permissions,\n      expiresOn,\n      resourceTypes,\n      services: AccountSASServices.parse(\"b\").toString()\n    }, options), this.credential).toString();\n    return appendToURLQuery(this.url, sas);\n  }\n\n}","map":{"version":3,"sources":["../../../src/BlobServiceClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport {\n  TokenCredential,\n  isTokenCredential,\n  isNode,\n  HttpResponse,\n  getDefaultProxySettings,\n} from \"@azure/core-http\";\nimport { SpanStatusCode } from \"@azure/core-tracing\";\nimport { AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  ServiceGetUserDelegationKeyHeaders,\n  ContainerCreateResponse,\n  ContainerDeleteResponse,\n  ServiceGetPropertiesResponse,\n  BlobServiceProperties,\n  ServiceSetPropertiesResponse,\n  ServiceGetStatisticsResponse,\n  ServiceGetAccountInfoResponse,\n  ServiceListContainersSegmentResponse,\n  ContainerItem,\n  UserDelegationKeyModel,\n  ContainerUndeleteResponse,\n  FilterBlobSegmentModel,\n  ServiceFilterBlobsHeaders,\n  ContainerRenameResponse,\n  LeaseAccessConditions,\n  FilterBlobSegment,\n  FilterBlobItem,\n} from \"./generatedModels\";\nimport { Container, Service } from \"./generated/src/operations\";\nimport { newPipeline, StoragePipelineOptions, PipelineLike, isPipelineLike } from \"./Pipeline\";\nimport {\n  ContainerClient,\n  ContainerCreateOptions,\n  ContainerDeleteMethodOptions,\n} from \"./ContainerClient\";\nimport {\n  appendToURLPath,\n  appendToURLQuery,\n  extractConnectionStringParts,\n  toTags,\n} from \"./utils/utils.common\";\nimport { StorageSharedKeyCredential } from \"./credentials/StorageSharedKeyCredential\";\nimport { AnonymousCredential } from \"./credentials/AnonymousCredential\";\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { truncatedISO8061Date } from \"./utils/utils.common\";\nimport { convertTracingToRequestOptionsBase, createSpan } from \"./utils/tracing\";\nimport { BlobBatchClient } from \"./BlobBatchClient\";\nimport { CommonOptions, StorageClient } from \"./StorageClient\";\nimport { AccountSASPermissions } from \"./sas/AccountSASPermissions\";\nimport { SASProtocol } from \"./sas/SASQueryParameters\";\nimport { SasIPRange } from \"./sas/SasIPRange\";\nimport { generateAccountSASQueryParameters } from \"./sas/AccountSASSignatureValues\";\nimport { AccountSASServices } from \"./sas/AccountSASServices\";\nimport { ListContainersIncludeType } from \"./generated/src\";\n\n/**\n * Options to configure the {@link BlobServiceClient.getProperties} operation.\n */\nexport interface ServiceGetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.setProperties} operation.\n */\nexport interface ServiceSetPropertiesOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getAccountInfo} operation.\n */\nexport interface ServiceGetAccountInfoOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.getStatistics} operation.\n */\nexport interface ServiceGetStatisticsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the Service - Get User Delegation Key.\n */\nexport interface ServiceGetUserDelegationKeyOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainerSegment} operation.\n */\ninterface ServiceListContainersSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies the maximum number of containers\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n  /**\n   * Include this parameter to\n   * specify that the container's metadata be returned as part of the response\n   * body. Possible values include: 'metadata'\n   */\n  include?: ListContainersIncludeType | ListContainersIncludeType[];\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.listContainers} operation.\n */\nexport interface ServiceListContainersOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Filters the results to return only containers\n   * whose name begins with the specified prefix.\n   */\n  prefix?: string;\n  /**\n   * Specifies whether the container's metadata\n   *                                   should be returned as part of the response body.\n   */\n  includeMetadata?: boolean;\n\n  /**\n   * Specifies whether soft deleted containers should be included in the response.\n   */\n  includeDeleted?: boolean;\n  /**\n   * Specifies whether system containers should be included in the response.\n   */\n  includeSystem?: boolean;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTagsSegment} operation.\n */\ninterface ServiceFindBlobsByTagsSegmentOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Specifies the maximum number of blobs\n   * to return. If the request does not specify maxPageSize, or specifies a\n   * value greater than 5000, the server will return up to 5000 items. Note\n   * that if the listing operation crosses a partition boundary, then the\n   * service will return a continuation token for retrieving the remainder of\n   * the results. For this reason, it is possible that the service will return\n   * fewer results than specified by maxPageSize, or than the default of 5000.\n   */\n  maxPageSize?: number;\n}\n\n/**\n * Options to configure the {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport interface ServiceFindBlobByTagsOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n}\n\n/**\n * The response of {@link BlobServiceClient.findBlobsByTags} operation.\n */\nexport type ServiceFindBlobsByTagsSegmentResponse = FilterBlobSegment &\n  ServiceFilterBlobsHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ServiceFilterBlobsHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: FilterBlobSegmentModel;\n    };\n  };\n\n/**\n * A user delegation key.\n */\nexport interface UserDelegationKey {\n  /**\n   * The Azure Active Directory object ID in GUID format.\n   */\n  signedObjectId: string;\n  /**\n   * The Azure Active Directory tenant ID in GUID format.\n   */\n  signedTenantId: string;\n  /**\n   * The date-time the key is active.\n   */\n  signedStartsOn: Date;\n  /**\n   * The date-time the key expires.\n   */\n  signedExpiresOn: Date;\n  /**\n   * Abbreviation of the Azure Storage service that accepts the key.\n   */\n  signedService: string;\n  /**\n   * The service version that created the key.\n   */\n  signedVersion: string;\n  /**\n   * The key as a base64 string.\n   */\n  value: string;\n}\n\n/**\n * Contains response data for the {@link getUserDelegationKey} operation.\n */\nexport declare type ServiceGetUserDelegationKeyResponse = UserDelegationKey &\n  ServiceGetUserDelegationKeyHeaders & {\n    /**\n     * The underlying HTTP response.\n     */\n    _response: HttpResponse & {\n      /**\n       * The parsed HTTP response headers.\n       */\n      parsedHeaders: ServiceGetUserDelegationKeyHeaders;\n\n      /**\n       * The response body as text (string format)\n       */\n      bodyAsText: string;\n\n      /**\n       * The response body as parsed JSON or XML\n       */\n      parsedBody: UserDelegationKeyModel;\n    };\n  };\n\n/**\n * Options to configure {@link BlobServiceClient.undeleteContainer} operation.\n */\nexport interface ServiceUndeleteContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n  /**\n   * Optional. Specifies the new name of the restored container.\n   * Will use its original name if this is not specified.\n   * @deprecated Restore container to a different name is not supported by service anymore.\n   */\n  destinationContainerName?: string;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.renameContainer} operation.\n */\nexport interface ServiceRenameContainerOptions extends CommonOptions {\n  /**\n   * An implementation of the `AbortSignalLike` interface to signal the request to cancel the operation.\n   * For example, use the &commat;azure/abort-controller to create an `AbortSignal`.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Condition to meet for the source container.\n   */\n  sourceCondition?: LeaseAccessConditions;\n}\n\n/**\n * Options to configure {@link BlobServiceClient.generateAccountSasUrl} operation.\n */\nexport interface ServiceGenerateAccountSasUrlOptions {\n  /**\n   * The version of the service this SAS will target. If not specified, it will default to the version targeted by the\n   * library.\n   */\n  version?: string;\n\n  /**\n   * Optional. SAS protocols allowed.\n   */\n  protocol?: SASProtocol;\n\n  /**\n   * Optional. When the SAS will take effect.\n   */\n  startsOn?: Date;\n  /**\n   * Optional. IP range allowed.\n   */\n  ipRange?: SasIPRange;\n  /**\n   * Optional. Encryption scope to use when sending requests authorized with this SAS URI.\n   */\n  encryptionScope?: string;\n}\n\n/**\n * A BlobServiceClient represents a Client to the Azure Storage Blob service allowing you\n * to manipulate blob containers.\n */\nexport class BlobServiceClient extends StorageClient {\n  /**\n   * serviceContext provided by protocol layer.\n   */\n  private serviceContext: Service;\n\n  /**\n   *\n   * Creates an instance of BlobServiceClient from connection string.\n   *\n   * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.\n   *                                  [ Note - Account connection string can only be used in NODE.JS runtime. ]\n   *                                  Account connection string example -\n   *                                  `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`\n   *                                  SAS connection string example -\n   *                                  `BlobEndpoint=https://myaccount.blob.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   */\n  public static fromConnectionString(\n    connectionString: string,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ): BlobServiceClient {\n    options = options || {};\n    const extractedCreds = extractConnectionStringParts(connectionString);\n    if (extractedCreds.kind === \"AccountConnString\") {\n      if (isNode) {\n        const sharedKeyCredential = new StorageSharedKeyCredential(\n          extractedCreds.accountName!,\n          extractedCreds.accountKey\n        );\n\n        if (!options.proxyOptions) {\n          options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);\n        }\n\n        const pipeline = newPipeline(sharedKeyCredential, options);\n        return new BlobServiceClient(extractedCreds.url, pipeline);\n      } else {\n        throw new Error(\"Account connection string is only supported in Node.js environment\");\n      }\n    } else if (extractedCreds.kind === \"SASConnString\") {\n      const pipeline = newPipeline(new AnonymousCredential(), options);\n      return new BlobServiceClient(extractedCreds.url + \"?\" + extractedCreds.accountSas, pipeline);\n    } else {\n      throw new Error(\n        \"Connection string must be either an Account connection string or a SAS connection string\"\n      );\n    }\n  }\n\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param credential -  Such as AnonymousCredential, StorageSharedKeyCredential or any credential from the `@azure/identity` package to authenticate requests to the service. You can also provide an object that implements the TokenCredential interface. If not specified, AnonymousCredential is used.\n   * @param options - Optional. Options to configure the HTTP pipeline.\n   *\n   * Example using DefaultAzureCredential from `@azure/identity`:\n   *\n   * ```js\n   * const account = \"<storage account name>\";\n   *\n   * const defaultAzureCredential = new DefaultAzureCredential();\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   defaultAzureCredential\n   * );\n   * ```\n   *\n   * Example using an account name/key:\n   *\n   * ```js\n   * const account = \"<storage account name>\"\n   * const sharedKeyCredential = new StorageSharedKeyCredential(account, \"<account key>\");\n   *\n   * const blobServiceClient = new BlobServiceClient(\n   *   `https://${account}.blob.core.windows.net`,\n   *   sharedKeyCredential\n   * );\n   * ```\n   */\n  constructor(\n    url: string,\n    credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  );\n  /**\n   * Creates an instance of BlobServiceClient.\n   *\n   * @param url - A Client string pointing to Azure Storage blob service, such as\n   *                     \"https://myaccount.blob.core.windows.net\". You can append a SAS\n   *                     if using AnonymousCredential, such as \"https://myaccount.blob.core.windows.net?sasString\".\n   * @param pipeline - Call newPipeline() to create a default\n   *                            pipeline, or provide a customized pipeline.\n   */\n  constructor(url: string, pipeline: PipelineLike);\n  constructor(\n    url: string,\n    credentialOrPipeline?:\n      | StorageSharedKeyCredential\n      | AnonymousCredential\n      | TokenCredential\n      | PipelineLike,\n    // Legacy, no fix for eslint error without breaking. Disable it for this interface.\n    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options*/\n    options?: StoragePipelineOptions\n  ) {\n    let pipeline: PipelineLike;\n    if (isPipelineLike(credentialOrPipeline)) {\n      pipeline = credentialOrPipeline;\n    } else if (\n      (isNode && credentialOrPipeline instanceof StorageSharedKeyCredential) ||\n      credentialOrPipeline instanceof AnonymousCredential ||\n      isTokenCredential(credentialOrPipeline)\n    ) {\n      pipeline = newPipeline(credentialOrPipeline, options);\n    } else {\n      // The second parameter is undefined. Use anonymous credential\n      pipeline = newPipeline(new AnonymousCredential(), options);\n    }\n    super(url, pipeline);\n    this.serviceContext = new Service(this.storageClientContext);\n  }\n\n  /**\n   * Creates a {@link ContainerClient} object\n   *\n   * @param containerName - A container name\n   * @returns A new ContainerClient object for the given container name.\n   *\n   * Example usage:\n   *\n   * ```js\n   * const containerClient = blobServiceClient.getContainerClient(\"<container name>\");\n   * ```\n   */\n  public getContainerClient(containerName: string): ContainerClient {\n    return new ContainerClient(\n      appendToURLPath(this.url, encodeURIComponent(containerName)),\n      this.pipeline\n    );\n  }\n\n  /**\n   * Create a Blob container. @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container\n   *\n   * @param containerName - Name of the container to create.\n   * @param options - Options to configure Container Create operation.\n   * @returns Container creation response and the corresponding container client.\n   */\n  public async createContainer(\n    containerName: string,\n    options: ContainerCreateOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerCreateResponse: ContainerCreateResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-createContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      const containerCreateResponse = await containerClient.create(updatedOptions);\n      return {\n        containerClient,\n        containerCreateResponse,\n      };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Deletes a Blob container.\n   *\n   * @param containerName - Name of the container to delete.\n   * @param options - Options to configure Container Delete operation.\n   * @returns Container deletion response.\n   */\n  public async deleteContainer(\n    containerName: string,\n    options: ContainerDeleteMethodOptions = {}\n  ): Promise<ContainerDeleteResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-deleteContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(containerName);\n      return await containerClient.delete(updatedOptions);\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Restore a previously deleted Blob container.\n   * This API is only functional if Container Soft Delete is enabled for the storage account associated with the container.\n   *\n   * @param deletedContainerName - Name of the previously deleted container.\n   * @param deletedContainerVersion - Version of the previously deleted container, used to uniquely identify the deleted container.\n   * @param options - Options to configure Container Restore operation.\n   * @returns Container deletion response.\n   */\n  public async undeleteContainer(\n    deletedContainerName: string,\n    deletedContainerVersion: string,\n    options: ServiceUndeleteContainerOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerUndeleteResponse: ContainerUndeleteResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-undeleteContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(\n        options.destinationContainerName || deletedContainerName\n      );\n      // Hack to access a protected member.\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerUndeleteResponse = await containerContext.restore({\n        deletedContainerName,\n        deletedContainerVersion,\n        ...updatedOptions,\n      });\n      return { containerClient, containerUndeleteResponse };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Rename an existing Blob Container.\n   *\n   * @param sourceContainerName - The name of the source container.\n   * @param destinationContainerName - The new name of the container.\n   * @param options - Options to configure Container Rename operation.\n   */\n  /* eslint-disable-next-line @typescript-eslint/ban-ts-comment */\n  // @ts-ignore Need to hide this interface for now. Make it public and turn on the live tests for it when the service is ready.\n  private async renameContainer(\n    sourceContainerName: string,\n    destinationContainerName: string,\n    options: ServiceRenameContainerOptions = {}\n  ): Promise<{\n    containerClient: ContainerClient;\n    containerRenameResponse: ContainerRenameResponse;\n  }> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-renameContainer\", options);\n    try {\n      const containerClient = this.getContainerClient(destinationContainerName);\n      // Hack to access a protected member.\n      const containerContext = new Container(containerClient[\"storageClientContext\"]);\n      const containerRenameResponse = await containerContext.rename(sourceContainerName, {\n        ...updatedOptions,\n        sourceLeaseId: options.sourceCondition?.leaseId,\n      });\n      return { containerClient, containerRenameResponse };\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Gets the properties of a storage account’s Blob service, including properties\n   * for Storage Analytics and CORS (Cross-Origin Resource Sharing) rules.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * @param options - Options to the Service Get Properties operation.\n   * @returns Response data for the Service Get Properties operation.\n   */\n  public async getProperties(\n    options: ServiceGetPropertiesOptions = {}\n  ): Promise<ServiceGetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getProperties\", options);\n    try {\n      return await this.serviceContext.getProperties({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Sets properties for a storage account’s Blob service endpoint, including properties\n   * for Storage Analytics, CORS (Cross-Origin Resource Sharing) rules and soft delete settings.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-service-properties\n   *\n   * @param properties -\n   * @param options - Options to the Service Set Properties operation.\n   * @returns Response data for the Service Set Properties operation.\n   */\n  public async setProperties(\n    properties: BlobServiceProperties,\n    options: ServiceSetPropertiesOptions = {}\n  ): Promise<ServiceSetPropertiesResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-setProperties\", options);\n    try {\n      return await this.serviceContext.setProperties(properties, {\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Retrieves statistics related to replication for the Blob service. It is only\n   * available on the secondary location endpoint when read-access geo-redundant\n   * replication is enabled for the storage account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-stats\n   *\n   * @param options - Options to the Service Get Statistics operation.\n   * @returns Response data for the Service Get Statistics operation.\n   */\n  public async getStatistics(\n    options: ServiceGetStatisticsOptions = {}\n  ): Promise<ServiceGetStatisticsResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getStatistics\", options);\n    try {\n      return await this.serviceContext.getStatistics({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Get Account Information operation returns the sku name and account kind\n   * for the specified account.\n   * The Get Account Information operation is available on service versions beginning\n   * with version 2018-03-28.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-account-information\n   *\n   * @param options - Options to the Service Get Account Info operation.\n   * @returns Response data for the Service Get Account Info operation.\n   */\n  public async getAccountInfo(\n    options: ServiceGetAccountInfoOptions = {}\n  ): Promise<ServiceGetAccountInfoResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getAccountInfo\", options);\n    try {\n      return await this.serviceContext.getAccountInfo({\n        abortSignal: options.abortSignal,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns a list of the containers under the specified account.\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-containers2\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to the Service List Container Segment operation.\n   * @returns Response data for the Service List Container Segment operation.\n   */\n  private async listContainersSegment(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {}\n  ): Promise<ServiceListContainersSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-listContainersSegment\", options);\n\n    try {\n      return await this.serviceContext.listContainersSegment({\n        abortSignal: options.abortSignal,\n        marker,\n        ...options,\n        include: typeof options.include === \"string\" ? [options.include] : options.include,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * The Filter Blobs operation enables callers to list blobs across all containers whose tags\n   * match a given search expression. Filter blobs searches across all containers within a\n   * storage account but can be scoped within the expression to a single container.\n   *\n   * @param tagFilterSqlExpression - The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                        The given expression must evaluate to true for a blob to be returned in the results.\n   *                                        The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                        however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async findBlobsByTagsSegment(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): Promise<ServiceFindBlobsByTagsSegmentResponse> {\n    const { span, updatedOptions } = createSpan(\n      \"BlobServiceClient-findBlobsByTagsSegment\",\n      options\n    );\n\n    try {\n      const response = await this.serviceContext.filterBlobs({\n        abortSignal: options.abortSignal,\n        where: tagFilterSqlExpression,\n        marker,\n        maxPageSize: options.maxPageSize,\n        ...convertTracingToRequestOptionsBase(updatedOptions),\n      });\n\n      const wrappedResponse: ServiceFindBlobsByTagsSegmentResponse = {\n        ...response,\n        _response: response._response, // _response is made non-enumerable\n        blobs: response.blobs.map((blob) => {\n          let tagValue = \"\";\n          if (blob.tags?.blobTagSet.length === 1) {\n            tagValue = blob.tags.blobTagSet[0].value;\n          }\n          return { ...blob, tags: toTags(blob.tags), tagValue };\n        }),\n      };\n      return wrappedResponse;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceFindBlobsByTagsSegmentResponse.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param marker - A string value that identifies the portion of\n   *                          the list of blobs to be returned with the next listing operation. The\n   *                          operation returns the continuationToken value within the response body if the\n   *                          listing operation did not return all blobs remaining to be listed\n   *                          with the current page. The continuationToken value can be used as the value for\n   *                          the marker parameter in a subsequent call to request the next page of list\n   *                          items. The marker value is opaque to the client.\n   * @param options - Options to find blobs by tags.\n   */\n  private async *findBlobsByTagsSegments(\n    tagFilterSqlExpression: string,\n    marker?: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<ServiceFindBlobsByTagsSegmentResponse> {\n    let response;\n    if (!!marker || marker === undefined) {\n      do {\n        response = await this.findBlobsByTagsSegment(tagFilterSqlExpression, marker, options);\n        response.blobs = response.blobs || [];\n        marker = response.continuationToken;\n        yield response;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for blobs.\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to findBlobsByTagsItems.\n   */\n  private async *findBlobsByTagsItems(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobsByTagsSegmentOptions = {}\n  ): AsyncIterableIterator<FilterBlobItem> {\n    let marker: string | undefined;\n    for await (const segment of this.findBlobsByTagsSegments(\n      tagFilterSqlExpression,\n      marker,\n      options\n    )) {\n      yield* segment.blobs;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to find all blobs with specified tag\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the blobs in pages.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-service-properties\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const blob of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\")) {\n   *   console.log(`Blob ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\");\n   * let blobItem = await iter.next();\n   * while (!blobItem.done) {\n   *   console.log(`Blob ${i++}: ${blobItem.value.name}`);\n   *   blobItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 20 })) {\n   *   if (response.blobs) {\n   *     for (const blob of response.blobs) {\n   *       console.log(`Blob ${i++}: ${blob.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.findBlobsByTags(\"tagkey='tagvalue'\").byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *     console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .findBlobsByTags(\"tagkey='tagvalue'\")\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints blob names\n   * if (response.blobs) {\n   *   for (const blob of response.blobs) {\n   *      console.log(`Blob ${i++}: ${blob.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param tagFilterSqlExpression -  The where parameter enables the caller to query blobs whose tags match a given expression.\n   *                                         The given expression must evaluate to true for a blob to be returned in the results.\n   *                                         The[OData - ABNF] filter syntax rule defines the formal grammar for the value of the where query parameter;\n   *                                         however, only a subset of the OData filter syntax is supported in the Blob service.\n   * @param options - Options to find blobs by tags.\n   */\n  public findBlobsByTags(\n    tagFilterSqlExpression: string,\n    options: ServiceFindBlobByTagsOptions = {}\n  ): PagedAsyncIterableIterator<FilterBlobItem, ServiceFindBlobsByTagsSegmentResponse> {\n    // AsyncIterableIterator to iterate over blobs\n    const listSegmentOptions: ServiceFindBlobsByTagsSegmentOptions = {\n      ...options,\n    };\n\n    const iter = this.findBlobsByTagsItems(tagFilterSqlExpression, listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.findBlobsByTagsSegments(tagFilterSqlExpression, settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for ServiceListContainersSegmentResponses\n   *\n   * @param marker - A string value that identifies the portion of\n   *                        the list of containers to be returned with the next listing operation. The\n   *                        operation returns the continuationToken value within the response body if the\n   *                        listing operation did not return all containers remaining to be listed\n   *                        with the current page. The continuationToken value can be used as the value for\n   *                        the marker parameter in a subsequent call to request the next page of list\n   *                        items. The marker value is opaque to the client.\n   * @param options - Options to list containers operation.\n   */\n  private async *listSegments(\n    marker?: string,\n    options: ServiceListContainersSegmentOptions = {}\n  ): AsyncIterableIterator<ServiceListContainersSegmentResponse> {\n    let listContainersSegmentResponse;\n    if (!!marker || marker === undefined) {\n      do {\n        listContainersSegmentResponse = await this.listContainersSegment(marker, options);\n        listContainersSegmentResponse.containerItems =\n          listContainersSegmentResponse.containerItems || [];\n        marker = listContainersSegmentResponse.continuationToken;\n        yield await listContainersSegmentResponse;\n      } while (marker);\n    }\n  }\n\n  /**\n   * Returns an AsyncIterableIterator for Container Items\n   *\n   * @param options - Options to list containers operation.\n   */\n  private async *listItems(\n    options: ServiceListContainersSegmentOptions = {}\n  ): AsyncIterableIterator<ContainerItem> {\n    let marker: string | undefined;\n    for await (const segment of this.listSegments(marker, options)) {\n      yield* segment.containerItems;\n    }\n  }\n\n  /**\n   * Returns an async iterable iterator to list all the containers\n   * under the specified account.\n   *\n   * .byPage() returns an async iterable iterator to list the containers in pages.\n   *\n   * Example using `for await` syntax:\n   *\n   * ```js\n   * let i = 1;\n   * for await (const container of blobServiceClient.listContainers()) {\n   *   console.log(`Container ${i++}: ${container.name}`);\n   * }\n   * ```\n   *\n   * Example using `iter.next()`:\n   *\n   * ```js\n   * let i = 1;\n   * const iter = blobServiceClient.listContainers();\n   * let containerItem = await iter.next();\n   * while (!containerItem.done) {\n   *   console.log(`Container ${i++}: ${containerItem.value.name}`);\n   *   containerItem = await iter.next();\n   * }\n   * ```\n   *\n   * Example using `byPage()`:\n   *\n   * ```js\n   * // passing optional maxPageSize in the page settings\n   * let i = 1;\n   * for await (const response of blobServiceClient.listContainers().byPage({ maxPageSize: 20 })) {\n   *   if (response.containerItems) {\n   *     for (const container of response.containerItems) {\n   *       console.log(`Container ${i++}: ${container.name}`);\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * Example using paging with a marker:\n   *\n   * ```js\n   * let i = 1;\n   * let iterator = blobServiceClient.listContainers().byPage({ maxPageSize: 2 });\n   * let response = (await iterator.next()).value;\n   *\n   * // Prints 2 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *     console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   *\n   * // Gets next marker\n   * let marker = response.continuationToken;\n   * // Passing next marker as continuationToken\n   * iterator = blobServiceClient\n   *   .listContainers()\n   *   .byPage({ continuationToken: marker, maxPageSize: 10 });\n   * response = (await iterator.next()).value;\n   *\n   * // Prints 10 container names\n   * if (response.containerItems) {\n   *   for (const container of response.containerItems) {\n   *      console.log(`Container ${i++}: ${container.name}`);\n   *   }\n   * }\n   * ```\n   *\n   * @param options - Options to list containers.\n   * @returns An asyncIterableIterator that supports paging.\n   */\n  public listContainers(\n    options: ServiceListContainersOptions = {}\n  ): PagedAsyncIterableIterator<ContainerItem, ServiceListContainersSegmentResponse> {\n    if (options.prefix === \"\") {\n      options.prefix = undefined;\n    }\n\n    const include: ListContainersIncludeType[] = [];\n    if (options.includeDeleted) {\n      include.push(\"deleted\");\n    }\n    if (options.includeMetadata) {\n      include.push(\"metadata\");\n    }\n    if (options.includeSystem) {\n      include.push(\"system\");\n    }\n\n    // AsyncIterableIterator to iterate over containers\n    const listSegmentOptions: ServiceListContainersSegmentOptions = {\n      ...options,\n      ...(include.length > 0 ? { include } : {}),\n    };\n\n    const iter = this.listItems(listSegmentOptions);\n    return {\n      /**\n       * The next method, part of the iteration protocol\n       */\n      next() {\n        return iter.next();\n      },\n      /**\n       * The connection to the async iterator, part of the iteration protocol\n       */\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      /**\n       * Return an AsyncIterableIterator that works a page at a time\n       */\n      byPage: (settings: PageSettings = {}) => {\n        return this.listSegments(settings.continuationToken, {\n          maxPageSize: settings.maxPageSize,\n          ...listSegmentOptions,\n        });\n      },\n    };\n  }\n\n  /**\n   * ONLY AVAILABLE WHEN USING BEARER TOKEN AUTHENTICATION (TokenCredential).\n   *\n   * Retrieves a user delegation key for the Blob service. This is only a valid operation when using\n   * bearer token authentication.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-user-delegation-key\n   *\n   * @param startsOn -      The start time for the user delegation SAS. Must be within 7 days of the current time\n   * @param expiresOn -     The end time for the user delegation SAS. Must be within 7 days of the current time\n   */\n  public async getUserDelegationKey(\n    startsOn: Date,\n    expiresOn: Date,\n    options: ServiceGetUserDelegationKeyOptions = {}\n  ): Promise<ServiceGetUserDelegationKeyResponse> {\n    const { span, updatedOptions } = createSpan(\"BlobServiceClient-getUserDelegationKey\", options);\n    try {\n      const response = await this.serviceContext.getUserDelegationKey(\n        {\n          startsOn: truncatedISO8061Date(startsOn, false),\n          expiresOn: truncatedISO8061Date(expiresOn, false),\n        },\n        {\n          abortSignal: options.abortSignal,\n          ...convertTracingToRequestOptionsBase(updatedOptions),\n        }\n      );\n\n      const userDelegationKey = {\n        signedObjectId: response.signedObjectId,\n        signedTenantId: response.signedTenantId,\n        signedStartsOn: new Date(response.signedStartsOn),\n        signedExpiresOn: new Date(response.signedExpiresOn),\n        signedService: response.signedService,\n        signedVersion: response.signedVersion,\n        value: response.value,\n      };\n\n      const res: ServiceGetUserDelegationKeyResponse = {\n        _response: response._response,\n        requestId: response.requestId,\n        clientRequestId: response.clientRequestId,\n        version: response.version,\n        date: response.date,\n        errorCode: response.errorCode,\n        ...userDelegationKey,\n      };\n\n      return res;\n    } catch (e: any) {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: e.message,\n      });\n      throw e;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Creates a BlobBatchClient object to conduct batch operations.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/blob-batch\n   *\n   * @returns A new BlobBatchClient object for this service.\n   */\n  public getBlobBatchClient(): BlobBatchClient {\n    return new BlobBatchClient(this.url, this.pipeline);\n  }\n\n  /**\n   * Only available for BlobServiceClient constructed with a shared key credential.\n   *\n   * Generates a Blob account Shared Access Signature (SAS) URI based on the client properties\n   * and parameters passed in. The SAS is signed by the shared key credential of the client.\n   *\n   * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-account-sas\n   *\n   * @param expiresOn - Optional. The time at which the shared access signature becomes invalid. Default to an hour later if not provided.\n   * @param permissions - Specifies the list of permissions to be associated with the SAS.\n   * @param resourceTypes - Specifies the resource types associated with the shared access signature.\n   * @param options - Optional parameters.\n   * @returns An account SAS URI consisting of the URI to the resource represented by this client, followed by the generated SAS token.\n   */\n  public generateAccountSasUrl(\n    expiresOn?: Date,\n    permissions: AccountSASPermissions = AccountSASPermissions.parse(\"r\"),\n    resourceTypes: string = \"sco\",\n    options: ServiceGenerateAccountSasUrlOptions = {}\n  ): string {\n    if (!(this.credential instanceof StorageSharedKeyCredential)) {\n      throw RangeError(\n        \"Can only generate the account SAS when the client is initialized with a shared key credential\"\n      );\n    }\n\n    if (expiresOn === undefined) {\n      const now = new Date();\n      expiresOn = new Date(now.getTime() + 3600 * 1000);\n    }\n\n    const sas = generateAccountSASQueryParameters(\n      {\n        permissions,\n        expiresOn,\n        resourceTypes,\n        services: AccountSASServices.parse(\"b\").toString(),\n        ...options,\n      },\n      this.credential\n    ).toString();\n\n    return appendToURLQuery(this.url, sas);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}