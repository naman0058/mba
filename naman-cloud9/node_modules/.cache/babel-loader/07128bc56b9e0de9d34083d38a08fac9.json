{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { BaseRequestPolicy } from \"./requestPolicy\";\nimport { SpanKind, SpanStatusCode, createSpanFunction, getTraceParentHeader, isSpanContextValid } from \"@azure/core-tracing\";\nimport { logger } from \"../log\";\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\"\n});\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\n\nexport function tracingPolicy() {\n  let tracingOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return {\n    create(nextPolicy, options) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    }\n\n  };\n}\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\n\nexport class TracingPolicy extends BaseRequestPolicy {\n  constructor(nextPolicy, options, tracingOptions) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  async sendRequest(request) {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    const span = this.tryCreateSpan(request);\n\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n\n  tryCreateSpan(request) {\n    var _a;\n\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const {\n        span\n      } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: Object.assign(Object.assign({}, request.spanOptions), {\n            kind: SpanKind.CLIENT\n          }),\n          tracingContext: request.tracingContext\n        }\n      }); // If the span is not recording, don't do any more work.\n\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = (_a = request.tracingContext) === null || _a === void 0 ? void 0 : _a.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      } // set headers\n\n\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize(); // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n\n      return span;\n    } catch (error) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  tryProcessError(span, err) {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  tryProcessResponse(span, response) {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n\n      span.setStatus({\n        code: SpanStatusCode.OK\n      });\n      span.end();\n    } catch (error) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n}","map":{"version":3,"sources":["../../../src/policies/tracingPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  BaseRequestPolicy,\n  RequestPolicy,\n  RequestPolicyFactory,\n  RequestPolicyOptions,\n} from \"./requestPolicy\";\nimport {\n  Span,\n  SpanKind,\n  SpanStatusCode,\n  createSpanFunction,\n  getTraceParentHeader,\n  isSpanContextValid,\n} from \"@azure/core-tracing\";\nimport { HttpOperationResponse } from \"../httpOperationResponse\";\nimport { WebResourceLike } from \"../webResource\";\nimport { logger } from \"../log\";\n\nconst createSpan = createSpanFunction({\n  packagePrefix: \"\",\n  namespace: \"\",\n});\n\n/**\n * Options to customize the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * User agent used to better identify the outgoing requests traced by the tracing policy.\n   */\n  userAgent?: string;\n}\n\n/**\n * Creates a policy that wraps outgoing requests with a tracing span.\n * @param tracingOptions - Tracing options.\n * @returns An instance of the {@link TracingPolicy} class.\n */\nexport function tracingPolicy(tracingOptions: TracingPolicyOptions = {}): RequestPolicyFactory {\n  return {\n    create(nextPolicy: RequestPolicy, options: RequestPolicyOptions) {\n      return new TracingPolicy(nextPolicy, options, tracingOptions);\n    },\n  };\n}\n\n/**\n * A policy that wraps outgoing requests with a tracing span.\n */\nexport class TracingPolicy extends BaseRequestPolicy {\n  private userAgent?: string;\n\n  constructor(\n    nextPolicy: RequestPolicy,\n    options: RequestPolicyOptions,\n    tracingOptions: TracingPolicyOptions\n  ) {\n    super(nextPolicy, options);\n    this.userAgent = tracingOptions.userAgent;\n  }\n\n  public async sendRequest(request: WebResourceLike): Promise<HttpOperationResponse> {\n    if (!request.tracingContext) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    const span = this.tryCreateSpan(request);\n\n    if (!span) {\n      return this._nextPolicy.sendRequest(request);\n    }\n\n    try {\n      const response = await this._nextPolicy.sendRequest(request);\n      this.tryProcessResponse(span, response);\n      return response;\n    } catch (err: any) {\n      this.tryProcessError(span, err);\n      throw err;\n    }\n  }\n\n  tryCreateSpan(request: WebResourceLike): Span | undefined {\n    try {\n      // Passing spanOptions as part of tracingOptions to maintain compatibility @azure/core-tracing@preview.13 and earlier.\n      // We can pass this as a separate parameter once we upgrade to the latest core-tracing.\n      const { span } = createSpan(`HTTP ${request.method}`, {\n        tracingOptions: {\n          spanOptions: {\n            ...(request as any).spanOptions,\n            kind: SpanKind.CLIENT,\n          },\n          tracingContext: request.tracingContext,\n        },\n      });\n\n      // If the span is not recording, don't do any more work.\n      if (!span.isRecording()) {\n        span.end();\n        return undefined;\n      }\n\n      const namespaceFromContext = request.tracingContext?.getValue(Symbol.for(\"az.namespace\"));\n\n      if (typeof namespaceFromContext === \"string\") {\n        span.setAttribute(\"az.namespace\", namespaceFromContext);\n      }\n\n      span.setAttributes({\n        \"http.method\": request.method,\n        \"http.url\": request.url,\n        requestId: request.requestId,\n      });\n\n      if (this.userAgent) {\n        span.setAttribute(\"http.user_agent\", this.userAgent);\n      }\n\n      // set headers\n      const spanContext = span.spanContext();\n      const traceParentHeader = getTraceParentHeader(spanContext);\n      if (traceParentHeader && isSpanContextValid(spanContext)) {\n        request.headers.set(\"traceparent\", traceParentHeader);\n        const traceState = spanContext.traceState && spanContext.traceState.serialize();\n        // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent\n        if (traceState) {\n          request.headers.set(\"tracestate\", traceState);\n        }\n      }\n      return span;\n    } catch (error: any) {\n      logger.warning(`Skipping creating a tracing span due to an error: ${error.message}`);\n      return undefined;\n    }\n  }\n\n  private tryProcessError(span: Span, err: any): void {\n    try {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      });\n\n      if (err.statusCode) {\n        span.setAttribute(\"http.status_code\", err.statusCode);\n      }\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n\n  private tryProcessResponse(span: Span, response: HttpOperationResponse): void {\n    try {\n      span.setAttribute(\"http.status_code\", response.status);\n      const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n      if (serviceRequestId) {\n        span.setAttribute(\"serviceRequestId\", serviceRequestId);\n      }\n      span.setStatus({\n        code: SpanStatusCode.OK,\n      });\n      span.end();\n    } catch (error: any) {\n      logger.warning(`Skipping tracing span processing due to an error: ${error.message}`);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}