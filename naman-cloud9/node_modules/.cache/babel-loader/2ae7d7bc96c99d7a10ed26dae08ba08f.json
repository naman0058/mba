{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { XML_ATTRKEY, XML_CHARKEY } from \"./serializer.common\";\n\nif (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {\n  throw new Error(`This library depends on the following DOM objects: [\"document\", \"DOMParser\", \"Node\", \"XMLSerializer\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `);\n}\n\nlet cachedDoc;\n\nfunction getDoc() {\n  if (!cachedDoc) {\n    cachedDoc = document.implementation.createDocument(null, null, null);\n  }\n\n  return cachedDoc;\n}\n\nlet cachedParser;\n\nfunction getParser() {\n  if (!cachedParser) {\n    cachedParser = new DOMParser();\n  }\n\n  return cachedParser;\n}\n\nlet cachedSerializer;\n\nfunction getSerializer() {\n  if (!cachedSerializer) {\n    cachedSerializer = new XMLSerializer();\n  }\n\n  return cachedSerializer;\n} // Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\n\n\nlet ttPolicy;\n\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-http#xml.browser\", {\n    createHTML: s => s\n  });\n}\n\nexport function parseXML(str) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b, _c, _d;\n\n  try {\n    const updatedOptions = {\n      rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"\",\n      includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n      xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n    };\n    const dom = getParser().parseFromString((_d = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(str)) !== null && _d !== void 0 ? _d : str, \"application/xml\");\n    throwIfError(dom);\n    let obj;\n\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n}\nlet errorNS;\n\nfunction getErrorNamespace() {\n  var _a, _b;\n\n  if (errorNS === undefined) {\n    try {\n      const invalidXML = (_a = ttPolicy === null || ttPolicy === void 0 ? void 0 : ttPolicy.createHTML(\"INVALID\")) !== null && _a !== void 0 ? _a : \"INVALID\";\n      errorNS = (_b = getParser().parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0].namespaceURI) !== null && _b !== void 0 ? _b : \"\";\n    } catch (ignored) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n\n  return errorNS;\n}\n\nfunction throwIfError(dom) {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\n\nfunction isElement(node) {\n  return !!node.attributes;\n}\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\n\n\nfunction asElementWithAttributes(node) {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node, options) {\n  let result = {};\n  const childNodeCount = node.childNodes.length;\n  const firstChildNode = node.childNodes[0];\n  const onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;\n  const elementWithAttributes = asElementWithAttributes(node);\n\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i]; // Ignore leading/trailing whitespace nodes\n\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject = domToObject(child, options);\n\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function stringifyXML(content) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b, _c;\n\n  const updatedOptions = {\n    rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : \"root\",\n    includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,\n    xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' + getSerializer().serializeToString(dom);\n}\n\nfunction buildAttributes(attrs) {\n  const result = [];\n\n  for (const key of Object.keys(attrs)) {\n    const attr = getDoc().createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n\n  return result;\n}\n\nfunction buildNode(obj, elementName, options) {\n  if (obj === undefined || obj === null || typeof obj === \"string\" || typeof obj === \"number\" || typeof obj === \"boolean\") {\n    const elem = getDoc().createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = getDoc().createElement(elementName);\n\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}","map":{"version":3,"sources":["../../../src/util/xml.browser.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { SerializerOptions, XML_ATTRKEY, XML_CHARKEY } from \"./serializer.common\";\n\nif (!self.document || !self.DOMParser || !self.Node || !self.XMLSerializer) {\n  throw new Error(\n    `This library depends on the following DOM objects: [\"document\", \"DOMParser\", \"Node\", \"XMLSerializer\"] to parse XML, but some of these are undefined. You may provide a polyfill to make these globally available in order to support your environment. For more information, please refer to https://aka.ms/azsdk/js/web-workers. `\n  );\n}\n\nlet cachedDoc: Document | undefined;\nfunction getDoc(): Document {\n  if (!cachedDoc) {\n    cachedDoc = document.implementation.createDocument(null, null, null);\n  }\n  return cachedDoc;\n}\n\nlet cachedParser: DOMParser | undefined;\nfunction getParser(): DOMParser {\n  if (!cachedParser) {\n    cachedParser = new DOMParser();\n  }\n  return cachedParser;\n}\n\nlet cachedSerializer: XMLSerializer | undefined;\nfunction getSerializer(): XMLSerializer {\n  if (!cachedSerializer) {\n    cachedSerializer = new XMLSerializer();\n  }\n  return cachedSerializer;\n}\n\n// Policy to make our code Trusted Types compliant.\n//   https://github.com/w3c/webappsec-trusted-types\n// We are calling DOMParser.parseFromString() to parse XML payload from Azure services.\n// The parsed DOM object is not exposed to outside. Scripts are disabled when parsing\n// according to the spec.  There are no HTML/XSS security concerns on the usage of\n// parseFromString() here.\nlet ttPolicy: Pick<TrustedTypePolicy, \"createHTML\"> | undefined;\nif (typeof self.trustedTypes !== \"undefined\") {\n  ttPolicy = self.trustedTypes.createPolicy(\"@azure/core-http#xml.browser\", {\n    createHTML: (s) => s,\n  });\n}\n\nexport function parseXML(str: string, opts: SerializerOptions = {}): Promise<any> {\n  try {\n    const updatedOptions: Required<SerializerOptions> = {\n      rootName: opts.rootName ?? \"\",\n      includeRoot: opts.includeRoot ?? false,\n      xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n    };\n    const dom = getParser().parseFromString(\n      (ttPolicy?.createHTML(str) ?? str) as string,\n      \"application/xml\"\n    );\n    throwIfError(dom);\n\n    let obj;\n    if (updatedOptions.includeRoot) {\n      obj = domToObject(dom, updatedOptions);\n    } else {\n      obj = domToObject(dom.childNodes[0], updatedOptions);\n    }\n\n    return Promise.resolve(obj);\n  } catch (err: any) {\n    return Promise.reject(err);\n  }\n}\n\nlet errorNS: string | undefined;\n\nfunction getErrorNamespace(): string {\n  if (errorNS === undefined) {\n    try {\n      const invalidXML = (ttPolicy?.createHTML(\"INVALID\") ?? \"INVALID\") as string;\n      errorNS =\n        getParser().parseFromString(invalidXML, \"text/xml\").getElementsByTagName(\"parsererror\")[0]\n          .namespaceURI! ?? \"\";\n    } catch (ignored: any) {\n      // Most browsers will return a document containing <parsererror>, but IE will throw.\n      errorNS = \"\";\n    }\n  }\n  return errorNS;\n}\n\nfunction throwIfError(dom: Document): void {\n  const parserErrors = dom.getElementsByTagName(\"parsererror\");\n  if (parserErrors.length > 0 && getErrorNamespace()) {\n    for (let i = 0; i < parserErrors.length; i++) {\n      if (parserErrors[i].namespaceURI === errorNS) {\n        throw new Error(parserErrors[i].innerHTML);\n      }\n    }\n  }\n}\n\nfunction isElement(node: Node): node is Element {\n  return !!(node as Element).attributes;\n}\n\n/**\n * Get the Element-typed version of the provided Node if the provided node is an element with\n * attributes. If it isn't, then undefined is returned.\n */\nfunction asElementWithAttributes(node: Node): Element | undefined {\n  return isElement(node) && node.hasAttributes() ? node : undefined;\n}\n\nfunction domToObject(node: Node, options: Required<SerializerOptions>): any {\n  let result: any = {};\n\n  const childNodeCount: number = node.childNodes.length;\n\n  const firstChildNode: Node = node.childNodes[0];\n  const onlyChildTextValue: string | undefined =\n    (firstChildNode &&\n      childNodeCount === 1 &&\n      firstChildNode.nodeType === Node.TEXT_NODE &&\n      firstChildNode.nodeValue) ||\n    undefined;\n\n  const elementWithAttributes: Element | undefined = asElementWithAttributes(node);\n  if (elementWithAttributes) {\n    result[XML_ATTRKEY] = {};\n\n    for (let i = 0; i < elementWithAttributes.attributes.length; i++) {\n      const attr = elementWithAttributes.attributes[i];\n      result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;\n    }\n\n    if (onlyChildTextValue) {\n      result[options.xmlCharKey] = onlyChildTextValue;\n    }\n  } else if (childNodeCount === 0) {\n    result = \"\";\n  } else if (onlyChildTextValue) {\n    result = onlyChildTextValue;\n  }\n\n  if (!onlyChildTextValue) {\n    for (let i = 0; i < childNodeCount; i++) {\n      const child = node.childNodes[i];\n      // Ignore leading/trailing whitespace nodes\n      if (child.nodeType !== Node.TEXT_NODE) {\n        const childObject: any = domToObject(child, options);\n        if (!result[child.nodeName]) {\n          result[child.nodeName] = childObject;\n        } else if (Array.isArray(result[child.nodeName])) {\n          result[child.nodeName].push(childObject);\n        } else {\n          result[child.nodeName] = [result[child.nodeName], childObject];\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function stringifyXML(content: unknown, opts: SerializerOptions = {}): string {\n  const updatedOptions: Required<SerializerOptions> = {\n    rootName: opts.rootName ?? \"root\",\n    includeRoot: opts.includeRoot ?? false,\n    xmlCharKey: opts.xmlCharKey ?? XML_CHARKEY,\n  };\n  const dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];\n  return (\n    '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>' +\n    getSerializer().serializeToString(dom)\n  );\n}\n\nfunction buildAttributes(attrs: { [key: string]: { toString(): string } }): Attr[] {\n  const result = [];\n  for (const key of Object.keys(attrs)) {\n    const attr = getDoc().createAttribute(key);\n    attr.value = attrs[key].toString();\n    result.push(attr);\n  }\n  return result;\n}\n\nfunction buildNode(obj: any, elementName: string, options: Required<SerializerOptions>): Node[] {\n  if (\n    obj === undefined ||\n    obj === null ||\n    typeof obj === \"string\" ||\n    typeof obj === \"number\" ||\n    typeof obj === \"boolean\"\n  ) {\n    const elem = getDoc().createElement(elementName);\n    elem.textContent = obj === undefined || obj === null ? \"\" : obj.toString();\n    return [elem];\n  } else if (Array.isArray(obj)) {\n    const result = [];\n    for (const arrayElem of obj) {\n      for (const child of buildNode(arrayElem, elementName, options)) {\n        result.push(child);\n      }\n    }\n    return result;\n  } else if (typeof obj === \"object\") {\n    const elem = getDoc().createElement(elementName);\n    for (const key of Object.keys(obj)) {\n      if (key === XML_ATTRKEY) {\n        for (const attr of buildAttributes(obj[key])) {\n          elem.attributes.setNamedItem(attr);\n        }\n      } else if (key === options.xmlCharKey) {\n        elem.textContent = obj[key].toString();\n      } else {\n        for (const child of buildNode(obj[key], key, options)) {\n          elem.appendChild(child);\n        }\n      }\n    }\n    return [elem];\n  } else {\n    throw new Error(`Illegal value passed to buildObject: ${obj}`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}