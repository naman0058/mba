{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortController } from \"@azure/abort-controller\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: config => ({\n    status: \"running\",\n    config\n  }),\n  setCanceled: state => state.status = \"canceled\",\n  setError: (state, error) => state.error = error,\n  setResult: (state, result) => state.result = result,\n  setRunning: state => state.status = \"running\",\n  setSucceeded: state => state.status = \"succeeded\",\n  setFailed: state => state.status = \"failed\",\n  getError: state => state.error,\n  getResult: state => state.result,\n  isCanceled: state => state.status === \"canceled\",\n  isFailed: state => state.status === \"failed\",\n  isRunning: state => state.status === \"running\",\n  isSucceeded: state => state.status === \"succeeded\"\n});\n/**\n * Returns a poller factory.\n */\n\n\nexport function buildCreatePoller(inputs) {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful\n  } = inputs;\n  return async (_ref, options) => {\n    let {\n      init,\n      poll\n    } = _ref;\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom\n    } = options || {};\n    const stateProxy = createStateProxy();\n    const withOperationLocation = withOperationLocationCallback ? (() => {\n      let called = false;\n      return (operationLocation, isUpdated) => {\n        if (isUpdated) withOperationLocationCallback(operationLocation);else if (!called) withOperationLocationCallback(operationLocation);\n        called = true;\n      };\n    })() : undefined;\n    const state = restoreFrom ? deserializeState(restoreFrom) : await initOperation({\n      init,\n      stateProxy,\n      processResult,\n      getOperationStatus: getStatusFromInitialResponse,\n      withOperationLocation,\n      setErrorAsResult: !resolveOnUnsuccessful\n    });\n    let resultPromise;\n    let cancelJob;\n    const abortController = new AbortController();\n    const handlers = new Map();\n\n    const handleProgressEvents = async () => handlers.forEach(h => h(state));\n\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n    const poller = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob === null || cancelJob === void 0 ? void 0 : cancelJob();\n      },\n      toString: () => JSON.stringify({\n        state\n      }),\n      onProgress: callback => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: pollOptions => resultPromise !== null && resultPromise !== void 0 ? resultPromise : resultPromise = (async () => {\n        const {\n          abortSignal: inputAbortSignal\n        } = pollOptions || {};\n        const {\n          signal: abortSignal\n        } = inputAbortSignal ? new AbortController([inputAbortSignal, abortController.signal]) : abortController;\n\n        if (!poller.isDone()) {\n          await poller.poll({\n            abortSignal\n          });\n\n          while (!poller.isDone()) {\n            const delay = delayMs(currentPollIntervalInMs);\n            cancelJob = delay.cancel;\n            await delay;\n            await poller.poll({\n              abortSignal\n            });\n          }\n        }\n\n        if (resolveOnUnsuccessful) {\n          return poller.getResult();\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return poller.getResult();\n\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n\n            case \"failed\":\n              throw state.error;\n\n            case \"notStarted\":\n            case \"running\":\n              throw new Error(`Polling completed without succeeding or failing`);\n          }\n        }\n      })().finally(() => {\n        resultPromise = undefined;\n      }),\n\n      async poll(pollOptions) {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n\n            case \"failed\":\n              throw state.error;\n          }\n        }\n\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: pollIntervalInMs => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful\n        });\n        await handleProgressEvents();\n\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      }\n\n    };\n    return poller;\n  };\n}","map":{"version":3,"sources":["../../../src/poller/poller.ts"],"names":[],"mappings":"AAAA;AACA;AAEA,SAAS,eAAT,QAAiD,yBAAjD;AAUA,SAAS,gBAAT,EAA2B,aAA3B,EAA0C,aAA1C,QAA+D,aAA/D;AACA,SAAS,mBAAT,QAAoC,aAApC;AACA,SAAS,OAAT,QAAwB,gBAAxB;;AAEA,MAAM,gBAAgB,GAGlB,OAAO;AACT;;;;AAIG;AACH,EAAA,SAAS,EAAG,MAAD,KAAa;AAAE,IAAA,MAAM,EAAE,SAAV;AAAqB,IAAA;AAArB,GAAb,CANF;AAOT,EAAA,WAAW,EAAG,KAAD,IAAY,KAAK,CAAC,MAAN,GAAe,UAP/B;AAQT,EAAA,QAAQ,EAAE,CAAC,KAAD,EAAQ,KAAR,KAAmB,KAAK,CAAC,KAAN,GAAc,KARlC;AAST,EAAA,SAAS,EAAE,CAAC,KAAD,EAAQ,MAAR,KAAoB,KAAK,CAAC,MAAN,GAAe,MATrC;AAUT,EAAA,UAAU,EAAG,KAAD,IAAY,KAAK,CAAC,MAAN,GAAe,SAV9B;AAWT,EAAA,YAAY,EAAG,KAAD,IAAY,KAAK,CAAC,MAAN,GAAe,WAXhC;AAYT,EAAA,SAAS,EAAG,KAAD,IAAY,KAAK,CAAC,MAAN,GAAe,QAZ7B;AAcT,EAAA,QAAQ,EAAG,KAAD,IAAW,KAAK,CAAC,KAdlB;AAeT,EAAA,SAAS,EAAG,KAAD,IAAW,KAAK,CAAC,MAfnB;AAgBT,EAAA,UAAU,EAAG,KAAD,IAAW,KAAK,CAAC,MAAN,KAAiB,UAhB/B;AAiBT,EAAA,QAAQ,EAAG,KAAD,IAAW,KAAK,CAAC,MAAN,KAAiB,QAjB7B;AAkBT,EAAA,SAAS,EAAG,KAAD,IAAW,KAAK,CAAC,MAAN,KAAiB,SAlB9B;AAmBT,EAAA,WAAW,EAAG,KAAD,IAAW,KAAK,CAAC,MAAN,KAAiB;AAnBhC,CAAP,CAHJ;AAyBA;;AAEG;;;AACH,OAAM,SAAU,iBAAV,CACJ,MADI,EAC+C;AAKnD,QAAM;AACJ,IAAA,oBADI;AAEJ,IAAA,4BAFI;AAGJ,IAAA,yBAHI;AAIJ,IAAA,gBAJI;AAKJ,IAAA,mBALI;AAMJ,IAAA,kBANI;AAOJ,IAAA;AAPI,MAQF,MARJ;AASA,SAAO,aAEL,OAFK,KAGH;AAAA,QAFF;AAAE,MAAA,IAAF;AAAQ,MAAA;AAAR,KAEE;AACF,UAAM;AACJ,MAAA,aADI;AAEJ,MAAA,WAFI;AAGJ,MAAA,qBAAqB,EAAE,6BAHnB;AAIJ,MAAA,YAAY,GAAG,mBAJX;AAKJ,MAAA;AALI,QAMF,OAAO,IAAI,EANf;AAOA,UAAM,UAAU,GAAG,gBAAgB,EAAnC;AACA,UAAM,qBAAqB,GAAG,6BAA6B,GACvD,CAAC,MAAK;AACJ,UAAI,MAAM,GAAG,KAAb;AACA,aAAO,CAAC,iBAAD,EAA4B,SAA5B,KAAkD;AACvD,YAAI,SAAJ,EAAe,6BAA6B,CAAC,iBAAD,CAA7B,CAAf,KACK,IAAI,CAAC,MAAL,EAAa,6BAA6B,CAAC,iBAAD,CAA7B;AAClB,QAAA,MAAM,GAAG,IAAT;AACD,OAJD;AAKD,KAPD,GADuD,GASvD,SATJ;AAUA,UAAM,KAAK,GAAqC,WAAW,GACvD,gBAAgB,CAAC,WAAD,CADuC,GAEvD,MAAM,aAAa,CAAC;AAClB,MAAA,IADkB;AAElB,MAAA,UAFkB;AAGlB,MAAA,aAHkB;AAIlB,MAAA,kBAAkB,EAAE,4BAJF;AAKlB,MAAA,qBALkB;AAMlB,MAAA,gBAAgB,EAAE,CAAC;AAND,KAAD,CAFvB;AAUA,QAAI,aAAJ;AACA,QAAI,SAAJ;AACA,UAAM,eAAe,GAAG,IAAI,eAAJ,EAAxB;AAGA,UAAM,QAAQ,GAAG,IAAI,GAAJ,EAAjB;;AACA,UAAM,oBAAoB,GAAG,YAA2B,QAAQ,CAAC,OAAT,CAAkB,CAAD,IAAO,CAAC,CAAC,KAAD,CAAzB,CAAxD;;AACA,UAAM,YAAY,GAAG,wBAArB;AACA,QAAI,uBAAuB,GAAG,YAA9B;AAEA,UAAM,MAAM,GAAsC;AAChD,MAAA,iBAAiB,EAAE,MAAM,KADuB;AAEhD,MAAA,SAAS,EAAE,MAAM,KAAK,CAAC,MAFyB;AAGhD,MAAA,MAAM,EAAE,MAAM,CAAC,WAAD,EAAc,QAAd,EAAwB,UAAxB,EAAoC,QAApC,CAA6C,KAAK,CAAC,MAAnD,CAHkC;AAIhD,MAAA,SAAS,EAAE,MAAM,aAAa,KAAK,SAJa;AAKhD,MAAA,WAAW,EAAE,MAAK;AAChB,QAAA,eAAe,CAAC,KAAhB;AACA,QAAA,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,EAAT;AACD,OAR+C;AAShD,MAAA,QAAQ,EAAE,MACR,IAAI,CAAC,SAAL,CAAe;AACb,QAAA;AADa,OAAf,CAV8C;AAahD,MAAA,UAAU,EAAG,QAAD,IAAsC;AAChD,cAAM,CAAC,GAAG,MAAM,EAAhB;AACA,QAAA,QAAQ,CAAC,GAAT,CAAa,CAAb,EAAgB,QAAhB;AACA,eAAO,MAAM,QAAQ,CAAC,MAAT,CAAgB,CAAhB,CAAb;AACD,OAjB+C;AAkBhD,MAAA,aAAa,EAAG,WAAD,IACZ,aAAa,KAAA,IAAb,IAAA,aAAa,KAAA,KAAA,CAAb,GAAA,aAAA,GAAA,aAAa,GAAK,CAAC,YAAW;AAC7B,cAAM;AAAE,UAAA,WAAW,EAAE;AAAf,YAAoC,WAAW,IAAI,EAAzD;AACA,cAAM;AAAE,UAAA,MAAM,EAAE;AAAV,YAA0B,gBAAgB,GAC5C,IAAI,eAAJ,CAAoB,CAAC,gBAAD,EAAmB,eAAe,CAAC,MAAnC,CAApB,CAD4C,GAE5C,eAFJ;;AAGA,YAAI,CAAC,MAAM,CAAC,MAAP,EAAL,EAAsB;AACpB,gBAAM,MAAM,CAAC,IAAP,CAAY;AAAE,YAAA;AAAF,WAAZ,CAAN;;AACA,iBAAO,CAAC,MAAM,CAAC,MAAP,EAAR,EAAyB;AACvB,kBAAM,KAAK,GAAG,OAAO,CAAC,uBAAD,CAArB;AACA,YAAA,SAAS,GAAG,KAAK,CAAC,MAAlB;AACA,kBAAM,KAAN;AACA,kBAAM,MAAM,CAAC,IAAP,CAAY;AAAE,cAAA;AAAF,aAAZ,CAAN;AACD;AACF;;AACD,YAAI,qBAAJ,EAA2B;AACzB,iBAAO,MAAM,CAAC,SAAP,EAAP;AACD,SAFD,MAEO;AACL,kBAAQ,KAAK,CAAC,MAAd;AACE,iBAAK,WAAL;AACE,qBAAO,MAAM,CAAC,SAAP,EAAP;;AACF,iBAAK,UAAL;AACE,oBAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;;AACF,iBAAK,QAAL;AACE,oBAAM,KAAK,CAAC,KAAZ;;AACF,iBAAK,YAAL;AACA,iBAAK,SAAL;AACE,oBAAM,IAAI,KAAJ,CAAU,iDAAV,CAAN;AATJ;AAWD;AACF,OA7BkB,IA6Bd,OA7Bc,CA6BN,MAAK;AAChB,QAAA,aAAa,GAAG,SAAhB;AACD,OA/BkB,CAnB2B;;AAmDhD,YAAM,IAAN,CAAW,WAAX,EAA0D;AACxD,YAAI,qBAAJ,EAA2B;AACzB,cAAI,MAAM,CAAC,MAAP,EAAJ,EAAqB;AACtB,SAFD,MAEO;AACL,kBAAQ,KAAK,CAAC,MAAd;AACE,iBAAK,WAAL;AACE;;AACF,iBAAK,UAAL;AACE,oBAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;;AACF,iBAAK,QAAL;AACE,oBAAM,KAAK,CAAC,KAAZ;AANJ;AAQD;;AACD,cAAM,aAAa,CAAC;AAClB,UAAA,IADkB;AAElB,UAAA,KAFkB;AAGlB,UAAA,UAHkB;AAIlB,UAAA,oBAJkB;AAKlB,UAAA,gBALkB;AAMlB,UAAA,qBANkB;AAOlB,UAAA,kBAPkB;AAQlB,UAAA,kBAAkB,EAAE,yBARF;AASlB,UAAA,mBATkB;AAUlB,UAAA,aAVkB;AAWlB,UAAA,WAXkB;AAYlB,UAAA,OAAO,EAAE,WAZS;AAalB,UAAA,QAAQ,EAAG,gBAAD,IAAqB;AAC7B,YAAA,uBAAuB,GAAG,gBAA1B;AACD,WAfiB;AAgBlB,UAAA,gBAAgB,EAAE,CAAC;AAhBD,SAAD,CAAnB;AAkBA,cAAM,oBAAoB,EAA1B;;AACA,YAAI,CAAC,qBAAL,EAA4B;AAC1B,kBAAQ,KAAK,CAAC,MAAd;AACE,iBAAK,UAAL;AACE,oBAAM,IAAI,KAAJ,CAAU,YAAV,CAAN;;AACF,iBAAK,QAAL;AACE,oBAAM,KAAK,CAAC,KAAZ;AAJJ;AAMD;AACF;;AA3F+C,KAAlD;AA6FA,WAAO,MAAP;AACD,GAxID;AAyID","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortController, AbortSignalLike } from \"@azure/abort-controller\";\nimport {\n  BuildCreatePollerOptions,\n  CreatePollerOptions,\n  Operation,\n  OperationState,\n  RestorableOperationState,\n  SimplePollerLike,\n  StateProxy,\n} from \"./models\";\nimport { deserializeState, initOperation, pollOperation } from \"./operation\";\nimport { POLL_INTERVAL_IN_MS } from \"./constants\";\nimport { delayMs } from \"./util/delayMs\";\n\nconst createStateProxy: <TResult, TState extends OperationState<TResult>>() => StateProxy<\n  TState,\n  TResult\n> = () => ({\n  /**\n   * The state at this point is created to be of type OperationState<TResult>.\n   * It will be updated later to be of type TState when the\n   * customer-provided callback, `updateState`, is called during polling.\n   */\n  initState: (config) => ({ status: \"running\", config } as any),\n  setCanceled: (state) => (state.status = \"canceled\"),\n  setError: (state, error) => (state.error = error),\n  setResult: (state, result) => (state.result = result),\n  setRunning: (state) => (state.status = \"running\"),\n  setSucceeded: (state) => (state.status = \"succeeded\"),\n  setFailed: (state) => (state.status = \"failed\"),\n\n  getError: (state) => state.error,\n  getResult: (state) => state.result,\n  isCanceled: (state) => state.status === \"canceled\",\n  isFailed: (state) => state.status === \"failed\",\n  isRunning: (state) => state.status === \"running\",\n  isSucceeded: (state) => state.status === \"succeeded\",\n});\n\n/**\n * Returns a poller factory.\n */\nexport function buildCreatePoller<TResponse, TResult, TState extends OperationState<TResult>>(\n  inputs: BuildCreatePollerOptions<TResponse, TState>\n): (\n  lro: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n  options?: CreatePollerOptions<TResponse, TResult, TState>\n) => Promise<SimplePollerLike<TState, TResult>> {\n  const {\n    getOperationLocation,\n    getStatusFromInitialResponse,\n    getStatusFromPollResponse,\n    isOperationError,\n    getResourceLocation,\n    getPollingInterval,\n    resolveOnUnsuccessful,\n  } = inputs;\n  return async (\n    { init, poll }: Operation<TResponse, { abortSignal?: AbortSignalLike }>,\n    options?: CreatePollerOptions<TResponse, TResult, TState>\n  ) => {\n    const {\n      processResult,\n      updateState,\n      withOperationLocation: withOperationLocationCallback,\n      intervalInMs = POLL_INTERVAL_IN_MS,\n      restoreFrom,\n    } = options || {};\n    const stateProxy = createStateProxy<TResult, TState>();\n    const withOperationLocation = withOperationLocationCallback\n      ? (() => {\n          let called = false;\n          return (operationLocation: string, isUpdated: boolean) => {\n            if (isUpdated) withOperationLocationCallback(operationLocation);\n            else if (!called) withOperationLocationCallback(operationLocation);\n            called = true;\n          };\n        })()\n      : undefined;\n    const state: RestorableOperationState<TState> = restoreFrom\n      ? deserializeState(restoreFrom)\n      : await initOperation({\n          init,\n          stateProxy,\n          processResult,\n          getOperationStatus: getStatusFromInitialResponse,\n          withOperationLocation,\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n    let resultPromise: Promise<TResult> | undefined;\n    let cancelJob: (() => void) | undefined;\n    const abortController = new AbortController();\n    // Progress handlers\n    type Handler = (state: TState) => void;\n    const handlers = new Map<symbol, Handler>();\n    const handleProgressEvents = async (): Promise<void> => handlers.forEach((h) => h(state));\n    const cancelErrMsg = \"Operation was canceled\";\n    let currentPollIntervalInMs = intervalInMs;\n\n    const poller: SimplePollerLike<TState, TResult> = {\n      getOperationState: () => state,\n      getResult: () => state.result,\n      isDone: () => [\"succeeded\", \"failed\", \"canceled\"].includes(state.status),\n      isStopped: () => resultPromise === undefined,\n      stopPolling: () => {\n        abortController.abort();\n        cancelJob?.();\n      },\n      toString: () =>\n        JSON.stringify({\n          state,\n        }),\n      onProgress: (callback: (state: TState) => void) => {\n        const s = Symbol();\n        handlers.set(s, callback);\n        return () => handlers.delete(s);\n      },\n      pollUntilDone: (pollOptions?: { abortSignal?: AbortSignalLike }) =>\n        (resultPromise ??= (async () => {\n          const { abortSignal: inputAbortSignal } = pollOptions || {};\n          const { signal: abortSignal } = inputAbortSignal\n            ? new AbortController([inputAbortSignal, abortController.signal])\n            : abortController;\n          if (!poller.isDone()) {\n            await poller.poll({ abortSignal });\n            while (!poller.isDone()) {\n              const delay = delayMs(currentPollIntervalInMs);\n              cancelJob = delay.cancel;\n              await delay;\n              await poller.poll({ abortSignal });\n            }\n          }\n          if (resolveOnUnsuccessful) {\n            return poller.getResult() as TResult;\n          } else {\n            switch (state.status) {\n              case \"succeeded\":\n                return poller.getResult() as TResult;\n              case \"canceled\":\n                throw new Error(cancelErrMsg);\n              case \"failed\":\n                throw state.error;\n              case \"notStarted\":\n              case \"running\":\n                throw new Error(`Polling completed without succeeding or failing`);\n            }\n          }\n        })().finally(() => {\n          resultPromise = undefined;\n        })),\n      async poll(pollOptions?: { abortSignal?: AbortSignalLike }): Promise<void> {\n        if (resolveOnUnsuccessful) {\n          if (poller.isDone()) return;\n        } else {\n          switch (state.status) {\n            case \"succeeded\":\n              return;\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n        await pollOperation({\n          poll,\n          state,\n          stateProxy,\n          getOperationLocation,\n          isOperationError,\n          withOperationLocation,\n          getPollingInterval,\n          getOperationStatus: getStatusFromPollResponse,\n          getResourceLocation,\n          processResult,\n          updateState,\n          options: pollOptions,\n          setDelay: (pollIntervalInMs) => {\n            currentPollIntervalInMs = pollIntervalInMs;\n          },\n          setErrorAsResult: !resolveOnUnsuccessful,\n        });\n        await handleProgressEvents();\n        if (!resolveOnUnsuccessful) {\n          switch (state.status) {\n            case \"canceled\":\n              throw new Error(cancelErrMsg);\n            case \"failed\":\n              throw state.error;\n          }\n        }\n      },\n    };\n    return poller;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}